<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>基于DCT技术的音频隐写破解</title>
    <url>/2023/12/06/DCT%E5%9B%BE%E7%89%87%E6%B0%B4%E5%8D%B0%E7%A0%B4%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="尝试阶段"><a href="#尝试阶段" class="headerlink" title="尝试阶段"></a>尝试阶段</h2><p>使用Audacity工具观察音频的波形图和频谱图，什么信息也没发现。</p>
<p><img src="D:\PicGo\typoraimage\image-20231206211421312.png" alt="image-20231206211421312"></p>
<p>经过对手组提示，我们知道了他们对这段音频进行了LSB处理和DCT处理，而我讲负责DCT部分的解密。</p>
<h2 id="分析阶段"><a href="#分析阶段" class="headerlink" title="分析阶段"></a>分析阶段</h2><p>对手组使用DCT技术在音频中嵌入了图像水印。</p>
<p>数字水印技术是一种信息隐藏技术。音频数字水印算法就是将数字水印通过水印嵌入算法嵌入到音频文件中，例如（.wav、.mp3、.avi等），但人耳无法分辨嵌入前后的细微差别。</p>
<h3 id="傅里叶变换（DFT）"><a href="#傅里叶变换（DFT）" class="headerlink" title="傅里叶变换（DFT）"></a>傅里叶变换（DFT）</h3><p>傅里叶级数：将一个周期的信号分解成无限多离散的正弦波。（在时域是一个周期且连续的函数，在频域则是一个非周期离散的函数）</p>
<p>傅里叶变换：将一个时域非周期的连续信号，转换为一个在频域非周期的连续信号。</p>
<p><img src="D:\PicGo\typoraimage\image-20231207150257287.png" alt="image-20231207150257287"></p>
<p>DCT：即离散余弦变换，是一种特殊的DTF，即输入信号为实偶函数的DFT变换。将一个时域的信号转换到频域上。</p>
<p>经过查阅参考资料1，DCT水印算法的思想如下：</p>
<ol>
<li><p>将原始音频转换为多声道数组（m*n），因为容纳图片需要更大的数组。然后对数组进行分块，假设得到了n个块</p>
</li>
<li><p>将需要嵌入的图像水印转换为灰度图像，大小为w*h</p>
</li>
<li><p>随机生成k密钥。密钥的维度和块维度相同。</p>
</li>
<li><p>水印的每个像素点可以看作特征点，因此有feature&#x3D;w*h个特征点。（如果n&lt;&#x3D;feature，则无法嵌入该图像水印）</p>
</li>
<li><p>取出第i个特征点的像素值，计算出change[i] &#x3D; k[i] x pixel_value</p>
</li>
<li><p>计算第i个原始音频块的DCT系数，称为dct block</p>
</li>
<li><p>将change[i] 嵌入第i个dct block中的最后一行或者最后一列中，dct block[i, collum − 1]+ &#x3D; change[i]</p>
</li>
<li><p>计算第i个dct block的逆DCT并保存</p>
</li>
<li><p>重复上述5~8，直至所有特征点都嵌入完成</p>
</li>
<li><p>得到嵌入水印的音频</p>
</li>
</ol>
<p>PS：图片的像素点可以进行二值归一化，1代表黑色像素点，0表示白色像素点。</p>
<p><img src="D:\PicGo\typoraimage\image-20231207213429486.png" alt="image-20231207213429486"></p>
<h2 id="破解阶段"><a href="#破解阶段" class="headerlink" title="破解阶段"></a>破解阶段</h2><p>相应的，如果我们要从一段使用了DCT技术隐藏了图片水印的音频中提取出该水印，我们的步骤应该是：</p>
<ol>
<li><p>将音频数据按照一定长度分成多个块</p>
</li>
<li><p>对每个块进行DCT变换，得到DCT系数</p>
</li>
<li><p>从每个DCT系数中提取出嵌入的水印图像的像素值，得到时域图像</p>
</li>
<li><p>根据提取的像素值恢复水印图像</p>
</li>
</ol>
<p><img src="D:\PicGo\typoraimage\image-20231207213441830.png" alt="image-20231207213441830"></p>
<p>水印图片提取函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">DCT</span>(<span class="params">data</span>):</span><br><span class="line">    dct_audio = dct(data,norm =<span class="string">&#x27;ortho&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> dct_audio</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getLastBit</span>(<span class="params">number</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(number) <span class="keyword">in</span> (<span class="built_in">int</span>, np.int16, np.int64):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(number % <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">type</span>(number) <span class="keyword">in</span> (<span class="built_in">float</span>, np.float64):</span><br><span class="line">        whole, dec = splitFloat(number)</span><br><span class="line">        <span class="keyword">return</span> getLastBit(whole)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dct_extract</span>(<span class="params">audio,<span class="built_in">len</span>,random</span>):</span><br><span class="line">    numFrames = math.ceil(audio.shape[<span class="number">0</span>] / <span class="built_in">len</span>)</span><br><span class="line">    <span class="built_in">print</span>(numFrames)</span><br><span class="line">    numFrames = numFrames - <span class="number">1</span></span><br><span class="line">    frames = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numFrames):</span><br><span class="line">        frames.append(audio[i * <span class="built_in">len</span>: (i * <span class="built_in">len</span>) + <span class="built_in">len</span>])</span><br><span class="line">        <span class="comment"># 将小块存储在frame列表中</span></span><br><span class="line"></span><br><span class="line">    DCTCoeffs = np.zeros((numFrames, <span class="built_in">len</span>))</span><br><span class="line">    <span class="comment"># 创建二维数组，存储每个小块的DCT系数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numFrames):</span><br><span class="line">        DCTCoeffs[i] = DCT(frames[i])</span><br><span class="line">        <span class="comment"># 对每个小块进行DCT变换，将得到的DCT系数存储在二维数组中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numFrames):</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            audio0 = DCTCoeffs[i]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            audio0 = np.concatenate((audio0, DCTCoeffs[i]), axis=<span class="number">0</span>)</span><br><span class="line">            <span class="comment"># 将所有小块的DCT系数拼接成一维数组audio0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    width, heigth = (<span class="number">112</span>, <span class="number">112</span>)  <span class="comment"># sizeExtraction(joinAudio)</span></span><br><span class="line">    image = Image.new(<span class="string">&quot;1&quot;</span>, (width, heigth))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(heigth):</span><br><span class="line">            x = i * heigth + j</span><br><span class="line">            r = random[x]</span><br><span class="line">            value = getLastBit(audio0[r])</span><br><span class="line">            image.putpixel(xy=(i, j), value=value)</span><br><span class="line">            <span class="comment"># 根据提供的随机数组random，以及getLastBit函数，构建一个112x112的图片，将提取的水印信息写入图片中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> image</span><br></pre></td></tr></table></figure>

<ol>
<li><p>对numFrames进行减1操作的目的是为了确保音频可以被完整地分成整数个长度为len的小块。</p>
<p>因为在处理音频时，通常将其分割成固定长度的小块进行处理，但是最后一个小块大概率没有填满整个长度len，所以将numFrames-1，以忽略最后一个不完整的小块。</p>
</li>
<li><p>DCT函数调用了numpy中的dct函数进行DCT变换</p>
</li>
<li><p>在将音频信号分成小块后，我们可以使用DCT变换将每个小块转换为其在频域上的表示。</p>
<p>在最后生成图片的过程中，我们可以使用经过处理的DCT系数来构建一张新的图像，以便显示水印信息。这样做的好处是，由于DCT系数对应于音频小块中不同的频率成分，因此可以用来更好地表示水印信息，并且可以减少由于噪声或其他干扰因素引起的误差。因此，使用DCT变换可以帮助我们更好地实现从音频中提取水印信息的目标。</p>
</li>
</ol>
<p>主函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    root = <span class="string">&quot;..&quot;</span></span><br><span class="line">    resultList = random.sample(<span class="built_in">range</span>(<span class="number">0</span>, <span class="number">100000</span>), <span class="number">112</span>*<span class="number">112</span>)</span><br><span class="line">    frames = <span class="number">20</span></span><br><span class="line">    samplerate, data = wavfile.read(<span class="string">&quot;sample.wav&quot;</span>)</span><br><span class="line">    extract_watermark = dct_extract(audio=data,<span class="built_in">len</span>=frames,random = resultList)</span><br><span class="line">    extract_watermark.save(<span class="string">&quot;extract_watermark.png&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>得到的图片水印：</p>
<p><img src="D:\PicGo\typoraimage\image-20231207214702158.png" alt="image-20231207214702158"></p>
<p>参考资料:</p>
<ol>
<li><p>应用DCT实现对音频水印的添加和提取  [<a href="https://weipp7.gitee.io/posts/e1e00902.html#%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81%E6%80%9D%E8%B7%AF]">https://weipp7.gitee.io/posts/e1e00902.html#%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81%E6%80%9D%E8%B7%AF]</a></p>
</li>
<li><p>傅里叶分析之掐死教程（完整版）  韩昊  [<a href="https://zhuanlan.zhihu.com/p/19763358]">https://zhuanlan.zhihu.com/p/19763358]</a></p>
</li>
<li><p>信号处理–离散傅里叶变换（DFT） [<a href="https://blog.csdn.net/qq_45732223/article/details/109772898]">https://blog.csdn.net/qq_45732223/article/details/109772898]</a></p>
</li>
<li><p>数字音频信息隐藏课件 陈文</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>夜</title>
    <url>/2023/07/04/%E5%A4%9C/</url>
    <content><![CDATA[<p>夜晚不说话</p>
<p>只会生产寂寞</p>
<p>夜晚不洞察</p>
<p>只会导致沉默</p>
<br />

<p>入夜，</p>
<p>我才是我</p>
<p>黑暗才是脉搏</p>
<br />

<p>2022.11.12凌晨</p>
]]></content>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/2023/07/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>原文出自：图解算法数据结构 - LeetBook</p>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>数据大小：N</p>
<ul>
<li><p>时间复杂度统计的是「计算操作数量」, 而不是「运行的绝对时间」</p>
</li>
<li><p>体现的是计算操作随数据大小 N 变化时的变化情况</p>
</li>
<li><p>常见种类排列：<img src="D:\PicGo\typoraimage\image-20230916161030379.png" alt="image-20230916161030379"></p>
</li>
</ul>
<p><img src="D:\PicGo\typoraimage\image-20230916161036405.png" alt="image-20230916161036405"></p>
<p>PS： log<del>2</del> N 通常写作 log N</p>
<p>e.g.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">algorithm</span>(<span class="params">N</span>):</span><br><span class="line"><span class="keyword">if</span> N &lt;= <span class="number">0</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">count_1 = algorithm(N - <span class="number">1</span>)</span><br><span class="line">count_2 = algorithm(N - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> count_1 + count_2</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(2^N^)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">algorithm</span>(<span class="params">N</span>):</span><br><span class="line"><span class="keyword">if</span> N &lt;= <span class="number">0</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">count_1 = algorithm(N - <span class="number">1</span>)</span><br><span class="line">count_2 = algorithm(N - <span class="number">1</span>)</span><br><span class="line">count_3 = algorithm(N - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> count_1 + count_2 + count_3</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(3^N^)</p>
<p>对数阶常出现于「二分法」、「分治」等算法中，体现着 “一分为二” 或 “一分为多” 的算法思想。</p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>空间复杂度涉及的空间类型有：</p>
<ul>
<li>输入空间：存储输入数据所需的空间大小；</li>
<li>暂存空间：算法运行过程中，存储所有中间变量和对象等数据所需的空间大小；</li>
<li>输出空间：算法运行返回时，存储输出数据所需的空间大小；</li>
</ul>
<p><img src="D:\PicGo\typoraimage\image-20230916163330766.png" alt="image-20230916163330766"></p>
<p>通常情况下，空间复杂度指在输入数据大小为 N 时，算法运行所使用的「暂存空间」+「输出空间」的总体大小。</p>
<p>而根据不同来源，算法使用的内存空间分为三类：</p>
<ul>
<li><p>指令空间：编译后，程序指令所使用的内存空间。</p>
</li>
<li><p>数据空间：算法中的各项变量使用的空间，包括：声明的常量、变量、动态数组、动态对象等使用的内存空间。</p>
</li>
<li><p>栈帧空间：程序调用函数是基于栈实现的，函数在调用期间，占用常量大小的栈帧空间，直至返回后释放。</p>
</li>
<li><p>常见种类排列：<img src="D:\PicGo\typoraimage\image-20230916170644798.png" alt="image-20230916170644798"></p>
</li>
</ul>
<p><img src="D:\PicGo\typoraimage\image-20230916170653116.png" alt="image-20230916170653116"></p>
<h2 id="数据结构简介"><a href="#数据结构简介" class="headerlink" title="数据结构简介"></a>数据结构简介</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是将相同类型的元素存储于连续内存空间的数据结构，长度不可变。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] array = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>

<p><img src="D:\PicGo\typoraimage\image-20230916180645749.png" alt="image-20230916180645749"></p>
<p>「可变数组」是经常使用的数据结构，其基于数组和扩容机制实现，相比普通数组更加灵活。常用操作有：访问元素、添加元素、删除元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化可变数组</span></span><br><span class="line">List&lt;Integer&gt; array = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//向尾部添加元素</span></span><br><span class="line">array.add(<span class="number">2</span>);</span><br><span class="line">array.add(<span class="number">3</span>);</span><br><span class="line">array.add(<span class="number">1</span>);</span><br><span class="line">array.add(<span class="number">0</span>);</span><br><span class="line">array.add(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>



<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表以节点为单位，每个元素都是一个独立对象，在内存空间的存储是<strong>非连续</strong>的。链表的节点对象具有两个成员变量：「值 <code>val</code>」，「后继节点引用 <code>next</code>」 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例化节点</span></span><br><span class="line"><span class="type">ListNode</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">4</span>); <span class="comment">// 节点 head</span></span><br><span class="line"><span class="type">ListNode</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">5</span>);</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">n3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建引用指向</span></span><br><span class="line">n1.next = n2;</span><br><span class="line">n2.next = n3;</span><br></pre></td></tr></table></figure>

<p><img src="D:\PicGo\typoraimage\image-20230916181128417.png" alt="image-20230916181128417"></p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈是一种具有 「先入后出」 特点的抽象数据结构，可使用数组或链表实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>PS： python中，列表可以当栈使用</p>
<p>如下图所示，通过常用操作「入栈 <code>push()</code>」,「出栈 <code>pop()</code>」，展示了栈的先入后出特性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stack.push(<span class="number">1</span>); <span class="comment">// 元素 1 入栈</span></span><br><span class="line">stack.push(<span class="number">2</span>); <span class="comment">// 元素 2 入栈</span></span><br><span class="line">stack.pop();   <span class="comment">// 出栈 -&gt; 元素 2</span></span><br><span class="line">stack.pop();   <span class="comment">// 出栈 -&gt; 元素 1</span></span><br></pre></td></tr></table></figure>

<p><img src="D:\PicGo\typoraimage\image-20230916181855600.png" alt="image-20230916181855600"></p>
<p>PS： 注意：通常情况下，不推荐使用 Java 的 <code>Vector</code> 以及其子类 <code>Stack</code> ，而一般将 <code>LinkedList</code> 作为栈来使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">stack.addLast(<span class="number">1</span>);   <span class="comment">// 元素 1 入栈</span></span><br><span class="line">stack.addLast(<span class="number">2</span>);   <span class="comment">// 元素 2 入栈</span></span><br><span class="line">stack.removeLast(); <span class="comment">// 出栈 -&gt; 元素 2</span></span><br><span class="line">stack.removeLast(); <span class="comment">// 出栈 -&gt; 元素 1</span></span><br></pre></td></tr></table></figure>



<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列是一种具有 「先入先出」 特点的抽象数据结构，可使用链表实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>PS: LinkedList是</p>
<p>通过常用操作「入队 <code>offer()</code>」,「出队 <code>poll()</code>」，展示了队列的先入先出特性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">queue.offer(<span class="number">1</span>); <span class="comment">// 元素 1 入队</span></span><br><span class="line">queue.offer(<span class="number">2</span>); <span class="comment">// 元素 2 入队</span></span><br><span class="line">queue.poll();   <span class="comment">// 出队 -&gt; 元素 1</span></span><br><span class="line">queue.poll();   <span class="comment">// 出队 -&gt; 元素 2</span></span><br></pre></td></tr></table></figure>

<p><img src="D:\PicGo\typoraimage\image-20230916183306075.png" alt="image-20230916183306075"></p>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>树是一种非线性数据结构，根据子节点数量可分为 「二叉树」 和 「多叉树」，最顶层的节点称为「根节点 <code>root</code>」。以二叉树为例，每个节点包含三个成员变量：「值 <code>val</code>」、「左子节点 <code>left</code>」、「右子节点 <code>right</code>」 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;		<span class="comment">// 节点值</span></span><br><span class="line">    TreeNode left;	<span class="comment">// 左子节点</span></span><br><span class="line">    TreeNode right;	<span class="comment">// 右子节点</span></span><br><span class="line">    TreeNode(<span class="type">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建立此二叉树需要实例化每个节点，并构建各节点的引用指向。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化节点</span></span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">3</span>); <span class="comment">// 根节点 root</span></span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">4</span>);</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">n3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">5</span>);</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">n4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">n5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建引用指向</span></span><br><span class="line">n1.left = n2;</span><br><span class="line">n1.right = n3;</span><br><span class="line">n2.left = n4;</span><br><span class="line">n2.right = n5;</span><br></pre></td></tr></table></figure>

<p><img src="D:\PicGo\typoraimage\image-20230916184358517.png" alt="image-20230916184358517"></p>
<h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p>图是一种非线性数据结构，由「节点（顶点）<code>vertex</code>」和「边  <code>edge</code>」组成，每条边连接一对顶点。根据边的方向有无，图可分为「有向图」和「无向图」。本文 <strong>以无向图为例</strong> 开展介绍。</p>
<p>如下图所示，此无向图的 <strong>顶点</strong> 和 <strong>边</strong> 集合分别为：</p>
<ul>
<li>顶点集合：<code>vertices = &#123;1, 2, 3, 4, 5&#125;</code></li>
<li>边集合：<code>edges = &#123;(1, 2), (1, 3), (1, 4), (1, 5), (2, 4), (3, 5), (4, 5)&#125;</code></li>
</ul>
<p><img src="D:\PicGo\typoraimage\image-20230916185349362.png" alt="image-20230916185349362"></p>
<p>表示图的方法通常有两种</p>
<ol>
<li><strong>邻接矩阵</strong>：使用数组 <code>vertice</code> 存储顶点，邻接矩阵 <code>edges</code> 存储边； <code>edges[i][j]</code> 代表节点 <code>i+1</code> 和 节点 <code>j+1</code> 之间是否有边。</li>
</ol>
<p><img src="D:\PicGo\typoraimage\image-20230916185709606.png" alt="image-20230916185709606"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] vertices = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span>[][] edges = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                 &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                 &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                 &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                 &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>邻接表： 使用数组 <code>vertices</code> 存储顶点，邻接表 <code>edges</code> 存储边。 <code>edges</code> 为一个二维容器，第一维 <code>i</code> 代表顶点索引，第二维 <code>edges[i]</code> 存储此顶点对应的边集和；例如 <code>edges[0]=[1,2,3,4]</code> 代表 <code>vertices[0]</code> 的边集合为 <code>[1,2,3,4]</code> 。（和<code>vertices[0]相邻的点有 vertices[1] [2] [3] [4]</code></p>
<p><img src="D:\PicGo\typoraimage\image-20230916191714964.png" alt="image-20230916191714964"></p>
</li>
</ol>
<blockquote>
<p><strong>邻接矩阵 VS 邻接表 ：</strong></p>
<p>邻接矩阵的大小只与节点数量有关，即 N^2^ ，其中 N 为节点数量。因此，当边数量明显少于节点数量时，使用邻接矩阵存储图会造成较大的内存浪费。</p>
<p>因此，邻接表 适合存储稀疏图（顶点较多、边较少）； 邻接矩阵 适合存储稠密图（顶点较少、边较多）。</p>
</blockquote>
<h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><p>散列表是一种非线性数据结构，通过利用 Hash 函数将指定的「键 <code>key</code>」映射至对应的「值 <code>value</code>」，以实现高效的元素查找。</p>
<blockquote>
<p>设想一个简单场景：小力、小特、小扣的学号分别为 10001, 10002, 10003 。</p>
<p>现需求从「姓名」查找「学号」。</p>
</blockquote>
<p>则可通过建立姓名为 <code>key</code> ，学号为 <code>value</code> 的散列表实现此需求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化散列表</span></span><br><span class="line">Map&lt;String, Integer&gt; dic = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 key -&gt; value 键值对</span></span><br><span class="line">dic.put(<span class="string">&quot;小力&quot;</span>, <span class="number">10001</span>);</span><br><span class="line">dic.put(<span class="string">&quot;小特&quot;</span>, <span class="number">10002</span>);</span><br><span class="line">dic.put(<span class="string">&quot;小扣&quot;</span>, <span class="number">10003</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从姓名查找学号</span></span><br><span class="line">dic.get(<span class="string">&quot;小力&quot;</span>); <span class="comment">// -&gt; 10001</span></span><br><span class="line">dic.get(<span class="string">&quot;小特&quot;</span>); <span class="comment">// -&gt; 10002</span></span><br><span class="line">dic.get(<span class="string">&quot;小扣&quot;</span>); <span class="comment">// -&gt; 10003</span></span><br></pre></td></tr></table></figure>

<p><img src="D:\PicGo\typoraimage\image-20230916193525998.png" alt="image-20230916193525998"></p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆是一种基于「完全二叉树」的数据结构，可使用数组实现。以堆为原理的排序算法称为「堆排序」，基于堆实现的数据结构为「优先队列」。堆分为「大顶堆」和「小顶堆」，大（小）顶堆：任意节点的值不大于（小于）其父节点的值。</p>
<blockquote>
<p>完全二叉树定义：设二叉树深度为 k ，若二叉树除第 k 层外的其他各层（第 1 至 k - 1 层）的节点达到最大个数，且处于第 k 层的节点都连续集中在最左边，则此二叉树为完全二叉树。</p>
</blockquote>
<p>如下图所示，为包含 <code>1, 4, 2, 6, 8</code> 元素的小顶堆。将堆（完全二叉树）中的结点按层编号，即可映射到右边的数组存储形式。</p>
<p><img src="D:\PicGo\typoraimage\image-20230916194131268.png" alt="image-20230916194131268"></p>
<p>通过使用「优先队列」的「压入 <code>push()</code>」和「弹出 <code>pop()</code>」操作，即可完成堆排序，实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化小顶堆</span></span><br><span class="line">Queue&lt;Integer&gt; heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素入堆</span></span><br><span class="line">heap.add(<span class="number">1</span>);</span><br><span class="line">heap.add(<span class="number">4</span>);</span><br><span class="line">heap.add(<span class="number">2</span>);</span><br><span class="line">heap.add(<span class="number">6</span>);</span><br><span class="line">heap.add(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素出堆（从小到大）</span></span><br><span class="line">heap.poll(); <span class="comment">// -&gt; 1</span></span><br><span class="line">heap.poll(); <span class="comment">// -&gt; 2</span></span><br><span class="line">heap.poll(); <span class="comment">// -&gt; 4</span></span><br><span class="line">heap.poll(); <span class="comment">// -&gt; 6</span></span><br><span class="line">heap.poll(); <span class="comment">// -&gt; 8</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/07/03/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>网络攻防技术</title>
    <url>/2023/12/20/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h1 id="网络攻防技术"><a href="#网络攻防技术" class="headerlink" title="网络攻防技术"></a>网络攻防技术</h1><h2 id="攻击分类的标准及类别"><a href="#攻击分类的标准及类别" class="headerlink" title="攻击分类的标准及类别*"></a>攻击分类的标准及类别*</h2><p>按照攻击发生时，攻击者与被攻击者之间的交互关系进行分类：</p>
<ol>
<li>本地攻击</li>
<li>主动攻击（服务端攻击）</li>
<li>被动攻击（客户端攻击）</li>
<li>中间人攻击</li>
</ol>
<ul>
<li>本地攻击</li>
</ul>
<p>攻击者通过<strong>实际接触</strong>被攻击的主机而实施的攻击。</p>
<ul>
<li>主动攻击</li>
</ul>
<p>攻击者对被攻击主机所运行的Web、FTP（文件传输协议）、Telnet等<strong>开放网络服务</strong>实施攻击。</p>
<ul>
<li>被动攻击</li>
</ul>
<p>攻击者利用浏览器、邮件接收程序、文字处理程序等<strong>客户端应用程序漏洞或系统用户弱点</strong>，对目标实施各种攻击。</p>
<ul>
<li>中间人攻击</li>
</ul>
<p>指攻击者处于被攻击主机的某个网络应用的<strong>中间人位置</strong>，进行数据窃听、破坏和篡改等攻击。</p>
<h2 id="攻击步骤与方法，每个步骤的详细理解"><a href="#攻击步骤与方法，每个步骤的详细理解" class="headerlink" title="攻击步骤与方法，每个步骤的详细理解*"></a>攻击步骤与方法，每个步骤的详细理解*</h2><p>一个完整的、有预谋的攻击通常可以分为5个步骤：</p>
<ol>
<li>信息收集</li>
<li>权限获取</li>
<li>安装后门</li>
<li>扩大影响</li>
<li>消除痕迹</li>
</ol>
<h3 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a><strong>信息收集</strong></h3><p>任务和目的：尽可能多的收集目标的相关信息，为后续的精确攻击建立基础。</p>
<p>主要方法：</p>
<ul>
<li>主动攻击<ul>
<li>利用公开信息服务</li>
<li>主机扫描与端口扫描</li>
<li>操作系统探测与应用程序类型识别</li>
</ul>
</li>
</ul>
<h3 id="获取权限"><a href="#获取权限" class="headerlink" title="获取权限"></a><strong>获取权限</strong></h3><p>任务和目的：获取目标系统的读、写、执行等权限。</p>
<p>主要方法：</p>
<ul>
<li>主动攻击：<ul>
<li>口令攻击</li>
<li>缓冲区溢出</li>
<li>脚本攻击</li>
</ul>
</li>
<li>被动攻击：<ul>
<li>特洛伊木马</li>
<li>使用邮件、IM等发送恶意链接</li>
</ul>
</li>
</ul>
<h3 id="安装后门"><a href="#安装后门" class="headerlink" title="安装后门"></a><strong>安装后门</strong></h3><p>任务和目的：在目标系统中安装后门程序，以更加方便、更加隐蔽的方式对目标系统进行操控。</p>
<p>主要方法：</p>
<ul>
<li>主机控制木马</li>
<li>Web服务控制木马</li>
</ul>
<h3 id="扩大影响"><a href="#扩大影响" class="headerlink" title="扩大影响"></a><strong>扩大影响</strong></h3><p>任务和目的：以目标系统为“跳板”，对目标所属网络的其他主机进行攻击，最大程度地扩大攻击的效果。</p>
<p>主要方法：</p>
<ul>
<li>可使用远程攻击主机的所有攻击方式</li>
<li>可使用局域网内部攻击所特有的嗅探、假消息攻击等方式</li>
</ul>
<h3 id="清除痕迹"><a href="#清除痕迹" class="headerlink" title="清除痕迹"></a><strong>清除痕迹</strong></h3><p>任务和目的：清除攻击的痕迹，以尽可能长久地对目标进行控制，并防止被识别、追踪。</p>
<p>主要方法：</p>
<ul>
<li>Rootkit隐藏</li>
<li>系统安全日志清除</li>
<li>应用程序日志清除</li>
</ul>
<h2 id="物理攻击与社会工程学"><a href="#物理攻击与社会工程学" class="headerlink" title="物理攻击与社会工程学"></a>物理攻击与社会工程学</h2><h3 id="物理攻击"><a href="#物理攻击" class="headerlink" title="物理攻击"></a><strong>物理攻击</strong></h3><p>定义：通过各种技术手段绕开物理安全防护体系，从而进入受保护的设施场所或设备资源内，获取或破坏信息系统物理媒体中受保护信息的攻击方式。</p>
<h3 id="社会工程学攻击"><a href="#社会工程学攻击" class="headerlink" title="社会工程学攻击"></a><strong>社会工程学攻击</strong></h3><p>定义：利用人类的愚蠢，操纵他人执行预期的动作或泄露机密信息的一门艺术与学问。</p>
<p>技巧：</p>
<ul>
<li>不引人关注的职业，攻击新员工，伪装身份，正面攻击，构造陷阱施以援手，制造陷阱骗取同情与帮助</li>
<li>施以小恩小惠，垃圾搜寻，结合多种技术手段</li>
</ul>
<h1 id="信息收集技术"><a href="#信息收集技术" class="headerlink" title="信息收集技术"></a>信息收集技术</h1><h2 id="公开信息收集的定义、内容、分类及必要性"><a href="#公开信息收集的定义、内容、分类及必要性" class="headerlink" title="公开信息收集的定义、内容、分类及必要性"></a>公开信息收集的定义、内容、分类及必要性</h2><p>定义：</p>
<p>内容：</p>
<p>利用Web服务</p>
<ul>
<li>网站拥有者信息<ul>
<li>邮编、地址</li>
<li>论坛版本号</li>
<li>网络管理员邮箱</li>
<li>公司人员名单、电话、邮箱</li>
<li>……</li>
</ul>
</li>
<li>得到对应的IP地址<ul>
<li>利用DNS服务器：提供域名到IP地址的映射</li>
</ul>
</li>
<li>获取目标网络拓扑结构<ul>
<li>网络拓扑图</li>
<li>IP分配表</li>
<li>子域名</li>
<li>网络设备、安全设施</li>
<li>……</li>
</ul>
</li>
</ul>
<p>利用搜索引擎服务</p>
<ul>
<li><p>共同特定：利用公开信息服务收集信息</p>
<ul>
<li>信息是公开的</li>
<li>海里的信息中很多都是敏感信息</li>
</ul>
</li>
<li><p>搜索引擎为我们提供了在WEB检索信息的功能。它在互联网收集网站摘要信息的同时，也收集了许多隐蔽信息。</p>
</li>
<li><p>Google Hacking就是利用搜索引擎强大的搜索功能，选用<strong>搜索语法</strong>和特殊的<strong>搜索关键字</strong>，将隐藏在目标网站中的不恰当配置信息和后门信息找出来。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">基本语法</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">AND</td>
<td>与</td>
</tr>
<tr>
<td align="center">OR</td>
<td>或</td>
</tr>
<tr>
<td align="center">+</td>
<td>强制包含搜索项</td>
</tr>
<tr>
<td align="center">-</td>
<td>非，去掉搜索项</td>
</tr>
<tr>
<td align="center">“”</td>
<td>包含一个完整的语义</td>
</tr>
<tr>
<td align="center">.</td>
<td>单个通配符</td>
</tr>
<tr>
<td align="center">*</td>
<td>任意通配符</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">高级操作符</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">site:</td>
<td>搜索具体服务器或域名的网页</td>
</tr>
<tr>
<td align="center">filetype:</td>
<td>搜索特定类型的文件</td>
</tr>
<tr>
<td align="center">intitle:</td>
<td>搜索网页标题</td>
</tr>
<tr>
<td align="center">inurl:</td>
<td>搜索URL</td>
</tr>
<tr>
<td align="center">intext:</td>
<td>搜索正文</td>
</tr>
<tr>
<td align="center">link:</td>
<td>搜索连接到指定网页的网页</td>
</tr>
</tbody></table>
<ul>
<li>Google Hacking可以做到<ul>
<li>搜索密码文件</li>
<li>搜索管理员后台URL</li>
<li>搜索Web应用漏洞</li>
<li>搜索黑客留下的后门</li>
<li>……</li>
</ul>
</li>
</ul>
<p>利用Whols服务</p>
<ul>
<li>功能：查询已注册域名的拥有者信息<ul>
<li>域名登记人信息</li>
<li>联系电话和邮箱</li>
<li>域名注册时间和更新时间</li>
<li>权威DNS的IP地址</li>
</ul>
</li>
<li>使用方法：<ul>
<li><a href="http://www.whois.net/">www.whois.net</a></li>
<li>SamSpade 等网络实用工具</li>
<li>利用网站获得Whois数据</li>
<li>企业的备案信息</li>
</ul>
</li>
</ul>
<p>利用DNS域名服务</p>
<ul>
<li>DNS：提供域名到IP地址的映射<ul>
<li>权威DNS——主DNS</li>
<li>Cache-Only DNS——副DNS</li>
</ul>
</li>
<li>区域传送（Zone transfer）：允许一个辅域名服务器更新自己的区域数据</li>
<li>如果DNS配置不当，可能造成内部主机名和IP地址对的泄露</li>
</ul>
<p>公开信息收集方法的应用</p>
<ul>
<li>社会工程学</li>
<li>Maltego：开源情报收集和取证的工具</li>
</ul>
<h2 id="网络扫描的类型（主机-端口-系统类型扫描）、原理"><a href="#网络扫描的类型（主机-端口-系统类型扫描）、原理" class="headerlink" title="网络扫描的类型（主机\端口\系统类型扫描）、原理*"></a>网络扫描的类型（主机\端口\系统类型扫描）、原理*</h2><p>扫描方法可分为两类：</p>
<ul>
<li>主动扫描<ul>
<li>向目标发送探测数据包<strong>获得的回应</strong>来获得目标的信息。</li>
</ul>
</li>
<li>被动扫描<ul>
<li>不主动向外发送数据包，只是通过<strong>捕获网络内传输的数据包</strong>来获得目标的信息。</li>
</ul>
</li>
</ul>
<p>主动扫描：</p>
<ul>
<li>主机扫描：查看目标网络中有哪些主机是存活的。</li>
<li>端口扫描：查看存活的主机运行了哪些服务，比如WWW，FTP，Telnet等。</li>
<li>系统类型扫描：查看目标主机运行的操作系统类型以及版本。</li>
</ul>
<h3 id="主机扫描"><a href="#主机扫描" class="headerlink" title="主机扫描"></a>主机扫描</h3><ul>
<li>Ping</li>
</ul>
<p>​			Ping 使用ICMP（因特网控制报文协议）协议进行工作。</p>
<ul>
<li>ICMP<ul>
<li>ICMP 是IP层的一个部分，主要有两大功能：网络信息查询、IP传送时的差错报告与控制（比如目标不可达、路由重定向）</li>
<li>报文格式：<ul>
<li>类型域（type）：用来指明该ICMP报文的类型</li>
<li>代码域（code）：确定该包具体作用</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="D:\PicGo\typoraimage\image-20231219212017306.png" alt="image-20231219212017306"></p>
<ul>
<li>常见的ICMP报文类型</li>
</ul>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ICMP Destination Unreachable（ICMP 目标不可达）</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">ICMP Source Quench（ICMP 源抑制）</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">ICMP Redirection（ICMP 重定向）</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">ICMP Timestamp Request&#x2F;Reply（ICMP 时间戳请求&#x2F;应答）</td>
<td align="center">13&#x2F;14</td>
</tr>
<tr>
<td align="center">ICMP Address Mask Request&#x2F;Reply（ICMP 子网掩码请求&#x2F;应答）</td>
<td align="center">17&#x2F;18</td>
</tr>
<tr>
<td align="center">ICMP Echo Request&#x2F;Reply（ICMP 响应请求&#x2F;应答）</td>
<td align="center">8&#x2F;0</td>
</tr>
</tbody></table>
<ul>
<li><p>Ping的实现机制</p>
<ul>
<li>向目标主机发送ICMP Echo Request（type 8）数据包，等待回复的ICMP Echo Reply包（type 0）</li>
<li>数据区包含了一些随机测试数据，如“A B C D E F G…”等</li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li>根据RFC的定义，TCP&#x2F;IP协议栈应该支持各种类型的ICMP报文。但事实上，在各个操作系统具体实现TCP&#x2F;IP时，可能并没有完全遵循RFC标准。即某些操作系统不一定会对ICMP子网掩码请求或是ICMP时间戳请求做出应答。</li>
</ul>
</li>
<li><p>高级IP扫描技术</p>
<ul>
<li>构造异常的IP包头<ul>
<li>向目标主机发送包头错误的IP包，目标主机或过滤设备如果存活则会反馈 ICMP Parameter Problem Error信息。常见的伪造错误字段为 Header Length Field 和 IP Options Field。</li>
</ul>
</li>
<li>在IP头中设置无效的字段值<ul>
<li>向目标主机发送的IP包中填充错误的字段值，目标主机或过滤设备如果存则会反馈 ICMP Destination Unreachable 信息。</li>
</ul>
</li>
<li>构造错误的数据分片<ul>
<li>当目标主机接收到错误的数据分片（如某些分片丢失)，并且在规定的时间间隔内得不到更正时，将会丢弃这些数据包，并且向主机发送 ICMP Fragment Reassembly Time Exceeded 报文。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><ul>
<li><p>端口是通信的通道——入侵通道</p>
</li>
<li><p>端口分为TCP端口和UDP端口</p>
</li>
<li><p>端口扫描可以分为：</p>
<ul>
<li>TCP扫描</li>
<li>UDP扫描</li>
</ul>
</li>
</ul>
<h4 id="基本扫描（TCP-Connect）"><a href="#基本扫描（TCP-Connect）" class="headerlink" title="基本扫描（TCP Connect）"></a>基本扫描（TCP Connect）</h4><ul>
<li>用Socket开发TCP应用<ul>
<li>客户端利用 Socket 向服务器端口发送一个 Connect请求，如果服务器正常允许，Connect将返回一个已建立的TCP连接。通过这个连接，客户端和服务器之间完成正常的数据交互。</li>
<li>如果仅仅判断目标主机上的某个端口是否运行着一个服务，那么只需要用 Socket 向目标端口发送一个 Connect请求，再连接建立后关闭即可。</li>
<li>connect()函数<ul>
<li>当返回值为0时，连接成功</li>
</ul>
</li>
<li>优点<ul>
<li>实现简单，几乎所有支持 TCP&#x2F;IP 的操作系统都提供了TCP Connect调用的API</li>
<li>可以用普通用户权限执行</li>
</ul>
</li>
<li>缺点<ul>
<li>容易被防火墙检测</li>
<li>会被目标的操作系统或服务记录</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="D:\PicGo\typoraimage\image-20231220134853794.png" alt="image-20231220134853794"></p>
<h4 id="隐秘扫描（SYN扫描和FIN扫描）"><a href="#隐秘扫描（SYN扫描和FIN扫描）" class="headerlink" title="隐秘扫描（SYN扫描和FIN扫描）"></a>隐秘扫描（SYN扫描和FIN扫描）</h4><ul>
<li><p>特点：</p>
<ul>
<li>扫描必须向目标发送某种数据包，而对于这种数据包，开放端口和关闭端口的响应是有差异的。</li>
<li>这种数据包的发送和接收过程往往不同于正常的TCP数据的发送和接收过程。</li>
</ul>
</li>
<li><p>正常的TCP三次握手:</p>
<ul>
<li>客户端发送SYN包</li>
<li>服务器回送 SYN|ACK 包</li>
<li>客户端回送ACK包</li>
</ul>
</li>
</ul>
<p><img src="D:\PicGo\typoraimage\image-20231220145431762.png" alt="image-20231220145431762"></p>
<p>SYN扫描（也被称为半打开扫描）</p>
<ul>
<li><p>特点：</p>
<ul>
<li><p>即不需要发送最后一个ACK数据包（可以使这次扫描变得隐蔽）</p>
</li>
<li><p>因为我们检测一个端口是否打开，并不需要完全地建立一个连接</p>
</li>
<li><p>只要服务器回送了 SYN|ACK包就说明该端口是打开的</p>
</li>
</ul>
</li>
<li><p>判断端口是否打开：</p>
<ul>
<li>若返回信息为 SYN|ACK，则该端口处于监听状态</li>
<li>若返回信息为RST，则该端口没有处于监听状态</li>
</ul>
</li>
<li><p>优点：</p>
<ul>
<li>一般不会被目标主机的应用所记录</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>运行Raw Socket时必须拥有管理员权限</li>
</ul>
</li>
</ul>
<p>FIN扫描</p>
<ul>
<li>对于FIN报文的回复：<ul>
<li>TCP标准<ul>
<li>关闭的端口：返回RST报文</li>
<li>打开的端口：忽略</li>
</ul>
</li>
<li>Unix BSD操作系统<ul>
<li>与TCP标准一致</li>
</ul>
</li>
<li>其他操作系统<ul>
<li>均返回RST报文</li>
</ul>
</li>
</ul>
</li>
<li>优点：<ul>
<li>不会被记录到日志</li>
<li>可以绕过某些防火墙</li>
<li>Netstate命令不会显示主机收到了扫描（因为该命令只能显示TCP连接或连接的尝试）</li>
</ul>
</li>
<li>缺点：<ul>
<li>使用RAW IP编程，实现起来相对复杂</li>
<li>不同操作系统结果不同，因此不完全可信</li>
</ul>
</li>
</ul>
<h4 id="其他端口扫描技术"><a href="#其他端口扫描技术" class="headerlink" title="其他端口扫描技术"></a>其他端口扫描技术</h4><p>SYN+ACK扫描</p>
<p><strong>TCP XMAS扫描</strong></p>
<p><strong>NULL扫描</strong></p>
<p>IP分段扫描</p>
<p><strong>TCP FTP Proxy扫描</strong></p>
<p>PS： UDP端口扫描技术</p>
<h4 id="端口扫描常用工具"><a href="#端口扫描常用工具" class="headerlink" title="端口扫描常用工具"></a>端口扫描常用工具</h4><p>UNIX下的端口扫描工具</p>
<ul>
<li>Nmap</li>
</ul>
<p>Windows下的端口扫描工具</p>
<ul>
<li>SuperScan</li>
<li>Nmap for windows</li>
</ul>
<h3 id="系统类型扫描"><a href="#系统类型扫描" class="headerlink" title="系统类型扫描"></a>系统类型扫描</h3><h4 id="利用端口扫描的结果"><a href="#利用端口扫描的结果" class="headerlink" title="利用端口扫描的结果"></a>利用端口扫描的结果</h4><p>操作系统往往提供一些自身特有的功能，而这些功能又很有可能打开一些特定的端口。</p>
<ul>
<li>windows： 137、139、445等端口</li>
<li>Linux： 512~514、2049等端口</li>
</ul>
<h4 id="利用Banner"><a href="#利用Banner" class="headerlink" title="利用Banner"></a>利用Banner</h4><p>所谓Banner（旗标）指的是服务程序接收到客户端的正常连接后所给出的欢迎信息。</p>
<p>e.g： 220 *** Microsoft FTP service (version 5.0)</p>
<h4 id="利用-TCP-x2F-IP-协议栈指纹"><a href="#利用-TCP-x2F-IP-协议栈指纹" class="headerlink" title="利用 TCP&#x2F;IP 协议栈指纹"></a>利用 TCP&#x2F;IP 协议栈指纹</h4><p><em>最准确的方式</em></p>
<p>不同的操作系统在实现 TCP&#x2F;IP 协议栈时都或多或少地存在着差异。而这些差异，我们就称之为 TCP&#x2F;IP 协议栈指纹。</p>
<ul>
<li><p>不同的操作系统在实现 TCP&#x2F;IP 协议栈的时候，并不是完全按照 RFC 所定义的标准来实现的。</p>
</li>
<li><p>在 RFC 中也没有对所有的问题给予准确的定义。</p>
</li>
</ul>
<h2 id="漏洞扫描的目的、原理、组件及方法"><a href="#漏洞扫描的目的、原理、组件及方法" class="headerlink" title="漏洞扫描的目的、原理、组件及方法"></a>漏洞扫描的目的、原理、组件及方法</h2><h2 id="网络拓扑探测（拓扑探测-网络设备识别-网络实体IP地理位置定位）"><a href="#网络拓扑探测（拓扑探测-网络设备识别-网络实体IP地理位置定位）" class="headerlink" title="网络拓扑探测（拓扑探测\网络设备识别\网络实体IP地理位置定位）"></a>网络拓扑探测（拓扑探测\网络设备识别\网络实体IP地理位置定位）</h2>]]></content>
  </entry>
  <entry>
    <title>tag</title>
    <url>/tag/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
