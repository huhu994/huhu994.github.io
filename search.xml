<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>/2023/12/06/DCT%E5%9B%BE%E7%89%87%E6%B0%B4%E5%8D%B0%E7%A0%B4%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="基于DCT技术的音频隐写破解"><a href="#基于DCT技术的音频隐写破解" class="headerlink" title="基于DCT技术的音频隐写破解"></a>基于DCT技术的音频隐写破解</h1><h2 id="尝试阶段"><a href="#尝试阶段" class="headerlink" title="尝试阶段"></a>尝试阶段</h2><p>使用Audacity工具观察音频的波形图和频谱图，什么信息也没发现。</p>
<p><img src="D:\PicGo\typoraimage\image-20231206211421312.png" alt="image-20231206211421312"></p>
<p>经过对手组提示，我们知道了他们对这段音频进行了LSB处理和DCT处理，而我讲负责DCT部分的解密。</p>
<h2 id="分析阶段"><a href="#分析阶段" class="headerlink" title="分析阶段"></a>分析阶段</h2><p>对手组使用DCT技术在音频中嵌入了图像水印。</p>
<p>数字水印技术是一种信息隐藏技术。音频数字水印算法就是将数字水印通过水印嵌入算法嵌入到音频文件中，例如（.wav、.mp3、.avi等），但人耳无法分辨嵌入前后的细微差别。</p>
<h3 id="傅里叶变换（DFT）"><a href="#傅里叶变换（DFT）" class="headerlink" title="傅里叶变换（DFT）"></a>傅里叶变换（DFT）</h3><p>傅里叶级数：将一个周期的信号分解成无限多离散的正弦波。（在时域是一个周期且连续的函数，在频域则是一个非周期离散的函数）</p>
<p>傅里叶变换：将一个时域非周期的连续信号，转换为一个在频域非周期的连续信号。</p>
<p><img src="D:\PicGo\typoraimage\image-20231207150257287.png" alt="image-20231207150257287"></p>
<p>DCT：即离散余弦变换，是一种特殊的DTF，即输入信号为实偶函数的DFT变换。将一个时域的信号转换到频域上。</p>
<p>经过查阅参考资料1，DCT水印算法的思想如下：</p>
<ol>
<li><p>将原始音频转换为多声道数组（m*n），因为容纳图片需要更大的数组。然后对数组进行分块，假设得到了n个块</p>
</li>
<li><p>将需要嵌入的图像水印转换为灰度图像，大小为w*h</p>
</li>
<li><p>随机生成k密钥。密钥的维度和块维度相同。</p>
</li>
<li><p>水印的每个像素点可以看作特征点，因此有feature&#x3D;w*h个特征点。（如果n&lt;&#x3D;feature，则无法嵌入该图像水印）</p>
</li>
<li><p>取出第i个特征点的像素值，计算出change[i] &#x3D; k[i] x pixel_value</p>
</li>
<li><p>计算第i个原始音频块的DCT系数，称为dct block</p>
</li>
<li><p>将change[i] 嵌入第i个dct block中的最后一行或者最后一列中，dct block[i, collum − 1]+ &#x3D; change[i]</p>
</li>
<li><p>计算第i个dct block的逆DCT并保存</p>
</li>
<li><p>重复上述5~8，直至所有特征点都嵌入完成</p>
</li>
<li><p>得到嵌入水印的音频</p>
</li>
</ol>
<p>PS：图片的像素点可以进行二值归一化，1代表黑色像素点，0表示白色像素点。</p>
<p><img src="D:\PicGo\typoraimage\image-20231207213429486.png" alt="image-20231207213429486"></p>
<h2 id="破解阶段"><a href="#破解阶段" class="headerlink" title="破解阶段"></a>破解阶段</h2><p>相应的，如果我们要从一段使用了DCT技术隐藏了图片水印的音频中提取出该水印，我们的步骤应该是：</p>
<ol>
<li><p>将音频数据按照一定长度分成多个块</p>
</li>
<li><p>对每个块进行DCT变换，得到DCT系数</p>
</li>
<li><p>从每个DCT系数中提取出嵌入的水印图像的像素值，得到时域图像</p>
</li>
<li><p>根据提取的像素值恢复水印图像</p>
</li>
</ol>
<p><img src="D:\PicGo\typoraimage\image-20231207213441830.png" alt="image-20231207213441830"></p>
<p>水印图片提取函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">DCT</span>(<span class="params">data</span>):</span><br><span class="line">    dct_audio = dct(data,norm =<span class="string">&#x27;ortho&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> dct_audio</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getLastBit</span>(<span class="params">number</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(number) <span class="keyword">in</span> (<span class="built_in">int</span>, np.int16, np.int64):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(number % <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">type</span>(number) <span class="keyword">in</span> (<span class="built_in">float</span>, np.float64):</span><br><span class="line">        whole, dec = splitFloat(number)</span><br><span class="line">        <span class="keyword">return</span> getLastBit(whole)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dct_extract</span>(<span class="params">audio,<span class="built_in">len</span>,random</span>):</span><br><span class="line">    numFrames = math.ceil(audio.shape[<span class="number">0</span>] / <span class="built_in">len</span>)</span><br><span class="line">    <span class="built_in">print</span>(numFrames)</span><br><span class="line">    numFrames = numFrames - <span class="number">1</span></span><br><span class="line">    frames = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numFrames):</span><br><span class="line">        frames.append(audio[i * <span class="built_in">len</span>: (i * <span class="built_in">len</span>) + <span class="built_in">len</span>])</span><br><span class="line">        <span class="comment"># 将小块存储在frame列表中</span></span><br><span class="line"></span><br><span class="line">    DCTCoeffs = np.zeros((numFrames, <span class="built_in">len</span>))</span><br><span class="line">    <span class="comment"># 创建二维数组，存储每个小块的DCT系数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numFrames):</span><br><span class="line">        DCTCoeffs[i] = DCT(frames[i])</span><br><span class="line">        <span class="comment"># 对每个小块进行DCT变换，将得到的DCT系数存储在二维数组中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numFrames):</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            audio0 = DCTCoeffs[i]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            audio0 = np.concatenate((audio0, DCTCoeffs[i]), axis=<span class="number">0</span>)</span><br><span class="line">            <span class="comment"># 将所有小块的DCT系数拼接成一维数组audio0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    width, heigth = (<span class="number">112</span>, <span class="number">112</span>)  <span class="comment"># sizeExtraction(joinAudio)</span></span><br><span class="line">    image = Image.new(<span class="string">&quot;1&quot;</span>, (width, heigth))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(heigth):</span><br><span class="line">            x = i * heigth + j</span><br><span class="line">            r = random[x]</span><br><span class="line">            value = getLastBit(audio0[r])</span><br><span class="line">            image.putpixel(xy=(i, j), value=value)</span><br><span class="line">            <span class="comment"># 根据提供的随机数组random，以及getLastBit函数，构建一个112x112的图片，将提取的水印信息写入图片中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> image</span><br></pre></td></tr></table></figure>

<ol>
<li><p>对numFrames进行减1操作的目的是为了确保音频可以被完整地分成整数个长度为len的小块。</p>
<p>因为在处理音频时，通常将其分割成固定长度的小块进行处理，但是最后一个小块大概率没有填满整个长度len，所以将numFrames-1，以忽略最后一个不完整的小块。</p>
</li>
<li><p>DCT函数调用了numpy中的dct函数进行DCT变换</p>
</li>
<li><p>在将音频信号分成小块后，我们可以使用DCT变换将每个小块转换为其在频域上的表示。</p>
<p>在最后生成图片的过程中，我们可以使用经过处理的DCT系数来构建一张新的图像，以便显示水印信息。这样做的好处是，由于DCT系数对应于音频小块中不同的频率成分，因此可以用来更好地表示水印信息，并且可以减少由于噪声或其他干扰因素引起的误差。因此，使用DCT变换可以帮助我们更好地实现从音频中提取水印信息的目标。</p>
</li>
</ol>
<p>主函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    root = <span class="string">&quot;..&quot;</span></span><br><span class="line">    resultList = random.sample(<span class="built_in">range</span>(<span class="number">0</span>, <span class="number">100000</span>), <span class="number">112</span>*<span class="number">112</span>)</span><br><span class="line">    frames = <span class="number">20</span></span><br><span class="line">    samplerate, data = wavfile.read(<span class="string">&quot;sample.wav&quot;</span>)</span><br><span class="line">    extract_watermark = dct_extract(audio=data,<span class="built_in">len</span>=frames,random = resultList)</span><br><span class="line">    extract_watermark.save(<span class="string">&quot;extract_watermark.png&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>得到的图片水印：</p>
<p><img src="D:\PicGo\typoraimage\image-20231207214702158.png" alt="image-20231207214702158"></p>
<p>参考资料:</p>
<ol>
<li><p>应用DCT实现对音频水印的添加和提取  [<a href="https://weipp7.gitee.io/posts/e1e00902.html#%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81%E6%80%9D%E8%B7%AF]">https://weipp7.gitee.io/posts/e1e00902.html#%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81%E6%80%9D%E8%B7%AF]</a></p>
</li>
<li><p>傅里叶分析之掐死教程（完整版）  韩昊  [<a href="https://zhuanlan.zhihu.com/p/19763358]">https://zhuanlan.zhihu.com/p/19763358]</a></p>
</li>
<li><p>信号处理–离散傅里叶变换（DFT） [<a href="https://blog.csdn.net/qq_45732223/article/details/109772898]">https://blog.csdn.net/qq_45732223/article/details/109772898]</a></p>
</li>
<li><p>数字音频信息隐藏课件 陈文</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/07/03/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>夜</title>
    <url>/2023/07/04/%E5%A4%9C/</url>
    <content><![CDATA[<p>夜晚不说话</p>
<p>只会生产寂寞</p>
<p>夜晚不洞察</p>
<p>只会导致沉默</p>
<br />

<p>入夜，</p>
<p>我才是我</p>
<p>黑暗才是脉搏</p>
<br />

<p>2022.11.12凌晨</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/07/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<hr>
<h2 id="title-数据结构"><a href="#title-数据结构" class="headerlink" title="title:数据结构"></a>title:数据结构</h2><p>原文出自：图解算法数据结构 - LeetBook</p>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>数据大小：N</p>
<ul>
<li><p>时间复杂度统计的是「计算操作数量」, 而不是「运行的绝对时间」</p>
</li>
<li><p>体现的是计算操作随数据大小 N 变化时的变化情况</p>
</li>
<li><p>常见种类排列：<img src="D:\PicGo\typoraimage\image-20230916161030379.png" alt="image-20230916161030379"></p>
</li>
</ul>
<p><img src="D:\PicGo\typoraimage\image-20230916161036405.png" alt="image-20230916161036405"></p>
<p>PS： log<del>2</del> N 通常写作 log N</p>
<p>e.g.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">algorithm</span>(<span class="params">N</span>):</span><br><span class="line"><span class="keyword">if</span> N &lt;= <span class="number">0</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">count_1 = algorithm(N - <span class="number">1</span>)</span><br><span class="line">count_2 = algorithm(N - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> count_1 + count_2</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(2^N^)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">algorithm</span>(<span class="params">N</span>):</span><br><span class="line"><span class="keyword">if</span> N &lt;= <span class="number">0</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">count_1 = algorithm(N - <span class="number">1</span>)</span><br><span class="line">count_2 = algorithm(N - <span class="number">1</span>)</span><br><span class="line">count_3 = algorithm(N - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> count_1 + count_2 + count_3</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(3^N^)</p>
<p>对数阶常出现于「二分法」、「分治」等算法中，体现着 “一分为二” 或 “一分为多” 的算法思想。</p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>空间复杂度涉及的空间类型有：</p>
<ul>
<li>输入空间：存储输入数据所需的空间大小；</li>
<li>暂存空间：算法运行过程中，存储所有中间变量和对象等数据所需的空间大小；</li>
<li>输出空间：算法运行返回时，存储输出数据所需的空间大小；</li>
</ul>
<p><img src="D:\PicGo\typoraimage\image-20230916163330766.png" alt="image-20230916163330766"></p>
<p>通常情况下，空间复杂度指在输入数据大小为 N 时，算法运行所使用的「暂存空间」+「输出空间」的总体大小。</p>
<p>而根据不同来源，算法使用的内存空间分为三类：</p>
<ul>
<li><p>指令空间：编译后，程序指令所使用的内存空间。</p>
</li>
<li><p>数据空间：算法中的各项变量使用的空间，包括：声明的常量、变量、动态数组、动态对象等使用的内存空间。</p>
</li>
<li><p>栈帧空间：程序调用函数是基于栈实现的，函数在调用期间，占用常量大小的栈帧空间，直至返回后释放。</p>
</li>
<li><p>常见种类排列：<img src="D:\PicGo\typoraimage\image-20230916170644798.png" alt="image-20230916170644798"></p>
</li>
</ul>
<p><img src="D:\PicGo\typoraimage\image-20230916170653116.png" alt="image-20230916170653116"></p>
<h2 id="数据结构简介"><a href="#数据结构简介" class="headerlink" title="数据结构简介"></a>数据结构简介</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是将相同类型的元素存储于连续内存空间的数据结构，长度不可变。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] array = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>

<p><img src="D:\PicGo\typoraimage\image-20230916180645749.png" alt="image-20230916180645749"></p>
<p>「可变数组」是经常使用的数据结构，其基于数组和扩容机制实现，相比普通数组更加灵活。常用操作有：访问元素、添加元素、删除元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化可变数组</span></span><br><span class="line">List&lt;Integer&gt; array = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//向尾部添加元素</span></span><br><span class="line">array.add(<span class="number">2</span>);</span><br><span class="line">array.add(<span class="number">3</span>);</span><br><span class="line">array.add(<span class="number">1</span>);</span><br><span class="line">array.add(<span class="number">0</span>);</span><br><span class="line">array.add(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>



<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表以节点为单位，每个元素都是一个独立对象，在内存空间的存储是<strong>非连续</strong>的。链表的节点对象具有两个成员变量：「值 <code>val</code>」，「后继节点引用 <code>next</code>」 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例化节点</span></span><br><span class="line"><span class="type">ListNode</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">4</span>); <span class="comment">// 节点 head</span></span><br><span class="line"><span class="type">ListNode</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">5</span>);</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">n3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建引用指向</span></span><br><span class="line">n1.next = n2;</span><br><span class="line">n2.next = n3;</span><br></pre></td></tr></table></figure>

<p><img src="D:\PicGo\typoraimage\image-20230916181128417.png" alt="image-20230916181128417"></p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈是一种具有 「先入后出」 特点的抽象数据结构，可使用数组或链表实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>PS： python中，列表可以当栈使用</p>
<p>如下图所示，通过常用操作「入栈 <code>push()</code>」,「出栈 <code>pop()</code>」，展示了栈的先入后出特性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stack.push(<span class="number">1</span>); <span class="comment">// 元素 1 入栈</span></span><br><span class="line">stack.push(<span class="number">2</span>); <span class="comment">// 元素 2 入栈</span></span><br><span class="line">stack.pop();   <span class="comment">// 出栈 -&gt; 元素 2</span></span><br><span class="line">stack.pop();   <span class="comment">// 出栈 -&gt; 元素 1</span></span><br></pre></td></tr></table></figure>

<p><img src="D:\PicGo\typoraimage\image-20230916181855600.png" alt="image-20230916181855600"></p>
<p>PS： 注意：通常情况下，不推荐使用 Java 的 <code>Vector</code> 以及其子类 <code>Stack</code> ，而一般将 <code>LinkedList</code> 作为栈来使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">stack.addLast(<span class="number">1</span>);   <span class="comment">// 元素 1 入栈</span></span><br><span class="line">stack.addLast(<span class="number">2</span>);   <span class="comment">// 元素 2 入栈</span></span><br><span class="line">stack.removeLast(); <span class="comment">// 出栈 -&gt; 元素 2</span></span><br><span class="line">stack.removeLast(); <span class="comment">// 出栈 -&gt; 元素 1</span></span><br></pre></td></tr></table></figure>



<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列是一种具有 「先入先出」 特点的抽象数据结构，可使用链表实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>PS: LinkedList是</p>
<p>通过常用操作「入队 <code>offer()</code>」,「出队 <code>poll()</code>」，展示了队列的先入先出特性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">queue.offer(<span class="number">1</span>); <span class="comment">// 元素 1 入队</span></span><br><span class="line">queue.offer(<span class="number">2</span>); <span class="comment">// 元素 2 入队</span></span><br><span class="line">queue.poll();   <span class="comment">// 出队 -&gt; 元素 1</span></span><br><span class="line">queue.poll();   <span class="comment">// 出队 -&gt; 元素 2</span></span><br></pre></td></tr></table></figure>

<p><img src="D:\PicGo\typoraimage\image-20230916183306075.png" alt="image-20230916183306075"></p>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>树是一种非线性数据结构，根据子节点数量可分为 「二叉树」 和 「多叉树」，最顶层的节点称为「根节点 <code>root</code>」。以二叉树为例，每个节点包含三个成员变量：「值 <code>val</code>」、「左子节点 <code>left</code>」、「右子节点 <code>right</code>」 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;		<span class="comment">// 节点值</span></span><br><span class="line">    TreeNode left;	<span class="comment">// 左子节点</span></span><br><span class="line">    TreeNode right;	<span class="comment">// 右子节点</span></span><br><span class="line">    TreeNode(<span class="type">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建立此二叉树需要实例化每个节点，并构建各节点的引用指向。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化节点</span></span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">3</span>); <span class="comment">// 根节点 root</span></span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">4</span>);</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">n3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">5</span>);</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">n4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">n5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建引用指向</span></span><br><span class="line">n1.left = n2;</span><br><span class="line">n1.right = n3;</span><br><span class="line">n2.left = n4;</span><br><span class="line">n2.right = n5;</span><br></pre></td></tr></table></figure>

<p><img src="D:\PicGo\typoraimage\image-20230916184358517.png" alt="image-20230916184358517"></p>
<h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p>图是一种非线性数据结构，由「节点（顶点）<code>vertex</code>」和「边  <code>edge</code>」组成，每条边连接一对顶点。根据边的方向有无，图可分为「有向图」和「无向图」。本文 <strong>以无向图为例</strong> 开展介绍。</p>
<p>如下图所示，此无向图的 <strong>顶点</strong> 和 <strong>边</strong> 集合分别为：</p>
<ul>
<li>顶点集合：<code>vertices = &#123;1, 2, 3, 4, 5&#125;</code></li>
<li>边集合：<code>edges = &#123;(1, 2), (1, 3), (1, 4), (1, 5), (2, 4), (3, 5), (4, 5)&#125;</code></li>
</ul>
<p><img src="D:\PicGo\typoraimage\image-20230916185349362.png" alt="image-20230916185349362"></p>
<p>表示图的方法通常有两种</p>
<ol>
<li><strong>邻接矩阵</strong>：使用数组 <code>vertice</code> 存储顶点，邻接矩阵 <code>edges</code> 存储边； <code>edges[i][j]</code> 代表节点 <code>i+1</code> 和 节点 <code>j+1</code> 之间是否有边。</li>
</ol>
<p><img src="D:\PicGo\typoraimage\image-20230916185709606.png" alt="image-20230916185709606"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] vertices = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span>[][] edges = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                 &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                 &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                 &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                 &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>邻接表： 使用数组 <code>vertices</code> 存储顶点，邻接表 <code>edges</code> 存储边。 <code>edges</code> 为一个二维容器，第一维 <code>i</code> 代表顶点索引，第二维 <code>edges[i]</code> 存储此顶点对应的边集和；例如 <code>edges[0]=[1,2,3,4]</code> 代表 <code>vertices[0]</code> 的边集合为 <code>[1,2,3,4]</code> 。（和<code>vertices[0]相邻的点有 vertices[1] [2] [3] [4]</code></p>
<p><img src="D:\PicGo\typoraimage\image-20230916191714964.png" alt="image-20230916191714964"></p>
</li>
</ol>
<blockquote>
<p><strong>邻接矩阵 VS 邻接表 ：</strong></p>
<p>邻接矩阵的大小只与节点数量有关，即 N^2^ ，其中 N 为节点数量。因此，当边数量明显少于节点数量时，使用邻接矩阵存储图会造成较大的内存浪费。</p>
<p>因此，邻接表 适合存储稀疏图（顶点较多、边较少）； 邻接矩阵 适合存储稠密图（顶点较少、边较多）。</p>
</blockquote>
<h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><p>散列表是一种非线性数据结构，通过利用 Hash 函数将指定的「键 <code>key</code>」映射至对应的「值 <code>value</code>」，以实现高效的元素查找。</p>
<blockquote>
<p>设想一个简单场景：小力、小特、小扣的学号分别为 10001, 10002, 10003 。</p>
<p>现需求从「姓名」查找「学号」。</p>
</blockquote>
<p>则可通过建立姓名为 <code>key</code> ，学号为 <code>value</code> 的散列表实现此需求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化散列表</span></span><br><span class="line">Map&lt;String, Integer&gt; dic = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 key -&gt; value 键值对</span></span><br><span class="line">dic.put(<span class="string">&quot;小力&quot;</span>, <span class="number">10001</span>);</span><br><span class="line">dic.put(<span class="string">&quot;小特&quot;</span>, <span class="number">10002</span>);</span><br><span class="line">dic.put(<span class="string">&quot;小扣&quot;</span>, <span class="number">10003</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从姓名查找学号</span></span><br><span class="line">dic.get(<span class="string">&quot;小力&quot;</span>); <span class="comment">// -&gt; 10001</span></span><br><span class="line">dic.get(<span class="string">&quot;小特&quot;</span>); <span class="comment">// -&gt; 10002</span></span><br><span class="line">dic.get(<span class="string">&quot;小扣&quot;</span>); <span class="comment">// -&gt; 10003</span></span><br></pre></td></tr></table></figure>

<p><img src="D:\PicGo\typoraimage\image-20230916193525998.png" alt="image-20230916193525998"></p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆是一种基于「完全二叉树」的数据结构，可使用数组实现。以堆为原理的排序算法称为「堆排序」，基于堆实现的数据结构为「优先队列」。堆分为「大顶堆」和「小顶堆」，大（小）顶堆：任意节点的值不大于（小于）其父节点的值。</p>
<blockquote>
<p>完全二叉树定义：设二叉树深度为 k ，若二叉树除第 k 层外的其他各层（第 1 至 k - 1 层）的节点达到最大个数，且处于第 k 层的节点都连续集中在最左边，则此二叉树为完全二叉树。</p>
</blockquote>
<p>如下图所示，为包含 <code>1, 4, 2, 6, 8</code> 元素的小顶堆。将堆（完全二叉树）中的结点按层编号，即可映射到右边的数组存储形式。</p>
<p><img src="D:\PicGo\typoraimage\image-20230916194131268.png" alt="image-20230916194131268"></p>
<p>通过使用「优先队列」的「压入 <code>push()</code>」和「弹出 <code>pop()</code>」操作，即可完成堆排序，实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化小顶堆</span></span><br><span class="line">Queue&lt;Integer&gt; heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素入堆</span></span><br><span class="line">heap.add(<span class="number">1</span>);</span><br><span class="line">heap.add(<span class="number">4</span>);</span><br><span class="line">heap.add(<span class="number">2</span>);</span><br><span class="line">heap.add(<span class="number">6</span>);</span><br><span class="line">heap.add(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素出堆（从小到大）</span></span><br><span class="line">heap.poll(); <span class="comment">// -&gt; 1</span></span><br><span class="line">heap.poll(); <span class="comment">// -&gt; 2</span></span><br><span class="line">heap.poll(); <span class="comment">// -&gt; 4</span></span><br><span class="line">heap.poll(); <span class="comment">// -&gt; 6</span></span><br><span class="line">heap.poll(); <span class="comment">// -&gt; 8</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>tag</title>
    <url>/tag/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
